/*     Program - ACTD Format                                              */
/*
 **************************************************************************
 *  PROGRAM NAME: slicgldACTD.pc
 *
 *  PURPOSE: The purpose of this program is to create formatted ACTD records
 *           for the loading of GOLD
 *
 *  INPUTS:   1. Input shelf-life file
 *
 *
 *  OUTPUTS:  1. Formatted ACTD API records
 *
 *
 *  CHANGE HISTORY:
 *   REV     DATE    Programmer                 CHANGE
 *   ---  --------   ----------------------     ------
 *    00  08/15/02   Ben Barth                  Initial coding
 *    01  11/01/02   Ben Barth                  CHAR to VARCHAR conv.
 **************************************************************************
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "gold685_cat1_api.h"
#include "gold685_actd_api.h"
#include "BinTree.h"
#include "str_procs.h"

EXEC SQL INCLUDE sqlca.h;
EXEC SQL INCLUDE oraca.h;

#define NF     1403
#define FND    0
#define MUL    2112

FILE *fpin;
FILE *gold_cat1_fp;
FILE *gold_cat1_in_fp;
FILE *gold_actd_fp;
FILE *fperror;
FILE *fp_delete;

gold68_cat1_api_rcd cat1_rcd;
gold68_actd_api_rcd actd_rcd;

/* Declare database ids */
/*char *slic_db = "slic_db";
char *gold_db = "gold_db";
char slic_dsn[20];
char gold_dsn[20];*/

varchar part[51];
varchar activity_code[51];
varchar lead_time[6];
varchar hold_lead_time[6];
varchar stmt[5000];
varchar temp_part[51];
varchar temp_act_code[51];
char update_create_delete;
char actdinput[200];
char actdoutput[200];
char cat1input[200];
char cat1output[200];
char errfile[200];
char delete_file[200];
char	gold_rcd_exists='N';
char    spaces[]={"                                                                                                    "};

/* Create Array of Valid Activity Codes */
/*valid_act_codes[35][2] = {
                       {'0',0},{'1',3},{'2',6},{'3',9},{'4',12},{'5',18},{'6',24},{'7',36},{'8',48},{'9',60},
                       {'A',1},{'B',2},{'C',3},{'D',4},{'E',5},{'F',6},{'G',9},{'H',12},{'I',72},{'J',15},
                       {'K',18},{'L',21},{'M',24},{'O',27},{'P',30},{'Q',36},{'R',48},{'S',60},{'T',84},
                       {'U',96},{'V',108},{'W',120},{'X',120},{'Y',144},{'Z',240}
                      };
*/
/**  HOST VARIABLES  **/

/*      CAT1 Table Host Variables */

varchar	cat1_prime[51];
varchar	cat1_part[51];

varchar	gold_cat1_part[51];
varchar	gold_cat1_prime[51];
varchar gold_cat_inst_code[13];
varchar	gold_um_issue_code[4];
varchar	gold_noun[41];
varchar	gold_manuf_cage[6];
varchar	gold_nsn[17];
varchar	gold_ave_cap_lead_time[6];
char	gold_security_code;
varchar	gold_pmi_code[21];
varchar	gold_demilitarization_code[21];
varchar	gold_hazardous_material_code[21];
varchar	gold_critical_item_code[21];
varchar	gold_cognizance_code[3];
varchar	gold_smr_code[7];
varchar	gold_source_code[4];
varchar	gold_ims_designator_code[21];
varchar	gold_nsn_smic[3];
varchar gold_cat1_profile[21];
char	gold_order_cap_b;
char	gold_order_gfp_b;
char	gold_delete_when_gone;
char	gold_tracked_b;
char	gold_part_make_b;
char	gold_part_buy_b;
char	gold_hazardous_material_b;
char	gold_lot_batch_mandatory_b;
char	gold_serial_mandatory_b;
char	gold_agency_peculiar_b;
char	gold_mils_auto_process_b;

varchar		ims_designator_code[21];
short		ims_designator_code_i;
varchar		ave_cap_lead_time[6];
short		ave_cap_lead_time_i;
varchar		old_act_code[51];
varchar		structure_code[21];
short		structure_code_i;
varchar		sub_structure_code[21];
short		sub_structure_code_i;
varchar		pos[21];
short		pos_i;
varchar		sc[21];
varchar 	actual_interval[16];
short   	actual_interval_i;
varchar 	warning_interval[16];
short		warning_interval_i;
varchar		category_instrument[21];
short		category_instrument_i;
char 		recurring_b;
short 		recurring_b_i;
varchar 	est_mat_cost[16];
short 		est_mat_cost_i;
varchar 	est_labor_hours[16];
short 		est_labor_hours_i;
char 		master_life_b;
short 		master_life_b_i;
varchar 	est_days[16];
short 		est_days_i;
varchar 	remarks[61];
short 		remarks_i;
varchar 	deviation_rebase[16];
short 		deviation_rebase_i;
char 		auto_rebase_b;
short 		auto_rebase_b_i;
char 		mandatory_b;
short 		mandatory_b_i;
char 		supply_b;
short 		supply_b_i;
char 		operational_b;
short 		operational_b_i;

int errcnt = 0;
int update_cnt = 0;
int create_cnt = 0;
int delete_cnt = 0;

char uidfile[200];
char passfile[200];
char db[20];
char dsn[20];

node *root = NULL;

void initialize();
int process_file();
int validate_activity_code();
int create_cat1_rcd();
int create_actd_rcd();
int delete_actd_rcd();
int query_actd(char flag);
int query_for_accm_defaults();
void check_null_values(char *tbl);
int build_actd_api_rcd(char *type);
int calculate_intervals();
int write_actd_api_rcd();
void print_data();
void print_totals();
void build_cat1_tree();
node *tree_insert(char *str,int length);
node *tree_find(char *str,int length);
int	A999_00_open_files();
int     Z9992_check_cat1_part();

int main(int argc, char **argv)
{
	int errcode = 0;

	if(argc != 7)
	{
		printf("Usage: %s infile outfile errfile delete_file cat1input cat1output\n",argv[0]);
		errcode = 2;
	}
	else
	{
		memset(actdinput, ' ', 200);
		memset(actdoutput, ' ', 200);
		memset(errfile, ' ', 200);
		memset(delete_file, ' ', 200);
		strncpy(actdinput,argv[1],strlen(argv[1]));
		actdinput[strlen(argv[1])] = '\0';
		strncpy(actdoutput,argv[2],strlen(argv[2]));
		actdoutput[strlen(argv[2])] = '\0';
		strncpy(errfile,argv[3],strlen(argv[3]));
		errfile[strlen(argv[3])] = '\0';
		strncpy(delete_file,argv[4],strlen(argv[4]));
		delete_file[strlen(argv[4])] = '\0';
		strncpy(cat1input,argv[5],strlen(argv[5]));
		cat1input[strlen(argv[5])] = '\0';
		strncpy(cat1output,argv[6],strlen(argv[6]));
		cat1output[strlen(argv[6])] = '\0';

/*		printf("%s\n\n",cat1input); */
		
		errcode=A999_00_open_files();
		if(errcode==0)
		{
			/***  CONNECT TO DATABASE  ***/
			Login();
			if(sqlca.sqlcode == 0)
				printf("Connect Successful.\n");
			else
			{
				printf("Error connecting to database.  Exiting.\n");
				db_err("main::Login");
			}

			build_cat1_tree();
			initialize();
			errcode = process_file();

			print_totals();	
			fclose(fpin);
			fclose(gold_actd_fp);
			fclose(gold_cat1_fp);
			fclose(fperror);
			fclose(fp_delete);
		}
	}
	
	return(errcode);
}
/*

*/
int     A999_00_open_files()
{
	int     errcode=0;

	#if DEBUG
		printf("\nA999_00_open_files");
	#endif


	if ((fpin=fopen(actdinput,"r")) == NULL)
	{
		printf("\n***********************************************************");
	    	printf("\n*                                                         *");
		printf("\n* Could not open Input ACTD Activity File (%s) ",actdinput);
		printf("\n*                                                         *");
		printf("\n***********************************************************");
		errcode=500;
	}		
	else
	{
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		printf("\n~                                                                   ~");
		printf("\n~  Processing Input ACTD Activity File (%s) ",actdinput);
		printf("\n~                                                                   ~");
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	}

	if ((gold_actd_fp=fopen(actdoutput,"w")) == NULL)
	{
		printf("\n***********************************************************");
	    	printf("\n*                                                         *");
		printf("\n* Could not open Output ACTD Output File (%s) ",actdoutput);
		printf("\n*                                                         *");
		printf("\n***********************************************************");
		errcode=501;
	}		
	else
	{
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		printf("\n~                                                                   ~");
		printf("\n~  Processing Output ACTD Output File (%s) ",actdoutput);
		printf("\n~                                                                   ~");
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	}

	if ((gold_cat1_in_fp=fopen(cat1input,"r")) == NULL)
	{
		printf("\n***********************************************************");
	    	printf("\n*                                                         *");
		printf("\n* Could not open Input GOLD CAT1 File (%s) ",cat1input);
		printf("\n*                                                         *");
		printf("\n***********************************************************");
		errcode=502;
	}		
	else
	{
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		printf("\n~                                                                   ~");
		printf("\n~  Processing Input GOLD CAT1 File (%s) ",cat1input);
		printf("\n~                                                                   ~");
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	}
	
	if ((gold_cat1_fp=fopen(cat1output,"w")) == NULL)
	{
		printf("\n***********************************************************");
	    	printf("\n*                                                         *");
		printf("\n* Could not open Output GOLD CAT1 File (%s) ",cat1output);
		printf("\n*                                                         *");
		printf("\n***********************************************************");
		errcode=502;
	}		
	else
	{
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		printf("\n~                                                                   ~");
		printf("\n~  Processing Output GOLD CAT1 File (%s) ",cat1output);
		printf("\n~                                                                   ~");
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	}
	
	if ((fperror=fopen(errfile,"w")) == NULL)
	{
		printf("\n***********************************************************");
	    	printf("\n*                                                         *");
		printf("\n* Could not open Output Error File (%s) ",errfile);
		printf("\n*                                                         *");
		printf("\n***********************************************************");
		errcode=503;
	}		
	else
	{
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		printf("\n~                                                                   ~");
		printf("\n~  Processing Output Error File (%s) ",errfile);
		printf("\n~                                                                   ~");
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	}
	
	if ((fp_delete=fopen(delete_file,"w")) == NULL)
	{
		printf("\n***********************************************************");
	    	printf("\n*                                                         *");
		printf("\n* Could not open Output Delete File (%s) ",delete_file);
		printf("\n*                                                         *");
		printf("\n***********************************************************");
		errcode=504;
	}		
	else
	{
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		printf("\n~                                                                   ~");
		printf("\n~  Processing Output Delete File (%s) ",delete_file);
		printf("\n~                                                                   ~");
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	}
	
	
	return(errcode);
}
/*

*/
void initialize()
{
	#if DEBUG
		printf("\ninitialize\n");
		fflush(stdout);
	#endif

	memset(&actd_rcd, ' ', sizeof(gold68_actd_api_rcd));
	memset(&cat1_rcd, ' ', sizeof(gold68_cat1_api_rcd));
/*	
	memset((char *) part.arr, ' ', 50);
	memset((char *) activity_code.arr, ' ', 50);
	memset((char *) lead_time.arr, ' ', 5);
	memset((char *) hold_lead_time.arr, ' ', 5);
	memset((char *) actual_interval.arr, ' ', 15);
	memset((char *) warning_interval.arr, ' ', 15);
	
	memset((char *) ims_designator_code.arr, ' ', 20);
	memset((char *) ave_cap_lead_time.arr, ' ', 5);
	memset((char *) old_act_code.arr, ' ', 50);
	memset((char *) structure_code.arr, ' ', 20);
	memset((char *) sub_structure_code.arr, ' ', 20);
	memset((char *) pos.arr, ' ', 20);	
	memset((char *) sc.arr, ' ', 20);
	memset((char *) category_instrument.arr, ' ', 20);
	memset((char *) actual_interval.arr, ' ', 15);
	memset((char *) warning_interval.arr, ' ', 15);
	memset((char *) est_mat_cost.arr, ' ', 15);
	memset((char *) est_labor_hours.arr, ' ', 15);
	memset((char *) est_days.arr, ' ', 15);
	memset((char *) remarks.arr, ' ', 60);
	memset((char *) deviation_rebase.arr, ' ', 15);
*/
}
/*

*/
int process_file()
{
	int errcode = 0;
	int lt_new_i;
	int lt_old_i;
	char buf[500];

	#if DEBUG
		printf("process_file\n");
		fflush(stdout);
	#endif

	printf("Processing input file...\n\n");	
	memset(buf, ' ', 500);
	while(fgets(buf,500,fpin) != NULL)
	{
		#if DEBUG
			printf("########################################### process_file #######################################\n");
			fflush(stdout);
		#endif
		/*initialize();*/
		strncpy((char *) part.arr,spaces,50);
		strncpy((char *) part.arr,&buf[0],50);
		rtrim((char *) part.arr);
		part.len = strlen((char *) part.arr);
		part.arr[part.len] = '\0';
		
		#if DEBUG
			printf("Part Number (%s)\n",part.arr);
			fflush(stdout);
		#endif

		strncpy((char *) activity_code.arr,&buf[50],50);
		rtrim((char *) activity_code.arr);
		activity_code.len = strlen((char *) activity_code.arr);
		activity_code.arr[activity_code.len] = '\0';

		if(activity_code.arr[0] != '0' && activity_code.arr[0] != ' ')
		{		
			strncpy((char *) lead_time.arr,&buf[100],5);
			lead_time.len = 5;
			lead_time.arr[lead_time.len] = '\0';
			
			update_create_delete = buf[105];
			
			strncpy((char *) temp_part.arr,spaces,50);
			rtrim(strncpy((char *) temp_part.arr,(char *) part.arr,part.len));
			rtrim(strncpy((char *) temp_act_code.arr,(char *) activity_code.arr,activity_code.len));
			#if DEBUG
				printf("(%s) (%s)\n",temp_part.arr,temp_act_code.arr);
				fflush(stdout);
			#endif

			errcode = validate_activity_code();
			
			if(errcode == 0)
			{
				if(update_create_delete != 'C')
					errcode = delete_actd_rcd();

				if(errcode == 0)
					errcode = create_actd_rcd();
				else
				{
					lt_new_i = atoi((char *) lead_time.arr);
					lt_old_i = (int) atoi((char *) hold_lead_time.arr)/30;
					#if DEBUG
						printf("(%s)\nNew (%d) Old (%d)\n",hold_lead_time.arr,lt_new_i,lt_old_i);
					#endif
					if(lt_new_i != lt_old_i)
					{
						errcode = update_actd_rcd();
					}
				}
			}
		}
	}
}
/*

*/
int validate_activity_code()
{
	int errcode = 0;
	char description[51];
	
	#if DEBUG
		printf("validate_activity_code\n");
		printf("Temp Act Code (%s)\n",temp_act_code.arr);
		fflush(stdout);
	#endif

	temp_act_code.len = strlen((char *) temp_act_code.arr);
	temp_act_code.arr[temp_act_code.len] = '\0';

	EXEC SQL SELECT code_description
		INTO :description
		FROM accm
		WHERE activity_code = :temp_act_code;
	
	errcode = sqlca.sqlcode;
	#if DEBUG
		printf("VALIDATE errcode (%d)\n",errcode);
		fflush(stdout);
	#endif
	
	if(errcode == FND || errcode == MUL)
		errcode = 0;
	else
	{
		if(errcode == NF)
		{			
			fprintf(fperror,"PART (%s): %s is not a valid activity code in GOLD\n",temp_part.arr,temp_act_code.arr);
			errcnt++;
			errcode = 500;
		}
		else
			db_err("validate_activity_code");
	}
	
	return(errcode);
}
/*
^L
*/
int query_actd(char flag)
{
    int errcode = 0;

    #if DEBUG
        printf("query_actd\n");
		fflush(stdout);
    #endif

	temp_part.len = strlen((char *) temp_part.arr);
	temp_part.arr[temp_part.len] = '\0';

    memset((char *) stmt.arr, ' ', 5000);
    strcpy((char *) stmt.arr, "select c.ims_designator_code,c.ave_cap_lead_time,a.activity_code,a.structure_code,a.sub_structure_code,");
    strcat((char *) stmt.arr, "a.pos,a.sc,a.actual_interval,a.warning_interval,a.category_instrument,a.recurring_b,a.est_mat_cost,");
    strcat((char *) stmt.arr, "a.est_labor_hours,a.master_life_b,a.est_days,a.remarks,a.deviation_rebase,a.auto_rebase_b,a.mandatory_b,");
    strcat((char *) stmt.arr, "a.supply_b,a.operational_b from cat1 c, actd a, accm b where a.part = '");
	strcat((char *) stmt.arr, (char *) temp_part.arr);
	strcat((char *) stmt.arr, "' and a.part = c.part and a.activity_code = b.activity_code ");
    if(flag == 'U')
	{
        strcat((char *) stmt.arr, "and a.activity_code = '");
		strcat((char *) stmt.arr, (char *) temp_act_code.arr);
		strcat((char *) stmt.arr, "'");
    }
	else if(flag == 'D')
        strcat((char *) stmt.arr, "and b.activity_type = 'SL'");
    stmt.len = strlen((char *) stmt.arr);

    /*
    #if DEBUG
        printf("%s\n",stmt.arr);
		fflush(stdout);
    #endif
    */

    EXEC SQL PREPARE actd_stmt FROM :stmt;
    EXEC SQL DECLARE actd_cur CURSOR FOR actd_stmt;
    if(flag == 'U')
        EXEC SQL OPEN actd_cur;
    else if(flag == 'D')
        EXEC SQL OPEN actd_cur;
    errcode = sqlca.sqlcode;

    return(errcode);
}
/*

*/
int create_actd_rcd()
{
	int errcode = 0;

	#if DEBUG
		printf("create_actd_rcd\n");
		fflush(stdout);
	#endif

	errcode = query_for_accm_defaults();
	if(errcode == FND)
	{
		update_create_delete = 'C';
		errcode = build_actd_api_rcd("create");
		if(errcode == 0)
		{
			create_cnt++;
			errcode = write_actd_api_rcd();
		}
	}
	
	return(errcode);
}

int update_actd_rcd()
{
	int errcode = 0;

	#if DEBUG
		printf("update_actd_rcd\n");
		fflush(stdout);
	#endif

	errcode = query_actd('U');
	if(errcode == FND)
	{
		EXEC SQL FETCH actd_cur INTO
			:ims_designator_code:ims_designator_code_i,
			:ave_cap_lead_time:ave_cap_lead_time_i,
			:old_act_code,
			:structure_code:structure_code_i,
			:sub_structure_code:sub_structure_code_i,
			:pos:pos_i,
			:sc,
			:actual_interval:actual_interval_i,
			:warning_interval:warning_interval_i, 
			:category_instrument:category_instrument_i,
			:recurring_b:recurring_b_i,
			:est_mat_cost:est_mat_cost_i,
			:est_labor_hours:est_labor_hours_i,
			:master_life_b:master_life_b_i,
			:est_days:est_days_i,
			:remarks:remarks_i,
			:deviation_rebase:deviation_rebase_i,
			:auto_rebase_b:auto_rebase_b_i,
			:mandatory_b:mandatory_b_i,
			:supply_b:supply_b_i,
			:operational_b:operational_b_i;

		errcode = sqlca.sqlcode;
		/*
		#if DEBUG
			printf("Fetch Errcode (%d)\n",errcode);
			fflush(stdout);
		#endif
		*/
		if(errcode == FND)
		{
			/*  Query ACCM for Shelf Life  */
			check_null_values("actd");
			update_create_delete = 'U';
			errcode = build_actd_api_rcd("update");
			if(errcode == 0)
			{
				update_cnt++;
				errcode = write_actd_api_rcd();
			}
		}
		else
		{
			if(errcode != NF)
				db_err("delete_actd_rcd");
		}
	}

	EXEC SQL CLOSE actd_cur;
	return(errcode);
}
/*

*/
int delete_actd_rcd()
{
	int errcode = 0;
	int dup_fnd = 0;
	int fnd = 1;
	varchar old_act_code2[51];
	
	#if DEBUG
		printf("delete_actd_rcd\n");
		fflush(stdout);
	#endif

	errcode = query_actd('D');
	if(errcode == FND)
	{
		while(fnd)
		{
			EXEC SQL FETCH actd_cur INTO
				:ims_designator_code:ims_designator_code_i,
				:ave_cap_lead_time:ave_cap_lead_time_i,
				:old_act_code,
				:structure_code:structure_code_i,
				:sub_structure_code:sub_structure_code_i,
				:pos:pos_i,
				:sc,
		  		:actual_interval:actual_interval_i,
				:warning_interval:warning_interval_i, 
				:category_instrument:category_instrument_i,
				:recurring_b:recurring_b_i,
				:est_mat_cost:est_mat_cost_i,
				:est_labor_hours:est_labor_hours_i,
				:master_life_b:master_life_b_i,
				:est_days:est_days_i,
				:remarks:remarks_i,
				:deviation_rebase:deviation_rebase_i,
				:auto_rebase_b:auto_rebase_b_i,
				:mandatory_b:mandatory_b_i,
				:supply_b:supply_b_i,
				:operational_b:operational_b_i;

			errcode = sqlca.sqlcode;
			#if DEBUG
				printf("Delete errcode (%d)\n",errcode);
				fflush(stdout);
			#endif

			if(errcode == FND || errcode == MUL)
			{
				if(strncmp((char *) old_act_code.arr,(char *) activity_code.arr,activity_code.len) != 0)
				{
					/*  Query ACCM for Shelf Life  */
					check_null_values("actd");
					/*
					#if DEBUG
						printf("Writing...\n");
						fflush(stdout);
					#endif
					*/
					memset((char *) old_act_code2.arr,' ',50);
					strcpy((char *) old_act_code2.arr,(char *) old_act_code.arr);
					#if DEBUG
						printf("Delete Cnt (%d)\n",delete_cnt);
						printf("Part       (%s)\n",temp_part.arr);
						printf("IMS Des    (%s)\n",ims_designator_code.arr);
						printf("old_act_cod2.arr=%s\n", old_act_code2.arr);
					        printf("rtrim(old_act_code2.arr=%s\n",rtrim(old_act_code2.arr)) ;
					        printf("rtrim(ims_designator_code.arr=%s\n",rtrim(ims_designator_code.arr)) ;
						printf("Manual deletion of old Shelf Life (%s) needed for part %s IMS Des Code %s\n",
						  rtrim(old_act_code2.arr),
						  temp_part.arr,
						  rtrim(ims_designator_code.arr));
					#endif



					fprintf(fp_delete,"Manual deletion of old Shelf Life (%s) needed for part %s IMS Des Code %s\n",
						rtrim(old_act_code2.arr),
						temp_part.arr,
						rtrim(ims_designator_code.arr));
					delete_cnt++;
					/*
					update_create_delete = 'D';
					errcode = build_actd_api_rcd("delete");
					if(errcode == 0)
					{
						delete_cnt++;
						errcode = write_actd_api_rcd();
					}
					*/
				}
				else
				{
					#if DEBUG
						printf("Ave Cap LT (%s)\n",ave_cap_lead_time.arr);
					#endif
					strncpy((char *) hold_lead_time.arr,(char *) ave_cap_lead_time.arr,5);
					hold_lead_time.len = 5;
					hold_lead_time.arr[hold_lead_time.len] = '\0';
					#if DEBUG
						printf("Hold Lead Time (%s)\n",hold_lead_time.arr);
						fflush(stdout);
					#endif
					dup_fnd = 1;
				}
			}
			else
			{
				if(errcode == NF)
				{
					#if DEBUG
						printf("Delete records not found\n");
						fflush(stdout);
					#endif
					if(dup_fnd != 0)
						errcode = dup_fnd;
					else
						errcode = 0;
					fnd = 0;
				}
				else
					db_err("delete_actd_rcd");
			}
		}
	}
	
	EXEC SQL CLOSE actd_cur;
	return(errcode);
}
/*

*/
int query_for_accm_defaults()
{
	int errcode = 0;
	
	#if DEBUG
		printf("query_for_accm_defaults\n");
		fflush(stdout);
	#endif

	EXEC SQL SELECT 
			recurring_b,
			est_mat_cost,
			est_labor_hours,
			master_life_b,
			est_days,
			remarks,
			deviation_rebase,
			auto_rebase_b,
			supply_b,
			operational_b
		INTO
			:recurring_b:recurring_b_i,
			:est_mat_cost:est_mat_cost_i,
			:est_labor_hours:est_labor_hours_i,
			:master_life_b:master_life_b_i,
			:est_days:est_days_i,
			:remarks:remarks_i,
			:deviation_rebase:deviation_rebase_i,
			:auto_rebase_b:auto_rebase_b_i,
			:supply_b:supply_b_i,
			:operational_b:operational_b_i
		FROM accm
		WHERE activity_code = :temp_act_code;
		
	errcode = sqlca.sqlcode;
	
	if(errcode == FND || errcode == MUL)
	{
		check_null_values("accm");
		errcode = 0;
	}
	else
		if(errcode != NF)
			db_err("query_for_accm_defaults");
	
	return(errcode);
}
/*

*/
void check_null_values(char *tbl)
{
	#if DEBUG
		printf("check_null_values\n");
		fflush(stdout);
	#endif

	if(strncmp(tbl,"actd",3) == 0)
	{
		if(ims_designator_code_i == -1)
			strncpy((char *) ims_designator_code.arr," ",1);
		ims_designator_code.len = strlen((char *) ims_designator_code.arr);
		ims_designator_code.arr[ims_designator_code.len] = '\0'; 

		if(ave_cap_lead_time_i == -1)
			strncpy((char *) ave_cap_lead_time.arr,"     ",5);
		ave_cap_lead_time.len = 5;
		ave_cap_lead_time.arr[ave_cap_lead_time.len] = '\0'; 

		if(actual_interval_i == -1)
		{
			strncpy((char *) actual_interval.arr,"              ",15);
			actual_interval.len = 15;
			actual_interval.arr[actual_interval.len] = '\0'; 
		}

		if(warning_interval_i == -1)
		{
			strncpy((char *) warning_interval.arr,"              ",15);
			warning_interval.len = 15;
			warning_interval.arr[warning_interval.len] = '\0'; 
		}

		if(structure_code_i == -1)
		{
			strncpy((char *) structure_code.arr,"                    ",20);
			structure_code.len = 20;
			structure_code.arr[structure_code.len] = '\0';
		}
		
		if(sub_structure_code_i == -1)
		{
			strncpy((char *) sub_structure_code.arr,"                    ",20);
			sub_structure_code.len = 20;
			sub_structure_code.arr[sub_structure_code.len] = '\0';
		}
		
		if(pos_i == -1)
		{
			strncpy((char *) pos.arr,"                    ",20);
			pos.len = 20;
			pos.arr[pos.len] = '\0';
		}

		if(category_instrument_i == -1)
		{
			strncpy((char *) category_instrument.arr,"                    ",20);
			category_instrument.len = 20;
			category_instrument.arr[category_instrument.len] = '\0';
		}
		
		if(mandatory_b_i == -1)
			mandatory_b = 'F';
	}
	else
		mandatory_b = 'F';
	
	if(recurring_b_i == -1)
		recurring_b = 'F';
	if(auto_rebase_b_i == -1)
		auto_rebase_b = 'F';
	if(supply_b_i == -1)
		supply_b = 'F';
	if(operational_b_i == -1)
		operational_b = 'F';
	if(master_life_b_i == -1)
		master_life_b = 'F';

	if(est_mat_cost_i == -1)
	{
		strncpy((char *) est_mat_cost.arr,"               ",15);
		est_mat_cost.len = 15;
		est_mat_cost.arr[est_mat_cost.len] = '\0';
	}

	if(est_labor_hours_i == -1)
	{
		strncpy((char *) est_labor_hours.arr,"               ",15);
		est_labor_hours.len = 15;
		est_labor_hours.arr[est_labor_hours.len] = '\0';
	}
	
	if(est_days_i == -1)
	{
		strncpy((char *) est_days.arr,"               ",15);
		est_days.len = 15;
		est_days.arr[est_days.len] = '\0';
	}

	if(remarks_i == -1)
	{
		strncpy((char *) remarks.arr,"                                                            ",60);
		remarks.len = 60;
		remarks.arr[remarks.len] = '\0';
	}

	if(deviation_rebase_i == -1)
	{
		strncpy((char *) deviation_rebase.arr,"               ",15);
		deviation_rebase.len = 15;
		deviation_rebase.arr[deviation_rebase.len] = '\0';
	}
}
/*

*/
int build_actd_api_rcd(char *type)
{
	int errcode = 0;
	int i_actual;
	int i_warning;
	
	#if DEBUG
		printf("build_actd_api_rcd\n");
		fflush(stdout);
	#endif

	strncpy(actd_rcd.customer,"STL",3);
	strncpy(actd_rcd.part,spaces,50);
	strncpy(actd_rcd.part,(char *) part.arr,part.len);
	strncpy(actd_rcd.table_nbr,"002",3);
	strncpy(actd_rcd.table_name,"DEFAULT_ACTIVITY",16);
	actd_rcd.update_create_delete = update_create_delete;

	if(strncmp(type,"create",6) == 0)
	{
		errcode = calculate_intervals();
		if(errcode == 0)
		{
			strncpy(actd_rcd.activity_code,(char *) activity_code.arr,activity_code.len);
			strncpy(actd_rcd.sc,"DEF",3);
			strncpy(actd_rcd.structure_code,"DEF",3);
			strncpy(actd_rcd.sub_structure_code,"DEF",3);
			strncpy(actd_rcd.pos,"DEF",3);
			strncpy(actd_rcd.category_instrument,"DEF",3);
		}
	}
	else
	{
		#if DEBUG
			printf("SLIC Lead Time (%s)\n",lead_time.arr);
			printf("GOLD Lead Time (%s)\n",ave_cap_lead_time.arr);
			fflush(stdout);
		#endif
		if(strncmp(type,"delete",6) == 0)
		{
			i_actual = atoi((char *) actual_interval.arr);
			i_warning = atoi((char *) warning_interval.arr);
			sprintf((char *) actual_interval.arr, "%15.15d",i_actual);
			actual_interval.len = 15;
			actual_interval.arr[actual_interval.len] = '\0';
			sprintf((char *) warning_interval.arr, "%15.15d",i_warning);
			warning_interval.len = 15;
			warning_interval.arr[warning_interval.len] = '\0';
		}
		else
			errcode = calculate_intervals();

		if(errcode == 0)
		{
			strncpy(actd_rcd.activity_code,(char *) old_act_code.arr,old_act_code.len);
			strncpy(actd_rcd.sc,(char *) sc.arr,sc.len);
			strncpy(actd_rcd.structure_code,(char *) structure_code.arr,structure_code.len);
			strncpy(actd_rcd.sub_structure_code,(char *) sub_structure_code.arr,sub_structure_code.len);
			strncpy(actd_rcd.pos,(char *) pos.arr,pos.len);
			strncpy(actd_rcd.category_instrument,(char *) category_instrument.arr,category_instrument.len);
		}
	}

	actd_rcd.recurring_b = recurring_b;
	actd_rcd.master_life_b = master_life_b;
	actd_rcd.auto_rebase_b = auto_rebase_b;
	actd_rcd.mandatory_b = mandatory_b;
	actd_rcd.supply_b = supply_b;
	actd_rcd.operational_b = operational_b;
	actd_rcd.eol = '\n';

	strncpy(actd_rcd.actual_interval,(char *) actual_interval.arr,actual_interval.len);
	strncpy(actd_rcd.warning_interval,(char *) warning_interval.arr,warning_interval.len);
	strncpy(actd_rcd.est_mat_cost,(char *) est_mat_cost.arr,est_mat_cost.len);
	strncpy(actd_rcd.est_labor_hours,(char *) est_labor_hours.arr,est_labor_hours.len);
	strncpy(actd_rcd.est_days,(char *) est_days.arr,est_days.len);
	strncpy(actd_rcd.remarks,(char *) remarks.arr,remarks.len);
	strncpy(actd_rcd.deviation_rebase,(char *) deviation_rebase.arr,deviation_rebase.len);
	#if DEBUG
		print_data();
		fflush(stdout);
	#endif

	return(errcode);
}
/*

*/
int calculate_intervals()
{
	int errcode = 0;
	int i_actual;
	int i_warning;
	int i_leadtime;
	varchar months[11];
	
	#if DEBUG
		printf("calculate_intervals\n");
		printf("Lead Time (%s)\n",lead_time.arr);
		fflush(stdout);
	#endif

	EXEC SQL SELECT months
		INTO :months
		FROM scm.shelf_life_ref_tbl
		WHERE code = :temp_act_code;

	errcode = sqlca.sqlcode;	
	if(errcode == FND)
	{
		strncpy((char *) actual_interval.arr,(char *) months.arr, months.len);
		actual_interval.len = 15;
		actual_interval.arr[actual_interval.len] = '\0';
		
		i_actual   = atoi((char *) actual_interval.arr);
		i_leadtime = atoi((char *) lead_time.arr);

		#if DEBUG
			printf("(%s) %d %d\n",lead_time.arr,i_actual,i_leadtime);
			fflush(stdout);
		#endif
			
		if(i_actual >= i_leadtime)
		{
			i_warning  =  i_actual - i_leadtime;
			sprintf((char *) actual_interval.arr, "%15.15d",i_actual);
			sprintf((char *) warning_interval.arr, "%15.15d",i_warning);
			warning_interval.len = 15;
			warning_interval.arr[warning_interval.len] = '\0';
		}
		else
		{
			fprintf(fperror,"PART (%s): Lead time (%d) exceeds shelf life interval(%d)\n",temp_part.arr,i_leadtime,i_actual);
			errcnt++;
			errcode = 500;
		}
	}
	else
	{
		if(errcode == NF)
		{
			fprintf(fperror,"PART (%s): %s activity code not found in reference table.\n",temp_part.arr,temp_act_code.arr);
			errcnt++;
		}
		else
			db_err("calculate_intervals");
	}
	
	return(errcode);
}
/*

*/
int write_actd_api_rcd()
{
	char out[2000];	
	int errcode = 0;
	node *search;
	
	#if DEBUG
		printf("write_actd_api_rcd\n");
		fflush(stdout);
	#endif

	memset(out, ' ', 2000);

	search = tree_find((char *) part.arr,part.len);
	if(search == 0)
		errcode = create_cat1_rcd();

	actd_rcd.eol = '\n';
	memcpy(out,&actd_rcd,sizeof(actd_rcd));
	out[sizeof(actd_rcd)] = '\0';

	#if DEBUG
	  printf("strlen(out)=%d\n", strlen(out)) ;
	#endif
	
	assert(strlen(out) == sizeof(actd_rcd));
	errcode = fwrite(out,strlen(out),1,gold_actd_fp);
	if(errcode != 1)
	{
		printf("\n**********************************************************");
		printf("\nError writing output gold_actd_fp (%d)",errcode);
		errcode=510;
	}
	else
	{
		errcode = 0;
		fflush(gold_actd_fp);
		memset((char *) actual_interval.arr,' ',15);
		memset((char *) warning_interval.arr,' ',15);
	}
	
	return(errcode);
}
/*

*/
int create_cat1_rcd()
{
	int errcode = 0;
	char out[2000];

	#if DEBUG
		printf("create_cat1_rcd\n");
		fflush(stdout);
	#endif

	cat1_rcd.eol='\0';
	memset ((char *) cat1_rcd.customer,' ',sizeof(cat1_rcd));

	memset(out,' ',2000);
	strncpy(cat1_rcd.customer,"STL",3);
	strncpy(cat1_rcd.part,spaces,50);
	strncpy(cat1_rcd.part,(char *) part.arr,part.len);
	strncpy(cat1_rcd.table_nbr,"001",3);
	strncpy(cat1_rcd.table_name,"CATALOG",7);
	cat1_rcd.update_create_delete = 'U';	

	errcode=Z9992_check_cat1_part();
	
	if(errcode==0)
	{
	        
	        cat1_rcd.eol = '\n';
		memcpy(out,&cat1_rcd,sizeof(cat1_rcd));
		out[sizeof(gold68_cat1_api_rcd)] = '\0';
	
		assert(strlen(out) == sizeof(cat1_rcd));
		errcode = fwrite(out,strlen(out),1,gold_cat1_fp);
		if(errcode != 1)
		{
			printf("\n**********************************************************");
			printf("\nError writing output gold_cat1_fp (%d)",errcode);
			errcode=520;
		}
		else
		{
			#if DEBUG
				printf("Ouput Cat1 Rcd (%s)\n",out);
				fflush(stdout);
			#endif
			errcode = 0;
			fflush(gold_cat1_fp);
		}
	}
	return errcode;
}
/*

*/
void print_data()
{
	#if DEBUG
		printf("print_data\n");
		fflush(stdout);
	#endif

	printf("Customer         (%20.20s)\n",actd_rcd.customer);
	printf("Part             (%50.50s)\n",actd_rcd.part);
	printf("Table Nbr        (%3.3s)\n",actd_rcd.table_nbr);
	printf("Table Name       (%30.30s)\n",actd_rcd.table_name);
	printf("UC Flag          (%c)\n",actd_rcd.update_create_delete);
	printf("SC               (%20.20s)\n",actd_rcd.sc);
	printf("Act Code         (%50.50s)\n",actd_rcd.activity_code);
	printf("Struct Code      (%20.20s)\n",actd_rcd.structure_code);
	printf("Sub Struct Code  (%20.20s)\n",actd_rcd.sub_structure_code);
	printf("Pos              (%20.20s)\n",actd_rcd.pos);
	printf("Category Instr   (%20.20s)\n",actd_rcd.category_instrument);
	printf("Recurring        (%c)\n",actd_rcd.recurring_b);
	printf("Actual Int       (%15.15s)\n",actd_rcd.actual_interval);
	printf("Warning Int      (%15.15s)\n",actd_rcd.warning_interval);
	printf("Est Mat Cost     (%15.15s)\n",actd_rcd.est_mat_cost);
	printf("Est Labor Hours  (%15.15s)\n",actd_rcd.est_labor_hours);
	printf("Master Life      (%c)\n",actd_rcd.master_life_b);
	printf("Est Days         (%15.15s)\n",actd_rcd.est_days);
	printf("Remarks          (%60.60s)\n",actd_rcd.remarks);
	printf("Deviation Rebase (%15.15s)\n",actd_rcd.deviation_rebase);
	printf("Auto Rebase      (%c)\n",actd_rcd.auto_rebase_b);
	printf("Mandatory        (%c)\n",actd_rcd.mandatory_b);
	printf("Supply           (%c)\n",actd_rcd.supply_b);
	printf("Operational      (%c)\n",actd_rcd.operational_b);
}
/*
*/
void print_totals()
{
	#if DEBUG
		printf("print_totals\n");
		fflush(stdout);
	#endif

	printf("Total Records Updated:             %d\n",update_cnt);
	printf("Total Records Created:             %d\n",create_cnt);
	printf("Total Record Errors:               %d\n",errcnt);
	printf("Total Manual Deletions Required:   %d\n\n",delete_cnt);
}
/*

*/
void build_cat1_tree()
{
    char cat1_buf[2000];
    varchar cat1_part[51];


    #if DEBUG
	printf("\nbuild_cat1_tree");
    #endif

    printf("\n\tBuilding catalog tree from %s\n",cat1input);
    fflush(stdout);

    memset(cat1_buf,' ',2000);
    while(fgets(cat1_buf,2000,gold_cat1_in_fp) != NULL)
    {
		#if DEBUG
			printf("(%s)\n",cat1_buf);
			fflush(stdout);
		#endif
		strncpy((char *) cat1_part.arr,spaces,50);
        	strncpy((char *) cat1_part.arr,&cat1_buf[20],50);
		cat1_part.len = 50;
		cat1_part.arr[cat1_part.len] = '\0';
		#if DEBUG
			printf("1 (%s) (%d)\n",cat1_part.arr,cat1_part.len);
			fflush(stdout);
		#endif
        	rtrim((char *) cat1_part.arr);
		#if DEBUG
			printf("2 (%s) (%d)\n",cat1_part.arr,cat1_part.len);
			fflush(stdout);
		#endif
		cat1_part.len = strlen((char *) cat1_part.arr);
		cat1_part.arr[cat1_part.len] = '\0';
		#if DEBUG
			printf("3 (%s) (%d)\n",cat1_part.arr,cat1_part.len);
			fflush(stdout);
		#endif
        	tree_insert((char *) cat1_part.arr,cat1_part.len);
    }
}
/*
*/
/********************************************
 * Searches through the tree to find the    *
 * input character string.  If found, the   *
 * pointer to the current node is returned. *
 * If not found, return 0.                  *
 ********************************************/
node *tree_find(char *str,int length)
{
    node *current;

    current = root;
    /*printf("Current str is %s\n",current->str);*/
    while(current != NULL)
    {
	/*
        #if DEBUG
		printf("Comparing:\n\t(%s)\n\t(%s)\n",str,current->str);
	#endif
		*/
        if(strncmp(str,current->str,length) == 0)
            return(current);
        else
        {
            if(strncmp(str,current->str,length) < 0)
                current = current->left;
            else
                current = current->right;
        }
    }

    return(0);
}
/*

*/
/******************************************************
 * Inserts the input character string into a tree.    *
 * Returns the current node if the string is already  *
 * in the tree. Otherwise it willl insert the string  *
 * into the tree and return the new node.             *
 ******************************************************/
node *tree_insert(char *str,int length)
{
    node *current;
    node *parent;
    node *child;

    current = root;
    parent = 0;

    /*  Find the parent of child node  */
    while(current)
    {
        if(strncmp(str,current->str,length) == 0)
        {
            return(current);
        }
        parent = current;

        if(strncmp(str,current->str,length) < 0)
            current = current->left;
        else
            current = current->right;
    }

    /*  New Node  */
    if((child = malloc(sizeof(*child))) == 0)
    {
        printf("Error in allocating memory for node\n");
        exit(2);
    }

    strncpy(child->str,str,length);
    child->str[length] = '\0';
    child->parent = parent;
    child->left = NULL;
    child->right = NULL;

    /*  Insert the child node into the tree  */
    if(parent)
    {
        if(strncmp(child->str,parent->str,length) < 0)
            parent->left = child;
        else
            parent->right = child;
    }
    else
        root = child;

    return(child);
}

int     Z9992_check_cat1_part(void)
{
        int     status;
        int	errcode=0;
	gold_rcd_exists='N';

	#if DEBUG
		printf("\nZ9992_check_cat1_part");
		printf("\nPart (%s) (%d)",part.arr,part.len);
	#endif

	EXEC SQL

	   select part,
	   	  rpad(prime,50),
		  nvl(category_instrument,'            '),
		  nvl(noun,' '),
		  nvl(um_issue_code,' '),
		  nvl(manuf_cage,'      '),
		  nvl(cat1.nsn,'NSL             '),
		  substr(to_char(nvl(ave_cap_lead_time,'000'),'00000'),2,5),
		  nvl(security_code,' '),
		  nvl(pmi_code,' '),
		  nvl(demilitarization_code,' '),
		  nvl(critical_item_code,' '),
		  nvl(cognizance_code,' '),
		  nvl(smrc,' '),
		  nvl(nsn1.nsn_smic,'  '),
		  nvl(source_code,'   '),
		  nvl(hazardous_material_code,' '),
		  nvl(cat1_profile,'STL'),
		  nvl(ims_designator_code,' '),
		  nvl(order_cap_b,'T'),
		  nvl(order_gfp_b,'F'),
		  nvl(delete_when_gone,'F'),
		  nvl(tracked_b,'F'),
		  nvl(part_make_b,'F'),
		  nvl(part_buy_b,'F'),
		  nvl(hazardous_material_b,'F'),
		  nvl(lot_batch_mandatory_b,'F'),
		  nvl(serial_mandatory_b,'F'),
		  nvl(agency_peculiar_b,'F'),
		  nvl(mils_auto_process_b,'T')
		into :gold_cat1_part,
		     :gold_cat1_prime,
		     :gold_cat_inst_code,
		     :gold_noun,
		     :gold_um_issue_code,
		     :gold_manuf_cage,
		     :gold_nsn,
		     :gold_ave_cap_lead_time,
		     :gold_security_code,
		     :gold_pmi_code,
		     :gold_demilitarization_code,
		     :gold_critical_item_code,
		     :gold_cognizance_code,
		     :gold_smr_code,
		     :gold_nsn_smic,
		     :gold_source_code,
		     :gold_hazardous_material_code,
		     :gold_cat1_profile,
		     :gold_ims_designator_code,
		     :gold_order_cap_b,
		     :gold_order_gfp_b,
		     :gold_delete_when_gone,
		     :gold_tracked_b,
		     :gold_part_make_b,
		     :gold_part_buy_b,
		     :gold_hazardous_material_b,
		     :gold_lot_batch_mandatory_b,
		     :gold_serial_mandatory_b,
		     :gold_agency_peculiar_b,
		     :gold_mils_auto_process_b
	     from cat1 cat1,nsn1 nsn1
	       where part = rtrim(:part)
		 and cat1.nsn=nsn1.nsn(+);


	if (sqlca.sqlcode == FND || sqlca.sqlcode == MUL)
	{
		#if DEBUG
			printf("\nZ9992_check_cat1_part - Row Found");
		#endif
		strncpy(cat1_rcd.prime,(char *) gold_cat1_prime.arr,gold_cat1_prime.len);
		strncpy(cat1_rcd.category_instrument,(char *) gold_cat_inst_code.arr,gold_cat_inst_code.len);
		strncpy(cat1_rcd.noun,(char *) gold_noun.arr,gold_noun.len);
		strncpy(cat1_rcd.um_issue_code,(char *) gold_um_issue_code.arr,gold_um_issue_code.len);
		strncpy(cat1_rcd.manuf_cage,(char *) gold_manuf_cage.arr,gold_manuf_cage.len);
		strncpy(cat1_rcd.nsn,(char *) gold_nsn.arr,gold_nsn.len);
		strncpy(cat1_rcd.ave_cap_lead_time,(char *) gold_ave_cap_lead_time.arr,gold_ave_cap_lead_time.len);
		cat1_rcd.security_code=gold_security_code;
		strncpy(cat1_rcd.pmi_code,(char *) gold_pmi_code.arr,gold_pmi_code.len);
		strncpy(cat1_rcd.demilitarization_code,(char *) gold_demilitarization_code.arr,gold_demilitarization_code.len);
		strncpy(cat1_rcd.critical_item_code,(char *) gold_critical_item_code.arr,gold_critical_item_code.len);
		strncpy(cat1_rcd.cognizance_code,(char *) gold_cognizance_code.arr,gold_cognizance_code.len);
		strncpy(cat1_rcd.smrc,(char *) gold_smr_code.arr,gold_smr_code.len);
		strncpy(cat1_rcd.nsn_smic,(char *) gold_nsn_smic.arr,gold_nsn_smic.len);
		strncpy(cat1_rcd.source_code,(char *) gold_source_code.arr,gold_source_code.len);
		strncpy(cat1_rcd.hazardous_material_code,(char *) gold_hazardous_material_code.arr,gold_hazardous_material_code.len);
		strncpy(cat1_rcd.cat1_profile,(char *) gold_cat1_profile.arr,gold_cat1_profile.len);
		cat1_rcd.order_cap_b=gold_order_cap_b;
		cat1_rcd.order_gfp_b=gold_order_gfp_b;
		cat1_rcd.delete_when_gone=gold_delete_when_gone;
		cat1_rcd.tracked_b=gold_tracked_b;
		cat1_rcd.part_make_b=gold_part_make_b;
		cat1_rcd.part_buy_b=gold_part_buy_b;
		cat1_rcd.hazardous_material_b=gold_hazardous_material_b;
		cat1_rcd.lot_batch_mandatory_b=gold_lot_batch_mandatory_b;
		cat1_rcd.serial_mandatory_b=gold_serial_mandatory_b;
		cat1_rcd.agency_peculiar_b=gold_agency_peculiar_b;
		cat1_rcd.mils_auto_process_b=gold_mils_auto_process_b;

		if(gold_part_make_b=='N')
		{
			gold_part_make_b='F';
		}
		else
		{
			cat1_rcd.part_make_b=gold_part_make_b;
		}
		if(gold_part_buy_b=='N')
		{
			gold_part_buy_b='F';
		}
		else
		{
			cat1_rcd.part_buy_b=gold_part_buy_b;
		}
		errcode=0;
	}
	else
	{
		if(sqlca.sqlcode == NF)
		{
			#if DEBUG
				printf("\nZ9992_check_cat1_part - Not Found");
			#endif
			errcode=0;
		}
		else
		{
			printf("\nZ9999_check_cat1_part");
			printf("\nBad SQLCODE ");
			errcode=sqlca.sqlcode;
			db_err("Z9992_check_cat1_part");
		}
	}

	return(errcode);
}
