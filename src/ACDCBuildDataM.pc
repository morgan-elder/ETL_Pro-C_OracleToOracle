/* vim: ts=2:sw=2:sts=2:et:syn=c: */

/* Program - Outputs all ACDC data into Excel */
/* ************************************************************************** 
 * PROGRAM NAME:  ACDCAll.pc 
 * *
PURPOSE:  The purpose of this program is to output all of the ACDC into an Excel Spreadsheet.  
* 
* INPUTS:  1.  Connect strings to SLIC and GOLD databases * * *
OUTPUTS:  1.  Output file 
* * * CHANGE HISTORY:  
* REV DATE Programmer CHANGE 
* --- -------- ----------------- ------ 
* 00 02/18/03 Kara Cappos Initial coding
* 01 04/08/03 Kara Cappos Added modifications to either output to file or load data into scm.acdc_order_data Oracle table
* 02 10/21/03 Kara Cappos Added Sweep logic
* 03 11/04/04 Kara Cappos Added multiple price sources.  Also, varied pricing logic depending on the contract (TA4, TA5, etc)
* 04 09/28/04 Kelly Dougherty Added TA8 price source
************************************************************************** */

#include <stdlib.h> 
#include <stdio.h> 
#include <string.h>
#include <time.h>
#include <assert.h>


EXEC SQL INCLUDE sqlca.h;

#define NOTFND 1403
#define MAX 50

struct tm *tmstruct;
time_t  start_time;
time_t  end_time;

/* Declare Record Sets 
slic_vars slic;
gold_vars gold;*/

/* Declare database ids */
char *slic_db = "slic_db";
char *gold_db = "gold_db";


char slic_dsn[20];
char gold_dsn[20];
char output_file[100];
char output_type[2];

struct
{
	char	pgm_system[20];
	char	default_job[20];
} default_job_tble[100];

FILE *fp_out;

/* Host Variables */
varchar cust[21];
short   cust_i;
varchar cust_model[21];
short   cust_model_i;
varchar cust_cust_model[42];
short   cust_cust_model_i;
varchar cust_system[21];
short   cust_system_i;
varchar jicc[11];
short jicc_i;
varchar order_mod[21]; 
varchar awo_jicc[11];
varchar chk_jicc_job[11];
int	count_jobs;
varchar part[51];
varchar part_basic[51];
varchar prime[51];
varchar noun[41];
varchar niin[12];
varchar nsn[17];
varchar cog[3];
varchar smic[3];
varchar MFG_cage[15];
varchar vendor_code[15];
varchar lisn_ssn[21];
short   lisn_ssn_i;
varchar releaseType[3];
varchar ims_designator_code[21];
varchar order_no[21];
varchar sc[21];
varchar buyer[26];
varchar fdw_buyer[26];
varchar contract[20];
varchar processing_job[4];
varchar default_job[20];
varchar default_system[20];
varchar default_job_date[9];
varchar contract_date[25];
varchar contract_year[5]; 
varchar contract_month[4];
short contract_date_i;
short contract_year_i;
short contract_month_i;
varchar activity_id[16];
varchar po[21];
varchar po_line[7];
varchar po_po_line[31];
varchar po_po_line_part[71];
varchar price_type[3];
varchar crtdocdte[25];
varchar bkupcdte[25];
varchar datesort[8];
varchar createdte[11];
varchar crtdocdte_month[4];
varchar crtdocdte_day[4];
varchar crtdocdte_year[5];
varchar pc_release_date[11];
short	pc_release_date_i;
float po_price;
short po_price_i;
varchar smrc[10];
short releaseType_i;
int priority;
short priority_i;
int lead_time;
short lead_time_i;
int lead_time_days;
short lead_time_days_i;
varchar est_sched_date[25];
int est_sched_year;
int est_sched_mo;
int est_sched_day;
varchar sched_cat[29];
int qty_ordered;
short qty_ordered_i;
float unit_price; 
short unit_price_i;
float extd_amt_display;
short extd_amt_display_i;
float fdw_unit_price;
float ichs_unit_price;
short ichs_unit_price_i;
float ngc_price;
short ngc_price_i;
float ichs_part_price;
short ichs_part_price_i;
float avg_order_mod_price;
short avg_order_mod_price_i;
float avg_price;
short avg_price_i;
float avg_price_output;
short avg_price_output_i;
float best_price;
short best_price_i;
float best_ext_price;
short best_ext_price_i;
char	sweep_price_type;
float sweep_uc_price;
short sweep_uc_price_i;
varchar	dps_contract_clin[21];
varchar dps_contract_elin[21];
varchar best_price_source[31];
short	best_price_source_i;
varchar best_price_cat[41];
short	best_price_cat_i;
varchar contract_start[9];
short	contract_start_i;
int	price_order;
short	price_order_i;
varchar prcType[15];
varchar mystatus[31];
varchar buyAuthNeed[15];
varchar remarks[181];
varchar user_ref2[51];
float rem_amt;
short rem_amt_i;
int rem_qty; 
short rem_qty_i;
int liq_qty;
int commit_qty;
float liq_amt;
float commit_amt;
int nwp_commit_qty;
float nwp_commit_amt;
int caps_commit_qty;
float caps_commit_amt;
varchar asofdate[25];
varchar vendor_name[51];
varchar vendor_name_ichs[51];
varchar cost_acct[21];
varchar part_source[10];
varchar hb_part[33];
varchar sc_list[2000];
varchar stmt[5000];
varchar escalation_fromdate[5];
short escalation_fromdate_i;
varchar escalation_currdate[5];
short escalation_currdate_i;
float escalation_pcnt;
float escalation_price;
float escalation_temp_price;
int numeric_po=0;
int user_ref2_numeric=0;
char	processing_mdl[10];

int input_ctr=0;
int ins_output_ctr=0;
int recs_output_ctr=0;

/* Functions */	
void show_err_info(char *procname) ;
void initialize();
int     A999_00_open_files();
void query_add_buy_auth_ords();
void query_best_price();
void query_PO_ICHS_price();
void query_PO_FDW_price();
void get_PO_FDW_vendor_name();
void query_sweep_price();
/* void query_ngc_price(); */
void query_part_price();
void setup_default_job();
void get_default_job();
void check_valid_job();
void set_override_job();
void get_scm_price_new();
void get_scm_price();
void query_jicc();
void check_user_ref2_expedite();
void query_hd_data();
void query_cage();
void query_cage_hb();
void query_cage_ha_hb();
void query_order_deliv_info();
void query_supplier_deliv_dates();
void query_cost_acct();
void query_vendor_name();
void calculate_escalation_adjmnt();
void calculate_all_escalation_adjmnt();
void retrieve_all_escalation_adjmnt();
void calculate_ngc_escalation_adjmnt();
void retrieve_ngc_escalation_adjmnt();
void write_output();
int  set_cust_model();
void insert_record();
void delete_record();
void display_record();
void commit();
void   SetBasicPart(char *str,int length);
int  isNum(char *in);

int main(int argc, char *argv[])
{
	int i;
	int errcode=0;
	long start, stop;
	long elapsed;
	float mins;
	char runtime[25];

        printf("\n\n**************************************************************************");

        printf("\nCompiled %s on %s at %s\n", __FILE__,__DATE__,__TIME__);
        time(&start_time);
        tmstruct = localtime(&start_time);
        strftime(runtime,sizeof(runtime),"%m/%d/%Y - %H:%M:%S",tmstruct);

        printf("\n\n\tStarting Time (%s)\n",runtime);

	if(argc != 3)
	{
		printf("Usage: %s i|f output_file\n",argv[0]);
		printf("  where i or f is the ooutput_type\n") ;
		exit(1);
	}
	Login();
	if(sqlca.sqlcode == 0)
		printf("Connected to SLIC.\n");
	else
	{
		printf("Error connecting to SLIC.  Exiting.\n");
		exit(2);
	}
	initialize();
	strcpy(output_file,argv[2]);
	strcpy(output_type,argv[1]);
  printf("\noutput_file=%s", output_file) ;
  printf("\noutput_type=%s\n", output_type) ;
	if(output_type[0] == 'i')
	{
		delete_record();
	}
	EXEC SQL
	SELECT to_char(sysdate,'MM/DD/YYYY HH:MI')
	INTO :asofdate
	from dual;
	if(output_type[0] == 'f')
	{
		errcode=A999_00_open_files();

		if(errcode==0)
		{
			fprintf(fp_out, "Automated Cost Data Consolidation As Of: ");
      recs_output_ctr++ ;
			fprintf(fp_out, "%s\n", asofdate.arr);
      recs_output_ctr++ ;
			fprintf(fp_out,"JICC\tOrder Mod\tPart No.\tMfg Code\tVendor Code\tRelease Type\tIMS Des Code\tCap Order\tContract Date\tContract Year");
      recs_output_ctr++ ;
			fprintf(fp_out,"\tContract Month\tPO\tPO Line\tPO+LI\tPO+LI+PN\tSubmittal Date\tSubmittal Year\tSubmittal Mo\tSMR Code\tLead Time(Months)");
      recs_output_ctr++ ;
			fprintf(fp_out,"\tLead Time(Days)\tEst. Sched Date\tEst. Year\tEst. Month\tSched Cat\tQty\tBest Price\tBest Extended Price\tBest Price Source\tBest Price Cat");
      recs_output_ctr++ ;
			fprintf(fp_out,"\tOrder Status\tAdditional Buy Authorization\tRemarks\tExpedite Info\tCommit Amt\tLiq. Amt\tCommit Qty\tLiq. Qty\tRemaining Amt\tRemaining Qty\tAs of Date\tDownloaded Vendor Name\tBest Vendor Name\tCost Acct\tLISN SSN");
      recs_output_ctr++ ;
			fprintf(fp_out,"\tEscalation From Date\tEscalation Price\tEscalation Percent\tPO Release Date\n");
      recs_output_ctr++ ;
			fflush(fp_out); 
		}
	}

	setup_default_job();

	query_add_buy_auth_ords();
	
	if(output_type[0] == 'f')
	{
		fclose(fp_out);
	}
	
	printf("\nTotal Rows Fetched (%d)",input_ctr);
	printf("\nTotal Rows Inserted(%d) to scm.acdc_order_data",ins_output_ctr);
	printf("\nTotal Recs Output(%d) to %s",recs_output_ctr, output_file);
        printf("\n\n**************************************************************************");
        time(&end_time);
        tmstruct = localtime(&end_time);
        strftime(runtime,sizeof(runtime),"%m/%d/%Y - %H:%M:%S",tmstruct);

        printf("\n\n\tEnding Time (%s)\n",runtime);

	return 0;
}
/*

*/
void initialize()
{
	#if DEBUG
		printf("\ninitialize");
		fflush(stdout);
	#endif
	lead_time=0;
	lead_time_i=0;
	lead_time_days=0;
	lead_time_days_i=0;
	qty_ordered=0;
	qty_ordered_i=0;
	unit_price=0;
	unit_price_i=0;
	extd_amt_display=0;
	extd_amt_display_i=0;
	ichs_unit_price=0;
	ichs_unit_price_i=0;
	fdw_unit_price=0;
	sweep_uc_price=0;
	sweep_uc_price_i=0;
	ngc_price=0;
	ngc_price_i=0;
	ichs_part_price=0;
	ichs_part_price_i=0;
	avg_order_mod_price=0;
	avg_order_mod_price_i=0;
	avg_price_output=0;
	best_price=0;
	best_price_i=0;
	best_ext_price=0;
	best_ext_price_i=0;
	rem_amt=0;
	rem_amt_i=0;
	rem_qty=0;
	rem_qty_i=0;
	est_sched_year=0;
	est_sched_mo=0;
	est_sched_day=0;
	nwp_commit_qty=0;
	nwp_commit_amt=0;
	caps_commit_qty=0;
	caps_commit_amt=0;
	commit_qty=0;
	commit_amt=0;
	liq_qty=0;
	liq_amt=0;
	/*po_line_num=0;
	po_line_num_i=0;*/
	strcpy((char *) part_source.arr, " ");
	strcpy((char *) buyAuthNeed.arr, " ");
	memset(order_no.arr,' ',20);
	memset(sc.arr,' ',20);
	memset(buyer.arr,' ',25);
	memset(part.arr,' ',50);
	memset(prime.arr,' ',50);
	memset(mystatus.arr,' ',2);
	memset(vendor_code.arr,' ',15);
	memset(crtdocdte.arr,' ',24);
	memset(bkupcdte.arr,' ',24);
	memset(createdte.arr,' ',10);
	memset(smrc.arr,' ',9);
	memset(remarks.arr,' ',180);
	memset(ims_designator_code.arr,' ',20);
	memset(dps_contract_clin.arr,' ',20);
	memset(dps_contract_elin.arr,' ',20);
	memset(activity_id.arr,' ',15);
	memset(po.arr,' ',20);
	memset(po_line.arr,' ',6);
	memset(price_type.arr,' ',2);
	memset(noun.arr,' ',40);
	memset(nsn.arr,' ',16);
	memset(niin.arr,' ',11);
	memset(cog.arr,' ',2);
	memset(smic.arr,' ',2);
	escalation_price=0;
	escalation_pcnt=0;
	memset((char *) escalation_fromdate.arr,' ',4);
	memset((char *) pc_release_date.arr,' ',10);
	pc_release_date_i=-1;
	memset((char *) awo_jicc.arr,' ',10);
	memset((char *) chk_jicc_job.arr,' ',10);
	memset((char *) order_mod.arr,' ',20);
	po_price=0;
}
/*
^L
*/
int     A999_00_open_files()
{
	int     errcode=0;

	#if DEBUG
		printf("\nA999_00_open_files");
		fflush(stdout);
	#endif

	if ((fp_out=fopen(output_file,"w")) == NULL)
	{
		printf("\n***********************************************************");
	    	printf("\n*                                                         *");
		printf("\n* Could not open Input File (%s) ",output_file);
		printf("\n*                                                         *");
		printf("\n***********************************************************");
		errcode=500;
	}		
	else
	{
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		printf("\n~                                                                   ~");
		printf("\n~  Processing Output File (%s) ",output_file);
		printf("\n~                                                                   ~");
		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	}
	
	return(errcode);
}
/*

*/
void	setup_default_job()
{
	int	i=0;

	#if DEBUG
		printf("\nsetup_default_job");
		fflush(stdout);
	#endif

	for(i=0;i<99;i++)
	{
		memset((char *) default_job_tble[i].pgm_system,' ',20);
		memset((char *) default_job_tble[i].default_job,' ',20);
	}

	get_default_job();
}
/*

*/
void get_default_job()
{
	int	fetch_sw=1;
	int	data_found=1;
	char	prev_system[21];
	int	i=0;

	#if DEBUG
		printf("\nget_default_job");
		fflush(stdout);
	#endif

	memset(prev_system,' ',20);
	memset(processing_job.arr,' ',3);
     	memset((char *) default_job_date.arr,' ',9);
    	memset((char *) default_system.arr,' ',20);
     	memset((char *) default_job.arr,' ',20);

	EXEC SQL DECLARE get_default_job_csr CURSOR FOR
		select distinct to_char(start_date,'YYYYMMDD'),
			system,
			job
		from scm.acdc_contract_job_multi
		where 1=1
		and to_char(start_date,'YYYYMMDD') <= to_char(sysdate,'YYYYMMDD')
		order by 1 desc;

	EXEC SQL OPEN get_default_job_csr;

	if(sqlca.sqlcode == 0)
	{
	     while(fetch_sw)
	     {
		     memset((char *) default_job_date.arr,' ',9);
		     memset((char *) default_system.arr,' ',20);
		     memset((char *) default_job.arr,' ',20);
		     EXEC SQL FETCH get_default_job_csr INTO
			:default_job_date,
			:default_system,
			:default_job;

			if(sqlca.sqlcode == 0)
			{
				data_found=0;
				#if DEBUG
					printf("\nDate (%s) (%d)",(char *) default_job_date.arr,default_job_date.len);
					printf("\nSYSTEM (%s) (%d)",(char *) default_system.arr,default_system.len);
					printf("\nJOB (%s) (%d)",(char *) default_job.arr,default_job.len);
					fflush(stdout);
				#endif
				if(strncmp((char *) processing_job.arr,"   ",3)==0)
				{
					strncpy((char *) processing_job.arr,(char *) default_job.arr,default_job.len);
					processing_job.len=default_job.len;
				}
				if(strncmp((char *) default_system.arr,prev_system,default_system.len)==0)
				{
				}
				else
				{
					strncpy((char *) default_job_tble[i].pgm_system,(char *) default_system.arr,default_system.len);
					strncpy((char *) default_job_tble[i].default_job,(char *) default_job.arr,default_job.len);
					i++;
					memset(prev_system,' ',20);
					strncpy(prev_system,(char *) default_system.arr,default_system.len);
				}
			}
			else
			{
				fetch_sw=0;
				if(sqlca.sqlcode == NOTFND)
				{
					if(data_found==0)
					{
					}
					else
					{
						printf("\nUnable to locate Default Jobs");
						exit;
					}
				}
				else
				{
					db_err("get_default_job - Fetch Cursor");
				}
			}
		}
		#if DEBUG
			printf("\nDisplay Default Table");
		for(i=0;i<99;i++)
		{
			if(strncmp((char *) default_job_tble[i].pgm_system,"    ",4)==0)
			{
				i=200;
			}
			else
			{
				printf("\nDefault System (%20.20s) Job (%20.20s)",(char *) default_job_tble[i].pgm_system,(char *) default_job_tble[i].default_job);
				fflush(stdout);
			}
		}
		#endif
	}
	else
	{
			db_err("get_default_job - Open Cursor");
	}
}
/*

*/

/*Finds the initial additional buy information from GOLD.  Loops through query and for each returned row calls several functions to find other data elements*/

void query_add_buy_auth_ords()
{
	int found = 1;	
	int errcode=0;

	#if DEBUG
		printf("\nquery_add_buy_auth_ords");
		fflush(stdout);
	#endif

	
	EXEC SQL DECLARE add_buy_csr CURSOR FOR
		select distinct o.order_no, 
			o.sc,
			o.part, 
			c.prime,
			decode(o.status,'O','OPEN', 'C','CANCELLED', 'F','FROZEN', 'U','UNAUTHORIZED', 'R','RESERVED', 'S','SATISFIED', 'K','K', 'UNKNOWN') mystatus,
			nvl(o.vendor_code,' ') vendor_code, 
			0,
			(nvl(o.qty_original_ordered,0) + nvl(o.qty_added,0)) - nvl(o.qty_canc,0) qty_ordered, 
			nvl(to_char(nvl(o.created_docdate,o.created_datetime),'mm/dd/yyyy'),' ') crtdocdte,
			nvl(priority,0),
			nvl(to_char(nvl(o.created_datetime,o.created_datetime),'yyyy-mm-dd'),' '),
			nvl(c.smrc,' '), 
			nvl(c.remarks,' '), 
			nvl(c.ims_designator_code,' '),
			nvl(o.po,' ') po, 
			nvl(o.po_line,' ') poline,
			nvl(c.noun,' ') noun,
			nvl(c.nsn,' ') nsn,
			nvl(c.nin,' ') niin,
			nvl(c.cognizance_code,' ') cog,
			nvl(b.buyer_name,' '),
			nvl(n.nsn_smic,' ') smic,
			nvl(to_char(o.created_docdate,'yyyymmdd'),' ') datesort,
			substr(o.awo,1,3)||' '||substr(o.awo,4,2)||' '||substr(o.awo,6,3),
			nvl(po_price,0)
		from ord1 o,
			cat1 c,
			nsn1 n,
/*			pur1 p, */
			sybu b,
			venn vn
		where o.order_type = 'C' 
			and o.part = c.part 
/*			and p.order_no = o.order_no (+)  */
			and o.buyer=b.buyer_code (+)
			and c.nsn=n.nsn(+)
/*			and (o.order_no like 'F18S%' or o.order_no like 'AV8BHS%') */
			and (o.order_no like 'AV8BHS%'
			       or o.order_no like 'AV8BHE%' 
			       or o.order_no like 'AV8BHM%'
			       or o.order_no like 'AV8BHW%')
			and o.status in ('O','C','F','U','R','S','K')
			and o.vendor_code = vn.vendor_code(+)
/*			and o.order_no in ('AV8BHS070001','F18S0703398') */
/*			and o.order_no='AV8BHE090458T'  */
/*			and o.part = 'MS20470A2-4' */
		order by datesort desc, o.order_no, o.part,mystatus,vendor_code;
		
	EXEC SQL OPEN add_buy_csr;
	if(sqlca.sqlcode == 0)
	{
	  while(found)
	  {
		#if DEBUG
			printf("\n######################### query_add_buy_auth_ords - Fetch #############################");
			fflush(stdout);
		#endif
	     initialize();
	     
	     EXEC SQL FETCH add_buy_csr INTO
		:order_no,
		:sc,
		:part,
		:prime,
		:mystatus,
		:vendor_code,
		:unit_price:unit_price_i,
		:qty_ordered:qty_ordered_i,
		:crtdocdte,
		:priority,
		:createdte,
		:smrc,
		:remarks,
		:ims_designator_code,
		:po,
		:po_line,
		:noun,
		:nsn,
		:niin,
		:cog,
		:buyer,
		:smic,
		:datesort,
		:awo_jicc,
		:po_price;
		
             if(sqlca.sqlcode == NOTFND)
             {
		#if DEBUG
			printf("\n*****************************************************************************");
			printf("\nNo Rows Found");
			printf("\n*****************************************************************************");
			fflush(stdout);
		#endif
             	found = 0;
             }
	     else
	     {
		if(sqlca.sqlcode == 0)
		{
		
			#if DEBUG
				printf("\n*****************************************************************************");
				printf("\nFetch Row Order No (%s)",(char*) order_no.arr);
				printf("\n          Part No (%s)",(char*) part.arr);
				printf("\n          unit price (%.2f)",unit_price);
				printf("\n          Ord1 AWO   (%s) (%d) ",(char *) awo_jicc.arr,awo_jicc.len);
				printf("\n          PO Nbr     (%s) (%d) ",(char *) po.arr,po.len);
				printf("\n          PO Line    (%s) (%d) ",(char *) po_line.arr,po_line.len);
				printf("\n          PO Price   (%.2f) ",po_price);
				printf("\n*****************************************************************************");
				fflush(stdout);
			#endif

			input_ctr++;
			memset(best_price_source.arr, ' ',30);
			memset(best_price_cat.arr, ' ',40);

      assert(order_no.len < sizeof(order_no.arr)) ;
			order_no.arr[order_no.len] ='\0';

      assert(part.len < sizeof(part.arr)) ;
			part.arr[part.len] ='\0';

			mystatus.arr[mystatus.len] ='\0';
			vendor_code.arr[vendor_code.len] ='\0';
			crtdocdte.arr[crtdocdte.len] ='\0';
			smrc.arr[smrc.len] ='\0';
			remarks.arr[remarks.len] ='\0';
			ims_designator_code.arr[ims_designator_code.len] ='\0';
			po.arr[po.len] ='\0';
			po_line.arr[po_line.len] ='\0';
			
			/* determine Basic Part format */
			memset(part_basic.arr,' ',50);
			strncpy((char *) part_basic.arr,(char *) part.arr,part.len);
			part_basic.len=part.len;

			#if DEBUG
				printf("\n*****************************************************************************");
				printf("\nCalling SetBasicPart -  Part (%s) (%d)",(char *) part.arr,part.len);
				printf("\n                        BasicPart (%s) (%d)",(char *) part_basic.arr,part_basic.len);
				printf("\n*****************************************************************************");
				fflush(stdout);
			#endif

			SetBasicPart(part_basic.arr,part_basic.len);

			#if DEBUG
				printf("\n*****************************************************************************");
				printf("\nReturn from SetBasicPart BasicPart (%s) (%d)",(char *) part_basic.arr,part_basic.len);
				printf("\n*****************************************************************************");
				fflush(stdout);
			#endif

			/* Extracts the month and year from the submittal date */
			strncpy((char *) crtdocdte_month.arr, (char*) &crtdocdte.arr[0], 2);
			strncpy((char *) crtdocdte_day.arr, (char*) &crtdocdte.arr[3], 2);
			strncpy((char *)crtdocdte_year.arr, (char*) &crtdocdte.arr[6], 4);
			crtdocdte_month.len = strlen((char *) crtdocdte_month.arr);
			crtdocdte_month.arr[crtdocdte_month.len]= '\0';
			crtdocdte_year.len = strlen((char *) crtdocdte_year.arr);
			crtdocdte_year.arr[crtdocdte_year.len]= '\0';
			
			/* Concatenates the po and po line item */
			strcpy((char *)po_po_line.arr, (char *) po.arr);
			strcat((char *)po_po_line.arr, (char *) po_line.arr);
			
			/* Concatenates the po, po line item, and part */
			strcpy(po_po_line_part.arr, po_po_line.arr);
			strcat(po_po_line_part.arr, part.arr);
			po_po_line_part.len=strlen(po_po_line_part.arr);
			
			errcode=set_cust_model();
			if(strncmp((char *) awo_jicc.arr," ",1) == 0)
			{
				query_jicc();
			}
			else
			{
				strncpy((char *) jicc.arr,awo_jicc.arr,awo_jicc.len);
				jicc.len=awo_jicc.len;
				check_valid_job();
			}
			query_cage();
			query_order_deliv_info();
			query_best_price();
			query_cost_acct();
			query_vendor_name();
			calculate_escalation_adjmnt();
			
			if(output_type[0] == 'f')
			{
				write_output();
			}
			else
			{
				insert_record();
			}
		}
	     	else
			db_err("query_add_buy_auth_ords");
	      }
	  }
	}
	else
	{
		db_err("query_add_buy_auth_ords");
	}
}
/*

*/
void query_best_price()
{
/* Finds the best available price for each item.  As soon as it finds a non-zero price it stops.
The current order for best price is:
	1. po price from commit_liq_data (scm.acdc_ichs_data)
	2. northrop price for part (scm.acdc_ngc_pricing)
	3. last part price from commit_liq_data (scm.acdc_ichs_data)
	4. Price from SLIC (DLSC, CAT, or NEG)
	5. avg price for that order mod (scm.acdc_ichs_data)
	6. avg price for all parts (scm.acdc_ichs_data) 
*/
	#if DEBUG
		printf("\nquery_best_price");
		printf("\nunit price (%.2f)",unit_price);
		printf("\nRelease Type (%s)",releaseType.arr);
		fflush(stdout);
	#endif

	best_price = 0;
	memset((char *) best_price_source.arr, ' ',30);
	memset((char *) best_price_cat.arr, ' ',40);

	if((strncmp((char *) releaseType.arr,"MM",2)==0) ||
	   (strncmp((char *) releaseType.arr,"PM",2)==0) ||
	   (strncmp((char *) releaseType.arr,"CD",2)==0))
	{
		query_sweep_price();
	}
	else
	{ 
	   	#if DEBUG
			printf("\nPO Number (%s) (%d)",(char *) po.arr,po.len);
			printf("\nPO line (%s) (%d)",(char *) po_line.arr,po_line.len);
			printf("\nRelease Type (%s) (%d)",(char *) releaseType.arr,releaseType.len);
			fflush(stdout);
	   	#endif

		numeric_po=0;
		numeric_po=isNum((char *) &po.arr);
		#if DEBUG
			printf("\nReturn from isNum for checking PO vs PR  (%i)",numeric_po);
			fflush(stdout);
		#endif
		if(numeric_po == 1)
		{
			if((releaseType.len== 0) &&
			   (strncmp((char *) po.arr," ",1)==0) &&
			   (strncmp((char *) po_line.arr," ",1)==0))
			{
				query_sweep_price();
				memset((char *) releaseType.arr,'?',2);
				releaseType.len=2;
			}
			else
			{
				query_PO_ICHS_price();
				if(ichs_unit_price != 0)
				{
			   		strcpy((char *) best_price_source.arr, "PO Price");
					strcpy((char *) best_price_cat.arr, "PO Price");
				}
			}
		}
	}
	#if DEBUG
		printf("\nichs_unit_price (%.2f)",ichs_unit_price);
		fflush(stdout);
	#endif
	if(ichs_unit_price == 0)
	{
	   if (po_price == 0)
	   {
		   get_scm_price_new();
		   if (best_price == 0)
		   {
			query_hd_data();
			if(unit_price == 0)
			{
				best_price=0;
				strcpy((char *) best_price_source.arr, "NO PRICE INFO");
				best_price_source.len=13;
				strcpy((char *) best_price_cat.arr, "NO PRICE INFO");
				best_price_cat.len=13;
			 }
			 else
			 {	
				best_price = unit_price;
				strcpy((char *) best_price_source.arr, (char *) prcType.arr);
				strcat((char *) best_price_source.arr, " Price");
				strcpy((char *) best_price_cat.arr, "SLIC Price");
				#if DEBUG
					printf("\n\tquery_best_price - SLIC Price");
					printf("\n\tCat (%s) ",best_price_cat.arr);
					printf("\n\tSource (%s) ",best_price_source.arr);
					fflush(stdout);
				#endif
			}
		 }
	    }
	    else
	    {
		if(strncmp((char *) order_no.arr,"AV8BHE",6)==0)
		{
			best_price = po_price;
			strcpy((char *) best_price_source.arr, "DLA");
			strcpy((char *) best_price_cat.arr, "EMALL PRICE");
		}
		else
		{
			if(strncmp((char *) order_no.arr,"AV8BHM",6)==0)
			{
				best_price = po_price;
				strcpy((char *) best_price_source.arr, "FRC");
				strcpy((char *) best_price_cat.arr, "FLEET READINESS PRICE");
			}
			else
			{
				if(strncmp((char *) order_no.arr,"AV8BHW",6)==0)
				{
					best_price = po_price;
					strcpy((char *) best_price_source.arr, "OVERRIDE");
					strcpy((char *) best_price_cat.arr, "ASSET MGR OVERRIDE");
				}
				else
				{
				}
			}
		}
	    }
	}
	else
	{
	   best_price = ichs_unit_price;
 		#if DEBUG
			printf("\n\tquery_best_price - PO Price");
			printf("\n\tCat (%s) ",best_price_cat.arr);
			printf("\n\tSource (%s) ",best_price_source.arr);
			fflush(stdout);
		#endif
	}
	best_ext_price = best_price * qty_ordered;
	best_price_source.len = strlen((char *) best_price_source.arr);
	best_price_source.arr[best_price_source.len] = '\0';
	best_price_cat.len = strlen((char *) best_price_cat.arr);
	best_price_cat.arr[best_price_cat.len] = '\0';
}
/*

*/
void get_scm_price_new ()
{

	#if DEBUG
		printf("\nget_scm_price_new");
		printf("\nPart (%s) ",part.arr);
		printf("\nPrime (%s) ",prime.arr);
		printf("\nJICC (%s) ",jicc.arr);
		printf("\nChk JICC (%s) (%d)",(char *) chk_jicc_job.arr,chk_jicc_job.len);
		printf("\nDefault Job (%s) (%d)",(char *) default_job.arr,default_job.len);
		printf("\nProcessing Job (%s) (%d)",(char *) processing_job.arr,processing_job.len);
		fflush(stdout);
	#endif

	EXEC SQL DECLARE get_scm_price_new CURSOR FOR
		select distinct b.price_source,
			   b.price_cat,
			   nvl(a.price,0),
			   to_char(c.start_date,'YYYYMMDD') start_date,
			   to_char(b.price_order,'999')
	       from scm.acdc_pboms_multi a,
		  scm.acdc_price_order_multi b,
		  scm.acdc_contract_job_multi c
		where 1=1
		  and (part = :part or part = :prime)
		  and a.price_source=b.price_source
		  and b.job=rtrim(:chk_jicc_job)
		  and b.job=c.job
/*		  and to_char(c.start_date,'YYYYMMDD') <= to_char(sysdate,'YYYYMMDD') */
		  and price > 0
		order by 4 desc,to_char(b.price_order,'999') asc;

	EXEC SQL OPEN get_scm_price_new;

	if (sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH get_scm_price_new INTO
			:best_price_source:best_price_source_i,
			:best_price_cat:best_price_cat_i,
			:best_price:best_price_i,
			:contract_start:contract_start_i,
			:price_order:price_order_i;

		if (sqlca.sqlcode == 0)
		{
			#if DEBUG
				printf("\nBest Price Source (%s) (%d)",(char *) best_price_source.arr,best_price_source.len);
				printf("\nBest Price Cat (%s) (%d) ",(char *) best_price_cat.arr,best_price_cat.len);
				printf("\nBest Price ($%.2f) ",best_price);
				printf("\nContract Start (%s) (%d) ",(char *) contract_start.arr,contract_start.len);
				printf("\nPrice Order (%d) ",price_order);
				fflush(stdout);
			#endif
		}
		else
		{
			if (sqlca.sqlcode == NOTFND)
			{
			}
			else
			{
				 printf("\nGold Order No (%s) ",(char *) order_no.arr);
				 db_err("get_scm_price_new - Fetch");
			}
		}
	}
	else
	{
		 printf("\nGold Order No (%s) ",(char *) order_no.arr);
		 db_err("get_scm_price_new - Open Cursor");
	}
}
/*

*/
void get_scm_price ()
{

/*Attempts to find a price based on the part number.  The scm.scm_price_logic contains the actual prices.  The scm.acdc_price_order table 
tells the order in which to look for the various prices.  If the*/
	
	float T14_INH_PBOM =0;
	short T14_INH_PBOM_i=0;
	float T14_SUP_PBOM =0;
	short T14_SUP_PBOM_i=0;
	float TA9_INH_PBOM =0;
	short TA9_INH_PBOM_i=0;
	float TA9_SUP_PBOM =0;
	short TA9_SUP_PBOM_i=0;
	float TA8_INH_PBOM =0;
	short TA8_INH_PBOM_i=0;
	float TA8_SUP_PBOM =0;
	short TA8_SUP_PBOM_i=0;
	float TA6_INH_PBOM =0;
	short TA6_INH_PBOM_i=0;
	float TA6_SUP_PBOM=0;
	short TA6_SUP_PBOM_i=0;
	float TA5_INH_PBOM=0;
	short TA5_INH_PBOM_i=0;
	float TA5_SUP_PBOM=0;
	short TA5_SUP_PBOM_i=0;
	float TA4_INH_PBOM=0;
	short TA4_INH_PBOM_i=0;
	float TA4_SUP_PBOM=0;
	short TA4_SUP_PBOM_i=0;
	float TA4_NGC=0;
	short TA4_NGC_i=0;
	float TA12_NGC=0;
	short TA12_NGC_i=0;
	float APL_PRICE=0;
	short APL_PRICE_i=0;
	float PN_PO_PRICE=0;
	short PN_PO_PRICE_i=0;
	int temp_a;
	int temp_b;
	int temp_c;
	int temp_d;
		
	#if DEBUG
		printf("\nget_scm_price");
		printf("\nPart (%s) ",part.arr);
		printf("\nPrime (%s) ",prime.arr);
		fflush(stdout);
	#endif

	if ((strstr((char *) jicc.arr, "TA4") != NULL)||(strstr((char *) jicc.arr, "TA1") != NULL)||(strstr((char *) jicc.arr, "TA2") != NULL))
	{
		strcpy((char *) contract.arr,"TA4_order");
	}
	else if (strstr((char *) jicc.arr, "TA5") != NULL)
	{
		strcpy((char *) contract.arr,"TA5_order");
	}
	else if (strstr((char *) jicc.arr, "TA6") != NULL)
	{
		strcpy((char *) contract.arr,"TA6_order");
	}
	else if (strstr((char *) jicc.arr, "TA8") != NULL)
	{
		strcpy((char *) contract.arr,"TA8_order");
	}
	else if (strstr((char *) jicc.arr, "TA9") != NULL)
	{
		strcpy((char *) contract.arr,"TA9_order");
	}
	else if (strstr((char *) jicc.arr, "T14") != NULL)
	{
		strcpy((char *) contract.arr,"T14_order");
	}
	else
	{
		#if DEBUG
			printf("\nget_scm_price");
			printf("\nTaking Default Contract");
			fflush(stdout);
		#endif
		strcpy((char *) contract.arr,"T14_order");
	}
	contract.len = strlen((char *) contract.arr);
	contract.arr[contract.len] = '\0';
	
	EXEC SQL DECLARE get_scm_price CURSOR FOR
	select TA8_INH_PBOM,
		TA8_SUP_PBOM,
		TA6_INH_PBOM,
		TA6_SUP_PBOM,
		TA5_INH_PBOM,
		TA5_SUP_PBOM,
		TA4_INH_PBOM,
		TA4_SUP_PBOM,
		TA4_NGC,        
		TA12_NGC,       
		APL_PRICE,      
		PN_PO_PRICE,
		TA9_INH_PBOM,
		TA9_SUP_PBOM,
		T14_INH_PBOM,
		T14_SUP_PBOM 
		from scm.scm_price_logic
		where (part = :part or part = :prime);
	
	EXEC SQL OPEN get_scm_price;
	if (sqlca.sqlcode == 0)
	{
	   	EXEC SQL FETCH get_scm_price INTO
		   	:TA8_INH_PBOM:TA8_INH_PBOM_i,
		   	:TA8_SUP_PBOM:TA8_SUP_PBOM_i,
		   	:TA6_INH_PBOM:TA6_INH_PBOM_i,
			:TA6_SUP_PBOM:TA6_SUP_PBOM_i,
			:TA5_INH_PBOM:TA5_INH_PBOM_i,
			:TA5_SUP_PBOM:TA5_SUP_PBOM_i,
			:TA4_INH_PBOM:TA4_INH_PBOM_i,
			:TA4_SUP_PBOM:TA4_SUP_PBOM_i,
			:TA4_NGC:TA4_NGC_i,        
			:TA12_NGC:TA12_NGC_i,       
			:APL_PRICE:APL_PRICE_i,      
			:PN_PO_PRICE:PN_PO_PRICE_i,	
		   	:TA9_INH_PBOM:TA9_INH_PBOM_i,
		   	:TA9_SUP_PBOM:TA9_SUP_PBOM_i,
		   	:T14_INH_PBOM:T14_INH_PBOM_i,
		   	:T14_SUP_PBOM:T14_SUP_PBOM_i;
	
		#if DEBUG
			printf("\n\tget_scm_price");
			printf("\n\tcontract: (%s) ",contract.arr);
			printf("\n\tSQL (%s) ",stmt.arr);
			fflush(stdout);
		#endif

		 memset((char *) stmt.arr, ' ', 5000);
		 strcpy((char *) stmt.arr, " select price_type,");
		 strcat((char *) stmt.arr, "        price_cat,");
		 strcat((char *) stmt.arr, "        TA4_order,");
		 strcat((char *) stmt.arr, "        TA5_order,");
		 strcat((char *) stmt.arr, "        TA6_order,");
		 strcat((char *) stmt.arr, "        TA8_order,");
		 strcat((char *) stmt.arr, "        TA9_order,");
		 strcat((char *) stmt.arr, "        T14_order");
		 strcat((char *) stmt.arr, "   from scm.acdc_price_order");
		 strcat((char *) stmt.arr, "   order by "); 
		 strcat((char *) stmt.arr, (char *) contract.arr);


		stmt.len = strlen((char *) stmt.arr);
		EXEC SQL PREPARE get_scm_price_stmt FROM :stmt;
		EXEC SQL DECLARE get_scm_price_order CURSOR FOR get_scm_price_stmt;


	/*	EXEC SQL DECLARE get_scm_price_order CURSOR FOR
			select price_type,
			price_cat,
			TA4_order,
			TA5_order,
			TA6_order,
			TA8_order
			from scm.scm_price_order
			order by :contract;*/

			
		EXEC SQL OPEN get_scm_price_order;
		int price_count = 0;
		while(best_price == 0 && price_count < 12)
		{
			EXEC SQL FETCH get_scm_price_order INTO
			:best_price_source,
			:best_price_cat,
			:temp_a,
			:temp_b,
			:temp_c,
			:temp_d;
			
			best_price_source.arr[best_price_source.len] = '\0';
			best_price_cat.arr[best_price_cat.len] = '\0';
		
			/*
			#if DEBUG
				printf("\n\tget_scm_price - Fetch");
				printf("\n\tCat (%s) ",best_price_cat.arr);
				printf("\n\tSource (%s) ",best_price_source.arr);
				printf("\n\tPrice Count (%d) ", price_count);
				fflush(stdout);
			#endif
			*/
			if (strcmp((char *) best_price_source.arr, "T14_INH_PBOM")==0)
			{
				best_price = T14_INH_PBOM;
			}
			else if (strcmp((char *) best_price_source.arr, "T14_SUP_PBOM")==0)
			{
				best_price = T14_SUP_PBOM;
			}
			else if (strcmp((char *) best_price_source.arr, "TA9_INH_PBOM")==0)
			{
				best_price = TA9_INH_PBOM;
			}
			else if (strcmp((char *) best_price_source.arr, "TA9_SUP_PBOM")==0)
			{
				best_price = TA9_SUP_PBOM;
			}
			else if (strcmp((char *) best_price_source.arr, "TA8_INH_PBOM")==0)
			{
				best_price = TA8_INH_PBOM;
			}
			else if (strcmp((char *) best_price_source.arr, "TA8_SUP_PBOM")==0)
			{
				best_price = TA8_SUP_PBOM;
			}
			else if (strcmp((char *) best_price_source.arr, "TA6_INH_PBOM")==0)
			{
				best_price = TA6_INH_PBOM;
			}
			else if (strcmp((char *) best_price_source.arr, "TA6_SUP_PBOM")==0)
			{
				best_price = TA6_SUP_PBOM;
			}
			else if (strcmp((char *) best_price_source.arr, "TA5_INH_PBOM")==0)
			{
				best_price = TA5_INH_PBOM;		
			}
			else if (strcmp((char *) best_price_source.arr, "TA5_SUP_PBOM")==0)
			{
				best_price = TA5_SUP_PBOM;		
			}
			else if (strcmp((char *) best_price_source.arr, "TA4_INH_PBOM")==0)
			{
				best_price = TA4_INH_PBOM;		
			}
			else if (strcmp((char *) best_price_source.arr, "TA4_SUP_PBOM")==0)
			{
				best_price = TA4_SUP_PBOM;		
			}
			else if (strcmp((char *) best_price_source.arr, "TA4_NGC")==0)
			{
				best_price = TA4_NGC;		
			}
			else if (strcmp((char *) best_price_source.arr, "TA12_NGC")==0)
			{
				best_price = TA12_NGC;		
			}
			else if (strcmp((char *) best_price_source.arr, "APL_PRICE")==0)
			{
				best_price = APL_PRICE;		
			}
			else if (strcmp((char *) best_price_source.arr, "PN_PO_PRICE")==0)
			{
				best_price = PN_PO_PRICE;			
			}
			else
			{
				best_price = 0;
/*				printf("Invalid Best Price Source: %s\n",best_price_source.arr); */

			}
			price_count++;
			/*printf("Best price = %s\n",best_price);*/
		}
	
	}	
}
/*

*/
void query_jicc()
{
/* Using the order mod, finds the proper jicc */
	int found = 1;
	int i = 0;
	int i1 = 0;
		
	#if DEBUG
		printf("\nquery_jicc");
		printf("\nCreated Doc Date (%s)",(char *) crtdocdte.arr);
		printf("\nCreated DateTime (%s)",(char *) createdte.arr);
		printf("\nOrder Priority   (%i)",priority);
		fflush(stdout);
	#endif

	strcpy((char *) jicc.arr, " ");
	jicc.arr[jicc.len] ='\0';
	memset((char *) chk_jicc_job.arr,' ',10);
	chk_jicc_job.len=10;
	memset((char *) order_mod.arr,' ',20);
	order_mod.len=0;
		
	EXEC SQL DECLARE get_jicc CURSOR FOR
	        SELECT nvl(order_modif,' ') order_modif, 
	          nvl(user_ref2,' ')
		FROM pur1
		WHERE order_no = :order_no;
	
	EXEC SQL OPEN get_jicc;
	if(sqlca.sqlcode == 0)
	{
	   	EXEC SQL FETCH get_jicc INTO
		:order_mod,
		:user_ref2;
		if(sqlca.sqlcode == 0)
		{
			#if DEBUG
				printf("\n\tFound Order Mod");
				printf("\n\tOrder mod (%s) (%d)",(char *) order_mod.arr,order_mod.len);
				fflush(stdout);
			#endif
			order_mod.arr[order_mod.len] ='\0';
			user_ref2.arr[user_ref2.len] ='\0';

			if(order_mod.arr[0] != ' ')
			{
				EXEC SQL
					SELECT jicc
					INTO :jicc
					FROM scm.jicc_order_mod
					WHERE rtrim(order_mod) = rtrim(:order_mod);					

				if(sqlca.sqlcode==0)
				{
					#if DEBUG
						printf("\n\t\tFound JICC");
						printf("\n\tJICC (%s) (%d)",(char *) jicc.arr,jicc.len);
						fflush(stdout);
					#endif
					#if DEBUG
						printf("\nquery_jicc");
						printf("\nJICC (%s) (%d)",(char *) jicc.arr,jicc.len);
						fflush(stdout);
					#endif
				}
				else
				{
					if(sqlca.sqlcode==NOTFND)
					{
						#if DEBUG
							printf("\n\t\tJICC Not Found");
							fflush(stdout);
						#endif
						memset((char *) jicc.arr,' ',10);
						jicc.arr[0]='\0';
						jicc.len=0;
					}
					else
					{
						printf("\nGold Order No (%s) ",(char *) order_no.arr);
						printf("\nOrder Mod (%s) ",(char *) order_mod.arr);
						db_err("query_jicc - SELECT JICC from scm.jicc_order_mod");
					}
				}
			}
			order_mod.arr[order_mod.len] ='\0';
		}
		else
		{
			#if DEBUG
				printf("\n\tOrder Mod Not Found");
				fflush(stdout);
			#endif
/*			strcpy((char *) order_no.arr, " "); */
			strcpy((char *) order_mod.arr, " ");
			strcpy((char *) user_ref2.arr, " ");
		}
	}
	else
	{
/*		strcpy((char *) order_no.arr, " "); */
		strcpy((char *) order_mod.arr, " ");
		strcpy((char *) user_ref2.arr, " ");
	}
	
	jicc.len = strlen((char *) jicc.arr);
	jicc.arr[jicc.len] ='\0';
	order_mod.arr[order_mod.len] ='\0';

	check_valid_job();

	#if DEBUG
		printf("\nExit query_jicc");
		printf("\nUser Ref2 (%s) (%d)",(char *) user_ref2.arr,user_ref2.len);
		printf("\nJICC (%s) (%d) (%d)",(char *) jicc.arr,jicc.len,strlen((char *) jicc.arr));
		fflush(stdout);
	#endif

	check_user_ref2_expedite();

	user_ref2.arr[user_ref2.len] ='\0';
}
/*

*/
void check_valid_job()
{
	count_jobs=0;
	int	i=0;

	#if DEBUG
		printf("\ncheck_valid_job");
		printf("\njicc (%s) (%d)",(char *) jicc.arr,jicc.len);
		printf("\ndefault_job (%s) (%d) (%d)",(char *) default_job.arr,default_job.len,strlen((char *) default_job.arr));
		fflush(stdout);
	#endif

	set_override_job();

	#if DEBUG
		printf("\nCustomer System (%s) (%d)",(char *) cust_system.arr,cust_system.len);
		printf("\nChk JICC (%s) (%d)",(char *) chk_jicc_job.arr,chk_jicc_job.len);
		fflush(stdout);
	#endif

	EXEC SQL 
		select count(*)
		   into :count_jobs
		from scm.acdc_contract_job_multi
		where 1=1
		and job=rtrim(:chk_jicc_job)
		and system=rtrim(:cust_system); 

	if(sqlca.sqlcode == 0)
	{
		if(count_jobs > 0)	
		{
			if(strncmp((char *) chk_jicc_job.arr,"TA7",3)==0)
			{
				count_jobs=0;
			}
		}
		else
		{
			memset((char *) chk_jicc_job.arr,' ',20);
			strncpy((char *) chk_jicc_job.arr,(char *) default_job.arr,default_job.len);
			chk_jicc_job.arr[default_job.len]='\0';
			chk_jicc_job.len=default_job.len;
		}
	}
	else
	{
		if(sqlca.sqlcode == NOTFND)
		{
			printf("\nRow not Found (%d)",count_jobs);
		}
		else
		{
			db_err("check_valid_job");
		}
	}

	if(count_jobs == 0)	
	{
		for(i=0;i<99;i++)
		{
			#if DEBUG
				printf("\ncust system (%s) (%d) (%20.20s)",(char *) cust_system.arr,cust_system.len,(char *) default_job_tble[i].pgm_system);
				fflush(stdout);
			#endif
			if(strncmp((char *) cust_system.arr,(char *) default_job_tble[i].pgm_system,cust_system.len)==0)
			{
				memset((char *) chk_jicc_job.arr,' ',20);
				strncpy((char *) chk_jicc_job.arr,(char *) default_job_tble[i].default_job,20);
				chk_jicc_job.arr[10]='\0';
				chk_jicc_job.len=strlen((char *) chk_jicc_job.arr);
				i=100;
			}
			else
			{
				if(strncmp((char *) default_job_tble[i].pgm_system,"   ",3)==0)
				{
					memset((char *) chk_jicc_job.arr,' ',20);
					chk_jicc_job.arr[0]='\0';
					chk_jicc_job.len=1;
					i=100;
				}
			}
		}
	}

	#if DEBUG
		printf("\ncheck_valid_job - Exit");
		printf("\nchk_jicc_job (%s) (%d)",(char *) chk_jicc_job.arr,chk_jicc_job.len);
		fflush(stdout);
	#endif
}
/*

*/
void	set_override_job()
{

	#if DEBUG
		printf("\nset_override_job");
		printf("\nCustomer System (%s)",(char *) cust_system.arr);
		printf("\nJICC (%s)",(char *) jicc.arr);
		fflush(stdout);
	#endif

	if(strncmp((char *) cust_system.arr,"FSTACDC",7)==0)
	{
	        if(strncmp((char *) chk_jicc_job.arr,"TA1",3)==0)
		{
			strcpy((char *) chk_jicc_job.arr,"TA4");
		}
		else
		{
			if(strncmp((char *) chk_jicc_job.arr,"TA2",3)==0)
			{
				strcpy((char *) chk_jicc_job.arr,"TA4");
			}
			else
			{
			}
		}
	}
	else
	{
		if(strncmp((char *) cust_system.arr,"HISSACDC",8)==0)
		{
			strncpy(chk_jicc_job.arr,jicc.arr,3);
			chk_jicc_job.arr[3] = '-';
			chk_jicc_job.arr[4] = '\0';
			strncat( chk_jicc_job.arr, jicc.arr+6,1);
		}
	}

	#if DEBUG
		printf("\nChk JICC (%s)",(char *) chk_jicc_job.arr);
		fflush(stdout);
	#endif
}

/*

*/
void	check_user_ref2_expedite()
{
	int i1=0;
	int i=0;
	char c;

	#if DEBUG
		printf("\ncheck_user_ref2_expedite");
		printf("\nUser Ref2 (%s) (%d)",(char *) user_ref2.arr,user_ref2.len);
		printf("\nOrder Priority   (%i)",priority);
		fflush(stdout);
	#endif

	i1=user_ref2.len;

	user_ref2_numeric=isNum((char *) &user_ref2.arr);

	#if DEBUG
		printf("\nReturn from isNum  (%i)",user_ref2_numeric);
		fflush(stdout);
	#endif

	if((priority==3) && (user_ref2_numeric==1))
	{
		#if DEBUG
			printf("\nUser Ref2 is numeric (%s) (%d)",(char *) user_ref2.arr,user_ref2.len);
			fflush(stdout);
		#endif
	}
	else
	{
		if((priority <= 3) && strncmp((char *) createdte.arr,"2005-11-08",10) > 0)
		{
			memset(user_ref2.arr,' ',51);
			strncpy((char *) user_ref2.arr,"XPDITE",6);
			user_ref2.len=6;
			#if DEBUG
				printf("\nUser Ref2 (%s) (%d) (%d)",(char *) user_ref2.arr,user_ref2.len,priority);
				fflush(stdout);
			#endif
		}
		else
		{
			#if DEBUG
				printf("\nUser Ref2 (%s) (%d)",(char *) user_ref2.arr,user_ref2.len);
				fflush(stdout);
			#endif
			memset(user_ref2.arr,' ',51);
			user_ref2.len=0;
		}
	}
}
/*

*/
void query_hd_data()
{	
	varchar sortPrcType[3];
	char	mysql[2000];
		
	#if DEBUG
		printf("\nquery_hd_data");
		printf("\nPart (%s) ",part.arr);
		printf("\nCage (%s) ",MFG_cage.arr);
		fflush(stdout);
	#endif

	memset(mysql,' ',2000);

	strcpy(mysql,"select hd.UIPRICHD DLSCPRICE, ");
	strcat(mysql,"decode(hd.tuiprchd,'B','1','D','2','C','3','A','4',' ') sortPrcType, ");
	strcat(mysql,"decode(hd.tuiprchd,'A','SLIC ENGINEERING ESTIMATE','B','SLIC DLSC','C','SLIC CAT','D','SLIC NEG',' ') myPrcType ");
	strcat(mysql,"from ");
	strcat(mysql,processing_mdl);
	strcat(mysql,"_hd hd ");
	strcat(mysql,"where hd.tuiprchd in ('B','C','D') and hd.can_int = 0 ");
	strcat(mysql," and hd.refnumha = rpad('");
	strcat(mysql,(char *) part.arr);
	strcat(mysql,"',32,' ') ");
	strcat(mysql," and hd.cagecdxh = '");
	strcat(mysql,(char *) MFG_cage.arr);
	strcat(mysql,"' ");
	strcat(mysql," order by FISCYRHD DESC, sortPrcType ");

	#if DEBUG
		printf("\nSQL (%s)",mysql);
		fflush(stdout);
	#endif

	EXEC SQL PREPARE hd_cage_stmt from :mysql;

	EXEC SQL DECLARE hd_cage CURSOR FOR hd_cage_stmt;
	
	EXEC SQL OPEN hd_cage;
	if(sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH hd_cage INTO
		:unit_price, 
		:sortPrcType,
		:prcType;
		if(sqlca.sqlcode == 0)
		{
			prcType.arr[prcType.len] ='\0';
			extd_amt_display = qty_ordered * unit_price; 
			if(extd_amt_display > 10000)
			{
				strcpy((char *)buyAuthNeed.arr, "NEEDS"); 
			}
		}
		else
		{
			if(sqlca.sqlcode==NOTFND)
			{
				#if DEBUG
					printf("\nNo HD Data Found");
					fflush(stdout);
				#endif
			}
			else
			{
				printf("\nquery_hd_data - Fetch CURSOR");
				printf("\nPart (%s) ",part.arr);
				printf("\nCage (%s) ",MFG_cage.arr);
				printf("\n?\t\tSQLCODE: %d",sqlca.sqlcode);
				printf("\n?\t\tSQLERR MSG %s",sqlca.sqlerrm.sqlerrmc);
			}
		}
	}
	else
	{
		printf("\nquery_hd_data - OPEN CURSOR");
		printf("\nPart (%s) ",part.arr);
		printf("\nCage (%s) ",MFG_cage.arr);
		printf("\n?\t\tSQLCODE: %d",sqlca.sqlcode);
		printf("\n?\t\tSQLERR MSG %s",sqlca.sqlerrm.sqlerrmc);
	}
}
/*

*/
void query_cage()
{
/*Finds the cage code for the given part.  First looks at the ha table.  If cage code is not found, 
it looks at the hb table to see if that part has an alternate part number.  Then goes back to the ha 
table to find the cage code using the alternate part.  If cage code is still not found, it sets it 
to 'N/A' */
	
		
	char	mysql[2000];

	#if DEBUG
		printf("\nquery_cage");
		printf("\nPart (%s) ",part.arr);
		fflush(stdout);
	#endif

	memset(mysql,' ',2000);

	strcpy(mysql,"SELECT nvl(ha.cagecdxh,' '), nvl(ha.prdldtha,0) ");
	strcat(mysql,"FROM ");
	strcat(mysql,processing_mdl);
	strcat(mysql,"_ha ha ");
	strcat(mysql,"WHERE ha.refnumha = rpad('");
	strcat(mysql,(char *) part.arr);
	strcat(mysql,"',32,' ') ");
	strcat(mysql,"and ha.can_int = 0 ");

	#if DEBUG
		printf("\nSQL (%s)",mysql);
		fflush(stdout);
	#endif

	EXEC SQL PREPARE ha_cage_stmt from :mysql;

	EXEC SQL DECLARE ha_cage CURSOR FOR ha_cage_stmt;
	
	EXEC SQL OPEN ha_cage;
	if(sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH ha_cage INTO
		:MFG_cage, 
		:lead_time:lead_time_i;
		
		if(sqlca.sqlcode == 0)
		{
			MFG_cage.arr[MFG_cage.len] ='\0';
			part_source.arr[0] = 'A';
			hb_part.arr[0] = '\0';
		}
		else
		{
			if(sqlca.sqlcode == NOTFND)
			{
				#if DEBUG
					printf("\nNot Found HA, checking HB");
					fflush(stdout);
				#endif
				query_cage_hb();
			}
			else
			{
				if(sqlca.sqlcode == NOTFND)
				{			
					lead_time = 0;
					memset((char *) MFG_cage.arr,' ',5);
					strncpy((char *) MFG_cage.arr, "N/A",3);
				}
				else
				{
					printf("\nSQL (%s)",mysql);
					db_err("query_cage - ha_cage Fetch Cursor");
				}
			}
		}
	}
	else
	{
		printf("\nSQL (%s)",mysql);
		db_err("query_cage - ha_cage Open Cursor");
	}
	lead_time_days = lead_time * 30;
}
void query_cage_hb()
{
/*Finds the cage code for the given part.  First looks at the ha table.  If cage code is not found, 
it looks at the hb table to see if that part has an alternate part number.  Then goes back to the ha 
table to find the cage code using the alternate part.  If cage code is still not found, it sets it 
to 'N/A' */
	
		
	char	mysql[2000];

	#if DEBUG
		printf("\nquery_cage_hb");
		printf("\nPart (%s) ",part.arr);
		fflush(stdout);
	#endif

	memset(mysql,' ',2000);

	strcpy(mysql,"SELECT hb.refnumhb ");
	strcat(mysql,"FROM ");
	strcat(mysql,processing_mdl);
	strcat(mysql,"_hb hb ");
	strcat(mysql,"WHERE hb.addrefhb like '");
	strncat(mysql,(char *) part.arr,part.len);
	strcat(mysql,"%' ");
	strcat(mysql,"and hb.can_int = 0 ");

	#if DEBUG
		printf("\nSQL (%s)",mysql);
		fflush(stdout);
	#endif

	EXEC SQL PREPARE hb_cage_stmt from :mysql;

	EXEC SQL DECLARE hb_cage CURSOR FOR hb_cage_stmt;

	EXEC SQL OPEN hb_cage;
	if(sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH hb_cage INTO
			:hb_part;
			
		if(sqlca.sqlcode == 0)
		{			

			#if DEBUG
				printf("\nFound HB, checking HA with (%s) ",hb_part.arr);
				fflush(stdout);
			#endif
			query_cage_ha_hb();
		}
		else
		{
			if(sqlca.sqlcode == NOTFND)
			{			
				lead_time = 0;
				memset((char *) MFG_cage.arr,' ',5);
				strncpy((char *) MFG_cage.arr, "N/A",3);
			}
			else
			{
				printf("\nSQL (%s)",mysql);
				db_err("query_cage_hb Fetch Cursor");
			}
		}
	}
	else
	{
		printf("\nSQL (%s)",mysql);
		db_err("query_cage_hb Open Cursor");
	}
}
void query_cage_ha_hb()
{
/*Finds the cage code for the given part.  First looks at the ha table.  If cage code is not found, 
it looks at the hb table to see if that part has an alternate part number.  Then goes back to the ha 
table to find the cage code using the alternate part.  If cage code is still not found, it sets it 
to 'N/A' */
	
		
	char	mysql[2000];

	#if DEBUG
		printf("\nquery_cage_ha_hb");
		printf("\nPart (%s) ",part.arr);
		fflush(stdout);
	#endif

	memset(mysql,' ',2000);
	strcpy(mysql,"SELECT nvl(ha.cagecdxh,' '), nvl(ha.prdldtha,0) ");
	strcat(mysql,"FROM ");
	strcat(mysql,processing_mdl);
	strcat(mysql,"_ha ha ");
	strcat(mysql,"WHERE ha.refnumha = rpad('");
	strcat(mysql,(char *) hb_part.arr);
	strcat(mysql,"',32,' ') ");
	strcat(mysql,"and ha.can_int = 0 ");
	
	#if DEBUG
		printf("\nSQL (%s)",mysql);
		fflush(stdout);
	#endif

	EXEC SQL PREPARE ha_hb_cage_stmt from :mysql;

	EXEC SQL DECLARE ha_hb_cage CURSOR FOR ha_hb_cage_stmt;

	EXEC SQL OPEN ha_hb_cage;
	if(sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH ha_hb_cage INTO
			:MFG_cage,
			:lead_time:lead_time_i;	
		if(sqlca.sqlcode == 0)
		{
			MFG_cage.arr[MFG_cage.len] ='\0';
		}
		else
		{
			if(sqlca.sqlcode == NOTFND)
			{
				memset((char *) MFG_cage.arr,' ',5);
				strncpy((char *) MFG_cage.arr, "N/A",3);
				lead_time=0;
			}
			else
			{
				printf("\nSQL (%s)",mysql);
				db_err("query_cage_ha_hb Fetch Cursor");
			}
		}
	}
	else
	{
		printf("\nSQL (%s)",mysql);
		db_err("query_cage_ha_hb Open Cursor");
	}
}
/*

*/
void query_order_deliv_info()
{
/* Finds the contract date.  Uses the lisn_ssn and finds the first supplier contract_date.  Then
uses this information to estimate the ship date.  If a contract date is found it uses that date.
If not it takes the submittal date and adds the lead_time. */
	varchar frst_ship_date[25];
	int add_year;
	int num;
	varchar temp_year[5];
	varchar temp_day[5];
	varchar temp_month[5];
		
	#if DEBUG
		printf("\nquery_order_deliv_info");
		fflush(stdout);
	#endif

	strcpy((char *) contract_date.arr, "\0");
	strcpy((char *) contract_month.arr, "\0");
	strcpy((char *) contract_year.arr, "\0");
	/*strcpy((char *) releaseType.arr, "\0");*/	
	memset((char *) lisn_ssn.arr,' ',20);
	memset((char *) releaseType.arr,' ',2);

	EXEC SQL DECLARE deliv_info CURSOR FOR	
		SELECT nvl(li.lisn_ssn,' '), nvl(li.release_type,' ')
		FROM scm.scm_lisn_ssn li
		WHERE li.gold_order_no = :order_no;

	EXEC SQL OPEN deliv_info;
	if(sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH deliv_info INTO
		:lisn_ssn:lisn_ssn_i,
		:releaseType:releaseType_i;
		
		
		if(sqlca.sqlcode == 0)
		{
			
			#if DEBUG
				printf("\nlisn_ssn XXXX (%s) (%d) (%d)",lisn_ssn.arr,lisn_ssn.len,lisn_ssn_i);
				fflush(stdout);
			#endif
			lisn_ssn.arr[lisn_ssn.len] ='\0';
			if(releaseType_i==1)
			{
				memset((char *) releaseType.arr,' ',2);
				releaseType.len=2;
			}
			releaseType.arr[releaseType.len] ='\0';
			#if DEBUG
				printf("\nlisn ssn (%s) (%d)",lisn_ssn.arr,lisn_ssn.len);
				printf("\nRelease Type (%s) (%d)",releaseType.arr,releaseType.len);
				fflush(stdout);
			#endif

			EXEC SQL DECLARE ship_date_info CURSOR FOR
			select to_char(min(supplier_cont_date),'mm/dd/yyyy') contract_date
			from scm.scm_will_ship
			where lisn_ssn = :lisn_ssn
			and rsn = 'SC';

			EXEC SQL OPEN ship_date_info;
			if(sqlca.sqlcode == 0)
			{
				EXEC SQL FETCH ship_date_info INTO
				:contract_date;
				if(sqlca.sqlcode == 0)
				{
					strncpy((char *) contract_month.arr, (char*) &contract_date.arr[0], 2);
					strncpy((char *) contract_year.arr, (char*) &contract_date.arr[6], 4);
					strcpy((char *) sched_cat.arr, "Contract Date");
					est_sched_mo = atoi((char *)contract_month.arr);
					est_sched_year = atoi((char *)contract_year.arr);
					strcpy((char *) est_sched_date.arr,(char *) contract_date.arr);
				}
				else
				{
					strcpy((char *) contract_date.arr,"\0");
					strcpy((char *) contract_month.arr,"\0");
					strcpy((char *) contract_year.arr,"\0");
					if(lead_time != 0)
					{
						/* If contract date is null and the crtdocdte (Submittal Date) is not null
						it adds the lead time to the submittal date to determine the estimated ship 
						date.*/

						/* Converts crtdocdte month and year to integers*/
						est_sched_mo = atoi((char *) crtdocdte_month.arr);
						/*est_sched_day = atoi((char *) crtdocdte_day.arr);*/
						est_sched_year = atoi((char *) crtdocdte_year.arr);
						
						/* The number of years that should be added to the submittal year.*/
						add_year = (lead_time + est_sched_mo)/12;
						
						/* Finds the est sched month*/
						est_sched_mo = (lead_time + est_sched_mo) % 12;

						est_sched_year = est_sched_year + add_year;

						/* If % (mod) function returns 0, convert it to the 12th month */
						if(est_sched_mo == 0)
						{
							est_sched_mo = 12;
							est_sched_year = est_sched_year - 1;
						}
						
						if(strncmp((char *) crtdocdte_day.arr, "31",2)==0)
						{
							if((est_sched_mo == 4) || (est_sched_mo == 6) || (est_sched_mo == 9) || (est_sched_mo == 11))
							{
								strncpy((char *) crtdocdte_day.arr, "30",2);
							}
							else
							{
								if(est_sched_mo == 2)
								{
									strncpy((char *) crtdocdte_day.arr, "28",2);
								}
							}
						}
						else 
						{
							if(strncmp((char *) crtdocdte_day.arr, "29",2)>=0)
							{
								if(est_sched_mo == 2)
								{
									strncpy((char *) crtdocdte_day.arr, "28",2);
								}
							}
						}
												
						/* Takes the est schedule month converts it into a string (without converting 
						the actual est_sched_mo variable) and stores it in the est_sched_date
						variable. The num variable returns the len of the est_sched_date string. */
						if(est_sched_mo < 10)
						{
							num = sprintf((char*)est_sched_date.arr, "%d", 0);
							num = sprintf((char*)temp_month.arr, "%d", est_sched_mo);
							strcat((char *) est_sched_date.arr, (char *) temp_month.arr);
						}
						else
						{
							num = sprintf((char*)est_sched_date.arr, "%d", est_sched_mo);
						}
							
						/* Converts the est_sched_year to a string and stores it in the temp_year
						variable. */
						num = sprintf((char*)temp_year.arr, "%d", est_sched_year);

						/* Concatenates the current value in the est_sched_date variable(should be the month) with the '/DD/' segment of the date.*/
						strcat((char *) est_sched_date.arr, "/");
						strcat((char *) est_sched_date.arr, (char*) crtdocdte_day.arr);
						strcat((char *) est_sched_date.arr, "/");

						/* Concatenates the year onto the rest of the est_sched_date */
						strcat((char *) est_sched_date.arr, (char *) temp_year.arr);

					}
					else
					{
						/* If lead time is 0 then set the estimated schedule date to the submittal date*/
						est_sched_mo = atoi((char *) crtdocdte_month.arr);
						est_sched_year = atoi((char *) crtdocdte_year.arr);
						strcpy((char *) est_sched_date.arr, (char *) crtdocdte.arr);
					}
					strcpy((char *) sched_cat.arr, "Lead Time");
				}

			}
		}
		else
		{
			if(lisn_ssn_i==0)
			{
				memset((char *) lisn_ssn.arr,' ',20);
				lisn_ssn.len=0;
			}
			if(releaseType_i==1)
			{
				memset((char *) releaseType.arr,' ',2);
				releaseType.len=2;
			}
			releaseType.arr[releaseType.len] ='\0';
			if(crtdocdte.arr[0] != ' ')
			{
				/* If contract date is null and the crtdocdte (Submittal Date) is not null
				it adds the lead time to the submittal date to determine the estimated ship 
				date.*/

				/* Converts crtdocdte month and year to integers*/
				est_sched_mo = atoi((char *) crtdocdte_month.arr);
				est_sched_day = atoi((char *) crtdocdte_day.arr);
				est_sched_year = atoi((char *) crtdocdte_year.arr);

				/* Finds the est sched month*/
				add_year = (lead_time + est_sched_mo)/12;
				est_sched_mo = (lead_time + est_sched_mo) % 12;

				/* The number of years that should be added to the submittal year.*/
				est_sched_year = est_sched_year + add_year;

				/* If % (mod) function returns 0, convert it to the 12th month */
				if(est_sched_mo == 0)
				{
					est_sched_mo = 12;
					est_sched_year = est_sched_year -1;
				}

				
						if(est_sched_day == 31)
						{
							if((est_sched_mo == 4) || (est_sched_mo == 6) || (est_sched_mo == 9) || (est_sched_mo == 11))
							{
								strncpy((char *) crtdocdte_day.arr, "30",2);
							}
							else 
							{
								if(est_sched_mo == 2)
								{
									strncpy((char *) crtdocdte_day.arr, "28",2);
								}
							}
						}
						else 
						{
							if(est_sched_day >= 29)
							{
								if(est_sched_mo == 2)
								{
									strncpy((char *) crtdocdte_day.arr, "28",2);
								}
							}
						}
						/* Takes the est schedule month converts it into a string (without converting 
						the actual est_sched_mo variable) and stores it in the est_sched_date
						variable. The num variable returns the len of the est_sched_date string. */
						if(est_sched_mo < 10)
						{
							num = sprintf((char*)est_sched_date.arr, "%d", 0);
							num = sprintf((char*)temp_month.arr, "%d", est_sched_mo);
							strcat((char *) est_sched_date.arr, (char *) temp_month.arr);
						}
						else
						{
							num = sprintf((char*)est_sched_date.arr, "%d", est_sched_mo);
						}
						/* Converts the est_sched_day to a string and stores it in the temp_day
						variable. */
						num = sprintf((char*)temp_day.arr, "%d", est_sched_day);
						
						/* Converts the est_sched_year to a string and stores it in the temp_year
						variable. */
						num = sprintf((char*)temp_year.arr, "%d", est_sched_year);

						/* Concatenates the current value in the est_sched_date variable(should be the month) with the '/DD/' segment of the date.*/
						strcat((char *) est_sched_date.arr, "/");
						strcat((char *) est_sched_date.arr, (char*) crtdocdte_day.arr);
						strcat((char *) est_sched_date.arr, "/");

						/* Concatenates the year onto the rest of the est_sched_date */
						strcat((char *) est_sched_date.arr, (char *) temp_year.arr);
						
			}
			else
			{
				/* If neither the contract nor the Submittal date exists sets the month and year to 0 and the date to "".  (Submittal date should always exist)*/
				est_sched_mo = 0;
				est_sched_year = 0;
				strcpy((char *) est_sched_date.arr, "\0");
			}
			strcpy((char *) sched_cat.arr, "Lead Time");
			strcpy((char *) releaseType.arr, "");
		}
	}
	sched_cat.len = strlen((char *) sched_cat.arr);
	sched_cat.arr[sched_cat.len] = '\0';
	contract_date.len = strlen((char *) contract_date.arr);
	contract_date.arr[contract_date.len] = '\0';
	contract_month.len = strlen((char *) contract_month.arr);
	contract_month.arr[contract_month.len]= '\0';
	contract_year.len = strlen((char *) contract_year.arr);
	contract_year.arr[contract_year.len]= '\0';
	est_sched_date.len = strlen((char *) est_sched_date.arr);
	est_sched_date.arr[est_sched_date.len]= '\0';
	releaseType.len = strlen((char *) releaseType.arr);
	releaseType.arr[releaseType.len]= '\0';
	#if DEBUG
		printf("\nlisn ssn Exit function (%s) (%d)",lisn_ssn.arr,lisn_ssn.len);
		fflush(stdout);
	#endif
}
/*

*/
void query_cost_acct()	
{
/* Finds the cost account for the given jicc (activity id) */
		
	#if DEBUG
		printf("\nquery_cost_acct");
		fflush(stdout);
	#endif

	EXEC SQL DECLARE cost_acct CURSOR FOR
	select cost_acct
	from scm.cost_acct_info
	where ccn = substr(:jicc,1,3)||substr(:jicc,5,2)||substr(:jicc,8,3);
	
	EXEC SQL OPEN cost_acct;
	if(sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH cost_acct INTO		
		:cost_acct;
		if(sqlca.sqlcode == 0)
		{
			cost_acct.arr[cost_acct.len] = '\0';
		}
		else
		{
			strcpy((char *) cost_acct.arr, " ");
		}
	}
	else
	{
		strcpy((char *) cost_acct.arr, " ");
	}
			#if DEBUG
				printf("\nlisn ssn (%s) (%d)",lisn_ssn.arr,lisn_ssn.len);
				fflush(stdout);
			#endif
}
/*

*/
void query_vendor_name()
{
		
	#if DEBUG
		printf("\nquery_vendor_name");
/*		printf("\nVendor Name ICHS (%s) (%d)",vendor_name_ichs.arr,vendor_name_ichs.len); */
		fflush(stdout);
	#endif

	EXEC SQL DECLARE vendor_name CURSOR FOR
		select sup_name
		from scm.acdc_vendor_info
		where alt_sup_name = upper(:vendor_name_ichs);

	EXEC SQL OPEN vendor_name;
	if(sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH vendor_name INTO
		:vendor_name;
		if(sqlca.sqlcode == 0)
		{
			vendor_name.arr[vendor_name.len] ='\0';
		}
		else
		{
			#if DEBUG
				printf("\nquery_vendor_name - Select Vendor #2 ");
				printf("\nVendor Name ICHS (%s) (%d)",vendor_name_ichs.arr,vendor_name_ichs.len);
				fflush(stdout);
			#endif
			EXEC SQL DECLARE vendor_name_code CURSOR FOR
			select sup_name
			from scm.acdc_vendor_info
			where cage_code = :vendor_code
			and cage_code is not null;
			
			EXEC SQL OPEN vendor_name_code;
			if(sqlca.sqlcode == 0)
				{
					EXEC SQL FETCH vendor_name_code INTO
					:vendor_name;
				}
				
		}
	}
	else
	{
		strcpy((char *) vendor_name.arr, "\0");
	}
}
/*

*/
void query_PO_ICHS_price()
{
	
		
	#if DEBUG
		printf("\nquery_PO_ICHS_price");
		printf("\n\tJICC (%s) ",jicc.arr);
		printf("\n\tPO (%s) ",po.arr);
		printf("\n\tPO Line item (%s) ",po_line.arr);
		fflush(stdout);
	#endif


	EXEC SQL DECLARE get_PO_ICHS_price CURSOR FOR
		select nvl(ichs.commit_qty,0)-nvl(ichs.liq_qty,0) rem_qty, 
			nvl(ichs.commit_amt,0)-nvl(ichs.liq_amt,0) rem_amt,
			nvl(ichs.commit_amt,0) commit_amt, 
			nvl(ichs.commit_qty,0) commit_qty,
			nvl(liq_amt,0),
			nvl(liq_qty,0),
			nvl(vendor_name,' '),
			nvl(activity_id,' ')
		from scm.acdc_ichs_data ichs
		where  ichs.purchase_order =  :po
		and '0'||ichs.po_line_item = :po_line
		and ichs.activity_id = substr(:jicc,1,3)||substr(:jicc,5,2)||substr(:jicc,8,3)
		union all
		select nvl(ichs.commit_qty,0)-nvl(ichs.liq_qty,0) rem_qty, 
			nvl(ichs.commit_amt,0)-nvl(ichs.liq_amt,0) rem_amt, 
			nvl(ichs.commit_amt,0) commit_amt,
			nvl(ichs.commit_qty,0) commit_qty,
			nvl(liq_amt,0), nvl(liq_qty,0),
			nvl(vendor_name,' '),
			nvl(activity_id,' ')
		from scm.acdc_ichs_data ichs
		where  ichs.purchase_order =  :po
		and '0'||ichs.po_line_item = :po_line;
	
	EXEC SQL OPEN get_PO_ICHS_price;
	if(sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH get_PO_ICHS_price INTO
			:rem_qty:rem_qty_i,
			:rem_amt:rem_amt_i,
			:commit_amt,
			:commit_qty,
			:liq_amt,
			:liq_qty,
			:vendor_name_ichs,
			:activity_id;
		
		if(sqlca.sqlcode == 0)
		{
			memset((char *) pc_release_date.arr,' ',10);
			strncpy((char *) pc_release_date.arr,"          ",10);
			pc_release_date.arr[pc_release_date.len]='\0';
			pc_release_date.len=10;

			#if DEBUG
				printf("\n\tFound in ICHS");
				printf("\n\t PC Release Date (%s) ",pc_release_date.arr);
				printf("\n\t Vendor Name (%s) ",vendor_name.arr);
				fflush(stdout);
			#endif

			vendor_name_ichs.arr[vendor_name_ichs.len] ='\0';

			if(commit_qty != 0)
			{

				ichs_unit_price = commit_amt/commit_qty;
			}
			if(jicc.len!=10)
			{
				memset(jicc.arr,' ',10);
				memset((char *) chk_jicc_job.arr,' ',10);
				strncpy((char *) &jicc.arr[0],(char *) &activity_id.arr[0],3);
				strncpy((char *) &chk_jicc_job.arr[0],(char *) &activity_id.arr[0],3);
				chk_jicc_job.len=3;
				set_override_job();
				strncpy((char *) &jicc.arr[4],(char *) &activity_id.arr[3],2);
				strncpy((char *) &jicc.arr[7],(char *) &activity_id.arr[5],3);
				jicc.arr[10] = '\0';
				jicc.len=strlen((char *) jicc.arr);
			}
		}
		else
		{
			if(sqlca.sqlcode==NOTFND)
			{
				ichs_unit_price = 0;
				rem_qty =0;
				rem_amt = 0;
				memset(vendor_name_ichs.arr,' ',50);
				memset((char *) pc_release_date.arr,' ',10);
/*				strncpy((char *) pc_release_date.arr,"          ",10); */
				pc_release_date.len=10;
				pc_release_date.arr[pc_release_date.len]='\0';
				query_PO_FDW_price();
			}
			else
			{
				db_err("query_PO_ICHS_price - FETCH CURSOR");
			}
		}
	}
	else
	{
		db_err("query_PO_ICHS_price - OPEN CURSOR");
		ichs_unit_price = 0;
		rem_qty =0;
		rem_amt = 100;
		strcpy((char *)vendor_name_ichs.arr, " ");
	}
		
		query_vendor_name();
}
/*

*/
void query_PO_FDW_price()
{
	#if DEBUG
		printf("\nquery_PO_FDW_price");
		printf("\n\tJICC (%s) (%d)",jicc.arr,jicc.len);
		printf("\n\tPO (%s) ",po.arr);
		printf("\n\tPO Line item (%s) ",po_line.arr);
		printf("\n\tPC Release Date (%s) ",pc_release_date.arr);
		fflush(stdout);
	#endif


	EXEC SQL DECLARE get_PO_FDW_price CURSOR FOR
		select  nwp_commit_qty nwpCQ,
			caps_commit_qty capCQ,
			(case
				 when nwp_commit_qty > 0 then
		 			  nwp_commit_qty
				 when caps_commit_qty > 0 then
				      caps_commit_qty
			 else
		      		0
	 		end) commit_qty,
			nwp_commit_amt nwpCA,
			caps_commit_amt capCA, 
			(case
		 		when nwp_commit_amt = 0 and caps_commit_amt=0 then
					0
		 		when nwp_commit_amt = caps_commit_amt then
		 	  		nwp_commit_amt
		 		when nwp_commit_amt > 0 and caps_commit_amt = 0 then
		 	  		nwp_commit_amt
		 		when nwp_commit_amt = 0 and caps_commit_amt > 0 then
		      			caps_commit_amt
		 		else
		 	 		0
	 		end) commit_amt,
			nwp_invoice_qty + caps_invoice_qty invoice_qty,	
			nwp_invoice_amt + caps_invoice_amt invoice_amt,
			(case
		 		when nwp_commit_amt = 0 and caps_commit_amt=0 then
					0
		 		when nwp_commit_amt = caps_commit_amt then
		 	  		nwp_commit_amt / nwp_commit_qty
		 		when nwp_commit_amt > 0 and caps_commit_amt = 0 then
		 	  		nwp_commit_amt / nwp_commit_qty
		 		when nwp_commit_amt = 0 and caps_commit_amt > 0 then
		      			caps_commit_amt / caps_commit_qty
		 		else
		 	 		0
	 		end) unit_cost,
			activity_id
		from scm.acdc_fdw_summed_data
			where 1=1
/*			and ((nwp_commit_qty > 0 and nwp_commit_amt > 0) 
				or (caps_commit_qty >0 and caps_commit_amt > 0)) */
			and purchase_order =  :po
			and po_line_item = :po_line
			and activity_id = substr(:jicc,1,3)||substr(:jicc,5,2)||substr(:jicc,8,3)
		union all
		select nwp_commit_qty nwpCQ,
			caps_commit_qty capCQ,
			(case
		 		when nwp_commit_amt = 0 and caps_commit_amt=0 then
					0
				 when nwp_commit_qty > 0 then
		 			  nwp_commit_qty
				 when caps_commit_qty > 0 then
				      caps_commit_qty
			 else
		      		0
	 		end) commit_qty,
			nwp_commit_amt nwpCA,
			caps_commit_amt capCA, 
			(case
		 		when nwp_commit_amt = 0 and caps_commit_amt=0 then
					0
		 		when nwp_commit_amt = caps_commit_amt then
		 	  		nwp_commit_amt
		 		when nwp_commit_amt > 0 and caps_commit_amt = 0 then
		 	  		nwp_commit_amt
		 		when nwp_commit_amt = 0 and caps_commit_amt > 0 then
		      			caps_commit_amt
		 		else
		 	 		0
	 		end) commit_amt,
			nwp_invoice_qty + caps_invoice_qty invoice_qty,	
			nwp_invoice_amt + caps_invoice_amt invoice_amt,
			(case
		 		when nwp_commit_amt = 0 and caps_commit_amt=0 then
					0
		 		when nwp_commit_amt = caps_commit_amt then
		 	  		nwp_commit_amt / nwp_commit_qty
		 		when nwp_commit_amt > 0 and caps_commit_amt = 0 then
		 	  		nwp_commit_amt / nwp_commit_qty
		 		when nwp_commit_amt = 0 and caps_commit_amt > 0 then
		      			caps_commit_amt / caps_commit_qty
		 		else
		 	 		0
	 		end) unit_cost,
			activity_id
		from scm.acdc_fdw_summed_data
			where 1=1
/*			and ((nwp_commit_qty > 0 and nwp_commit_amt > 0) 
				or (caps_commit_qty >0 and caps_commit_amt > 0)) */
			and purchase_order =  :po
			and po_line_item = :po_line;

	EXEC SQL OPEN get_PO_FDW_price;

	if(sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH get_PO_FDW_price INTO
			:nwp_commit_qty,
			:caps_commit_qty,
			:commit_qty,
			:nwp_commit_amt,
			:caps_commit_amt,
			:commit_amt,
			:liq_qty,
			:liq_amt,
			:fdw_unit_price,
			:activity_id;

		if(sqlca.sqlcode == 0)
		{


			if(commit_qty != 0)
			{

				ichs_unit_price = commit_amt/commit_qty;
				rem_amt=commit_amt-liq_amt;
				rem_qty=commit_qty-liq_qty;
			}
			if(jicc.len!=10)
			{
				memset(jicc.arr,' ',10);
				strncpy((char *) &jicc.arr[0],(char *) &activity_id.arr[0],3);
				strncpy((char *) &jicc.arr[4],(char *) &activity_id.arr[3],2);
				strncpy((char *) &jicc.arr[7],(char *) &activity_id.arr[5],3);
				jicc.arr[10] = '\0';
				jicc.len=strlen((char *) jicc.arr);
				memset(chk_jicc_job.arr,' ',10);
				strncpy((char *) &chk_jicc_job.arr[0],(char *) &activity_id.arr[0],3);
				chk_jicc_job.len=3;
				set_override_job();
			}
			#if DEBUG
				printf("\nNWP Commit Qty (%i)",nwp_commit_qty);
				printf("\nCAPS Commit Qty (%i)",caps_commit_qty);
				printf("\nCommit Qty (%i)",commit_qty);
				printf("\nNWP Commit Amt (%.2f)",nwp_commit_amt);
				printf("\nCAPS Commit Amt (%.2f)",caps_commit_amt);
				printf("\nCommit Amt (%.2f)",commit_amt);
				printf("\nInvoice Qty (%i)",liq_qty);
				printf("\nInvoice Amt (%.2f)",liq_amt);
				printf("\nUnit Cost (%.2f)",fdw_unit_price);
				printf("\nActivity ID (%s)",(char *) activity_id.arr);
				printf("\nRemain Amt (%.2f)",rem_amt);
				printf("\nRemain Qty (%i)",rem_qty);
				printf("\nJICC Length (%s)",strlen((char *) jicc.arr));
				fflush(stdout);
			#endif
			get_PO_FDW_vendor_name();
		}
		else
		{
			if(sqlca.sqlcode == NOTFND)
			{
			}
			else
			{
				printf("\nProblem with Query");
				db_err("query_PO_FDW_price - Fetch CURSOR");
			}
		}

	}
	else
	{
		printf("\n\t\tOrder Number (%s) ",(char *) order_no.arr);
		printf("\n\t\tPO (%s) PO Line Item (%s) ",(char *) po.arr,(char *) po_line.arr);
		printf("\n?\t\tSQLCODE: %d",sqlca.sqlcode);
		printf("\n?\t\tSQLERR MSG %s",sqlca.sqlerrm.sqlerrmc);
		printf("\n?");
		db_err("query_PO_FDW_price - OPEN CURSOR");
	}
}
/*

*/
void get_PO_FDW_vendor_name()
{

	#if DEBUG
		printf("\nget_PO_FDW_vendor_name");
		printf("\n\tJICC (%s) ",jicc.arr);
		printf("\n\tPO (%s) ",po.arr);
		printf("\n\tPO Line item (%s) ",po_line.arr);
		printf("\n\t PC Release Date (%s) ",pc_release_date.arr);
		fflush(stdout);
	#endif

	EXEC SQL DECLARE get_PO_FDW_vendor_name CURSOR FOR
		select distinct nvl(vendor_name,' '),
			to_char(pc_release_date,'MM/DD/YYYY'),
			nvl(price_type,' '),
			nvl(buyer_name,' ')
		from scm.acdc_fdw_dtl_data
		where purchase_order =  :po
		  and po_line_item = :po_line
		  and activity_id = substr(:jicc,1,3)||substr(:jicc,5,2)||substr(:jicc,8,3) 
		union all
		select distinct nvl(vendor_name,' '),
			to_char(pc_release_date,'MM/DD/YYYY'),
			nvl(price_type,' '),
			nvl(buyer_name,' ')
		from scm.acdc_fdw_dtl_data
		where purchase_order =  :po
		  and po_line_item = :po_line; 

	EXEC SQL OPEN get_PO_FDW_vendor_name;

	if(sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH get_PO_FDW_vendor_name INTO
			:vendor_name_ichs,
			:pc_release_date:pc_release_date_i,
			:price_type,
			:fdw_buyer;

		if(sqlca.sqlcode == 0)
		{
			#if DEBUG
				printf("\n\tData Found");
				printf("\n\t PC Release Date (%s) ",pc_release_date.arr);
				printf("\n\t Vendor Name (%s) ",vendor_name_ichs.arr);
				printf("\n\t Price Type (%s) ",price_type.arr);
				fflush(stdout);
			#endif
			vendor_name_ichs.arr[vendor_name_ichs.len] ='\0';
			pc_release_date.arr[pc_release_date.len]='\0';
			if(strncmp((char *) fdw_buyer.arr," ",1)>0)
			{
				memset(buyer.arr,' ',25);
				strncpy((char *) buyer.arr,(char *) fdw_buyer.arr,fdw_buyer.len);
			}
		}
		else
		{
			if(sqlca.sqlcode == NOTFND)
			{
				#if DEBUG
					printf("\n\tData Not Found");
					printf("\n\t PC Release Date (%s) (%d) ",pc_release_date.arr,pc_release_date.len);
					printf("\n\t Vendor Name (%s) ",vendor_name_ichs.arr);
					printf("\n\t Price Type (%s) ",price_type.arr);
					fflush(stdout);
				#endif
				memset(vendor_name_ichs.arr,' ',60);
				vendor_name.len=0;
				memset(pc_release_date.arr,' ',10);
				pc_release_date.len=0;
				memset(price_type.arr,' ',2);
				price_type.len=0;
			}
			else
			{
				printf("\nget_PO_FDW_vendor_name - Fetch Cursor");
				printf("\n?\t\tSQLCODE: %d",sqlca.sqlcode);
				printf("\n?\t\tSQLERR MSG %s",sqlca.sqlerrm.sqlerrmc);
				printf("\n?");
				db_err("query_PO_FDW_vendor_name - Fetch CURSOR");
			}
		}
	}
	else
	{
		printf("\nget_PO_FDW_vendor_name - Open Cursor");
		printf("\n?\t\tSQLCODE: %d",sqlca.sqlcode);
		printf("\n?\t\tSQLERR MSG %s",sqlca.sqlerrm.sqlerrmc);
		printf("\n?");
		db_err("query_PO_FDW_vendor_name - Open CURSOR");
	}
}

/*

*/
void query_sweep_price()
{
	varchar list_order[5];
		
	#if DEBUG
		printf("\nquery_sweep_price");
		printf("\nPart (%s) ",(char *) part.arr);
		fflush(stdout);
	#endif

	
	EXEC SQL DECLARE get_sweep_price CURSOR FOR
		select '1',
		      nvl(price,0),
		      rtrim(job)||'_SWEEP_PRICE',
		      a.fiscal_year,
		      ' '
		from scm.acdc_sweep_price a,
		      scm.acdc_contract_job b
	        where part = :part
	        and to_char(start_date,'YYYYMMDD') <= to_char(sysdate,'YYYYMMDD')
	        and a.fiscal_year = b.fiscal_year
		and a.cust_model like 'AV8%'
		and price > 0
		union all
		select '2',
			nvl(unit_price,0),
			rtrim(b.job)||'_DPS_Price',
			contract_clin,
			contract_elin
		from scm.acdc_dps_prices a,
		     scm.acdc_contract_job b
		where part = :part
		and to_char(start_date,'YYYYMMDD') <= to_char(sysdate,'YYYYMMDD')
		and contract_clin = fiscal_year
		and a.cust_model like 'AV8%'
		and unit_price > 0
		order by 1,4 desc,5 asc;
	
	EXEC SQL OPEN get_sweep_price;
	if(sqlca.sqlcode == 0 || sqlca.sqlcode == 2112)
	{
		EXEC SQL FETCH get_sweep_price INTO
			:sweep_price_type,
			:sweep_uc_price:sweep_uc_price_i,
			:best_price_source,
			:dps_contract_clin,
			:dps_contract_elin;
			
		if(sqlca.sqlcode==NOTFND)
		{
			#if DEBUG
				printf("\nNo Sweep Price Found");
				fflush(stdout);
			#endif
			sweep_uc_price = 0;
		}
		else
		{
			if(sqlca.sqlcode ==0)
			{
				memset(best_price_cat.arr,' ',40);
				strcpy((char *) best_price_cat.arr,"CATALOG PRICING");
				#if DEBUG
					printf("\nBest Price Source (%s) ",(char *) best_price_source.arr);
					printf("\nclin (%s) ",(char *) dps_contract_clin.arr);
					printf("\nelin (%s) ",(char *) dps_contract_elin.arr);
					printf("\nSweep Price ($%.2f) ",sweep_uc_price);
					fflush(stdout);
				#endif
			}
			else
			{
				db_err("query_sweep_price - fetch Cursor");
			}
		}
	}			
	else
	{
		if(sqlca.sqlcode==NOTFND)
		{
			sweep_uc_price = 0;
		}
		else
		{
			db_err("query_sweep_price - Open Cursor");
		}
	}

	ichs_unit_price=sweep_uc_price;
}
/*

*/
/*
void query_ngc_price()
{

		
	#if DEBUG
		printf("\nquery_ngc_price");
		fflush(stdout);
	#endif

	EXEC SQL DECLARE get_ngc_price CURSOR FOR
	select nvl(price,0)
	from scm.acdc_ngc_pricing
	where part = :part;

	EXEC SQL OPEN get_ngc_price;
	if(sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH get_ngc_price INTO
		:ngc_price:ngc_price_i;
		if(sqlca.sqlcode == NOTFND)
		{
			ngc_price = 0;
		}
		
	}
	else
	{
		ngc_price = 0;
	}
}
*/
/*

*/
void query_part_price()
{
	float commit_amt=0;
	int commit_qty=0;
	short commit_amt_i=0;
	short commit_qty_i=0;
	
		
	#if DEBUG
		printf("\nquery_part_price");
		fflush(stdout);
	#endif

	
	EXEC SQL DECLARE get_part_price CURSOR FOR
		select nvl(commit_amt,0), nvl(commit_qty,0)
		  from scm.acdc_ichs_data
		where part = :part and 
		      purchase_order = (select max(purchase_order) 
					from scm.acdc_ichs_data 
					where part = :part
					and not substr(activity_id,4,2) in ('08','09','15','16','22','23','24','28','29','31')
					and commit_amt > 0 and commit_qty > 0);

	EXEC SQL OPEN get_part_price;
	if(sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH get_part_price INTO
		:commit_amt:commit_amt_i,
		:commit_qty:commit_qty_i;
		if(sqlca.sqlcode == 0 && commit_qty !=0)
		{
			ichs_part_price = commit_amt/commit_qty;
			
		}
		else
		{
			ichs_part_price = 0;
		}
	}
	else
	{
		ichs_part_price = 0;
	}


}
/*

*/
void write_output()
{
		
		
	#if DEBUG
		printf("\nwrite_output *******************");
		display_record();
		printf("\nStatus (%s) (%d)",(char *) mystatus.arr,mystatus.len);
		printf("\nPrice Cat (%s)",best_price_cat.arr);
		printf("\nPrice Source (%s)",best_price_source.arr);
		fflush(stdout);
	#endif

	if(strncmp((char *) mystatus.arr,"CANCELLED",9)==0)
	{
		best_price_i=-1;
		memset(best_price_cat.arr,' ',40);
		memset(best_price_source.arr,' ',30);
		strncpy((char *) best_price_cat.arr,"CANCELLED",9);
		best_price_cat.len=9;
		strncpy((char *) best_price_source.arr,"CANCELLED",9);
		best_price_source.len=9;
	}


	fprintf(fp_out,"%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%d\t%d\t%s\t%d\t%d\t%s\t%d\t$%.2f\t$%.2f\t%s\t%s\t%s\t%s\t%s\t%s\t$%.2f\t$%.2f\t%d\t%d\t$%.2f\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t$%.2f\t$%.2f\t%s\t%s\n",jicc.arr,order_mod.arr,part.arr,MFG_cage.arr,vendor_code.arr,releaseType.arr,ims_designator_code.arr,order_no.arr,contract_date.arr,contract_year.arr,contract_month.arr,po.arr,po_line.arr,po_po_line.arr,po_po_line_part.arr,crtdocdte.arr,crtdocdte_year.arr,crtdocdte_month.arr,smrc.arr,lead_time,lead_time_days,est_sched_date.arr,est_sched_year,est_sched_mo,sched_cat.arr,qty_ordered,best_price,best_ext_price,best_price_source.arr,best_price_cat.arr,mystatus.arr,buyAuthNeed.arr,remarks.arr,user_ref2.arr,commit_amt,liq_amt,commit_qty,liq_qty,rem_amt,rem_qty,asofdate.arr,vendor_name_ichs.arr,vendor_name.arr,cost_acct.arr,lisn_ssn.arr,escalation_fromdate.arr,escalation_price,escalation_pcnt,pc_release_date.arr,price_type.arr);

	recs_output_ctr++;

	fflush(fp_out);
}
/*

*/
void delete_record()
{
	int errcode = 0;
		
	#if DEBUG
		printf("\ndelete_record");
		fflush(stdout);
	#endif

	EXEC SQL
		delete from scm.acdc_order_data_multi;
	errcode = sqlca.sqlcode;
	if(errcode != 0 && errcode != 1403)
	{
		EXEC SQL ROLLBACK;
	}
}
/*

*/
void commit()
{
	EXEC SQL COMMIT;
	
	if(sqlca.sqlcode != 0)
	{
		EXEC SQL ROLLBACK;
		db_err("commit funciton");
	}
}
/*

*/
void insert_record()
{
	int errcode = 0;
		
	#if DEBUG
		printf("\ninsert_record");
		printf("\nnoun (%s) (%d)",(char *) noun.arr,noun.len);
		printf("\nniin (%s) (%d)",(char *) niin.arr,niin.len);
		printf("\nnsn  (%s) (%d)",(char *) nsn.arr,nsn.len);
		printf("\nStatus (%s) (%d)",(char *) mystatus.arr,mystatus.len);
		printf("\nPrice Cat (%s)",best_price_cat.arr);
		printf("\nPrice Source (%s)",best_price_source.arr);
		fflush(stdout);
	#endif

	EXEC SQL alter session set nls_date_format='MM/DD/YYYY';

	/*
	if(strncmp((char *) mystatus.arr,"CANCELLED",9)==0)
	{
		best_price_i=-1;
		memset(best_price_cat.arr,' ',40);
		memset(best_price_source.arr,' ',30);
		strncpy((char *) best_price_cat.arr,"CANCELLED",9);
		best_price_cat.len=9;
		strncpy((char *) best_price_source.arr,"CANCELLED",9);
		best_price_source.len=9;
	}
	*/
	
		
	#if DEBUG
		display_record();
	#endif
	EXEC SQL INSERT INTO
	scm.acdc_order_data_multi (
		cust,
		cust_model,
		cust_cust_model, 
		system,
		jicc,
		order_mod,
		part,
		mfg_code,
		vendor_code,
		release_type,
		ims_des_code,
		order_no,
		sc,
		contract_date,
		contract_year,
		contract_month,
		po,
		po_line,
		submittal_date,
		submittal_year,
		submittal_mo,
		smr_code,
		lead_time_mo,
		lead_time_days,
		est_sched_date,
		est_year,
		est_month,
		sched_cat,
		qty,
		best_price,
		best_ext_price,
		best_price_source,
		best_price_cat,
		order_status,
		add_buy_auth,
		remarks,
		user_ref2,
		commit_amt,
		liq_amt,
		commit_qty,
		liq_qty,
		remaining_amt,
		remaining_qty,
		dwnload_vendor_name,
		best_vendor_name,
		cost_acct,
		lisn_ssn,
		part_basic,
		noun,
		nsn,
		niin,
		cog,
		buyer,
		smic,
		escalation_fromdate,
		escalation_price,
		escalation_pcnt_amt,
		po_release_date,
		price_type,
		asofdate
	)
	values (
		rtrim(:cust:cust_i),
		rtrim(:cust_model:cust_model_i),
		rtrim(:cust_cust_model:cust_model_i),
		rtrim(:cust_system:cust_system_i), 
		rtrim(:jicc:jicc_i),
		rtrim(:order_mod),
		rtrim(:part),
		rtrim(:MFG_cage),
		rtrim(:vendor_code),
		rtrim(:releaseType:releaseType_i),
		rtrim(:ims_designator_code),
		rtrim(:order_no),
		rtrim(:sc),
		rtrim(:contract_date:contract_date_i),
		rtrim(:contract_year:contract_year_i),
		rtrim(:contract_month:contract_month_i),
		rtrim(:po),
		rtrim(:po_line),
		rtrim(:crtdocdte),
		rtrim(:crtdocdte_year),
		rtrim(:crtdocdte_month),
		rtrim(:smrc),
		rtrim(:lead_time:lead_time_i),
		rtrim(:lead_time_days:lead_time_i),
		rtrim(:est_sched_date),
		rtrim(:est_sched_year),
		rtrim(:est_sched_mo),
		rtrim(:sched_cat),
		rtrim(:qty_ordered:qty_ordered_i),
		rtrim(:best_price:best_price_i),
		rtrim(:best_ext_price),
		rtrim(:best_price_source),
		rtrim(:best_price_cat),
		rtrim(:mystatus),
		rtrim(:buyAuthNeed),
		rtrim(:remarks),
		rtrim(:user_ref2),
		rtrim(:commit_amt),
		rtrim(:liq_amt),
		rtrim(:commit_qty),
		rtrim(:liq_qty),
		rtrim(:rem_amt:rem_amt_i),
		rtrim(:rem_qty:rem_qty_i),
		rtrim(:vendor_name_ichs),
		rtrim(:vendor_name),
		rtrim(:cost_acct),
		rtrim(:lisn_ssn:lisn_ssn_i),
		rtrim(:part_basic),
		rtrim(:noun),
		rtrim(:nsn),
		rtrim(:niin),
		rtrim(:cog),
		rtrim(:buyer),
		rtrim(:smic),
		rtrim(:escalation_fromdate),
		rtrim(:escalation_price),
		rtrim(:escalation_pcnt),
		rtrim(:pc_release_date:pc_release_date_i),
		rtrim(:price_type),
		sysdate	
	);
	errcode = sqlca.sqlcode;

	if(errcode == 0)
	{
		ins_output_ctr++;
		commit();
	}
	else
	{
		printf("\nError in insert.  Errorcode %d\n",sqlca.sqlcode);
		printf("\nPart (%s)", part.arr);
		printf("\nGold Order No (%s)", order_no.arr);
		display_record();
    if (errcode == -1 ) {
		  printf("\nDuplicate record skipped") ;
 		  printf("\nGold Order No (%s)", order_no.arr);
  		printf("\nGold Customer (%s)", cust.arr);
  		printf("\nGold Customer Model (%s)", cust_model.arr);
  		printf("\nGold Cust Customer Model (%s)", cust_cust_model.arr);
  		printf("\nGold System (%s)", cust_system.arr);
      show_err_info("insert_record") ;
   } else {
		  db_err("insert_record");
    }
	}
}

void show_err_info(char *procname)
{
	char msg[513];
	size_t size = sizeof(msg) ;
	size_t msg_len;

        assert(procname != NULL) ;

	printf("\n===========================================================");
	printf("\n=");
	printf("\n=\tError occurred in process %s",procname);
	printf("\n=");
	printf("\n=\tDatabase Error has Occurred:");
	sqlglm(msg,&size,&msg_len);
	msg[msg_len] = '\0';
	printf("\n=\t\t%s",msg);
	printf("\n=\t\tSQLCODE: %d",sqlca.sqlcode);
	printf("\n=\t\tSQLERR MSG %.*s",sqlca.sqlerrm.sqlerrml,sqlca.sqlerrm.sqlerrmc);
	printf("\n=");
	printf("\n===========================================================\n");


}
/*

*/
int	set_cust_model()
{
	int errcode = 0;

	#if DEBUG
		printf("\n\tset_cust_model");
		printf("\n\torder_no (%s)",(char *) order_no.arr);
		fflush(stdout);
	#endif

	memset((char *) cust.arr,' ',20);
	memset((char *) cust_model.arr,' ',20);
	memset((char *) cust_cust_model.arr,' ',41);
	memset((char *) cust_system.arr,' ',20);

	if(strncmp((char *) order_no.arr,"F18S",4)==0)
	{
		strncpy((char *) cust.arr,"NAVICP",6);
		cust.arr[6]='\0';
		cust.len=6;
		strncpy((char *) cust_model.arr,"F18",3);
		cust_model.arr[3]='\0';
		cust_model.len=3;
		strncpy((char *) processing_mdl,"F18",3);
		processing_mdl[3]='\0';
		strncpy((char *) cust_cust_model.arr,"NAVICP~F18",10);
		cust_cust_model.arr[10]='\0';
		cust_cust_model.len=10;
		strncpy((char *) cust_system.arr,"FSTACDC",7);
		cust_system.arr[7]='\0';
		cust_system.len=7;
	}
	else
	{
		if(strncmp((char *) order_no.arr,"AV8BH",5)==0)
		{
			strncpy((char *) cust.arr,"NAVICP",6);
			cust.arr[6]='\0';
			cust.len=6;
			strncpy((char *) cust_model.arr,"AV8BH",5);
			cust_model.arr[5]='\0';
			cust_model.len=5;
			strncpy((char *) processing_mdl,"AV8B",4);
			processing_mdl[4]='\0';
			strncpy((char *) cust_cust_model.arr,"NAVICP~AV8BH",12);
			cust_cust_model.arr[12]='\0';
			cust_cust_model.len=12;
			strncpy((char *) cust_system.arr,"HISSACDC",8);
			cust_system.arr[8]='\0';
			cust_system.len=8;
		}
		else
		{
			printf("\nUnable to setup Cust Model Info");
			display_record();
			exit;
		}
	}

	return(errcode);
}

/*

*/
void calculate_escalation_adjmnt()
{

	#if DEBUG
		printf("\n\tcalculate_escalation_adjmnt");
		printf("\n\tcrtdocdte (%s)",(char *) crtdocdte.arr);
		printf("\n\tBest price = %.2f\n",best_price);
		printf("\n\tVendor Code = %s\n",(char *) vendor_code.arr);
		fflush(stdout);
	#endif

	if(strncmp((char *) vendor_code.arr,"76823",5)==0)
	{
		calculate_ngc_escalation_adjmnt();
	}
	else
	{
		calculate_all_escalation_adjmnt();
	}
	#if DEBUG
		printf("\n\tcalculate_escalation_adjmnt - Exit Function");
		printf("\n\t\tEscalation Percent  = %.2f",escalation_pcnt);
		printf("\n\t\tEscalation Price  = %.2f",escalation_price);
		printf("\n\t\tEscalation FromDate  = %s",(char *) escalation_fromdate.arr);
		fflush(stdout);
	#endif

}

/*

*/
void calculate_all_escalation_adjmnt()
{

	#if DEBUG
		printf("\n\tcalculate_all_escalation_adjmnt");
		printf("\n\tcrtdocdte (%s)",(char *) crtdocdte.arr);
		printf("\n\tcrtdodte_year (%s)",(char *) crtdocdte_year.arr);
		printf("\n\tBest price = %.2f\n",best_price);
		fflush(stdout);
	#endif

	retrieve_all_escalation_adjmnt();
}

/*

*/
void retrieve_all_escalation_adjmnt()
{

	#if DEBUG
		printf("\n\tretrieve_all_escalation_adjmnt");
		printf("\n\tcrtdocdte (%s)",(char *) crtdocdte.arr);
		printf("\n\tcrtdodte_year (%s)",(char *) crtdocdte_year.arr);
		printf("\n\tBest price = %.2f\n",best_price);
		fflush(stdout);
	#endif

	strcpy((char *) stmt.arr,"select to_char(fromdate,'YYYY'),escalation_amt, to_char(sysdate,'YYYY')");
	strcat((char *) stmt.arr,"from scm.acdc_price_escalation_info ");
	strcat((char *) stmt.arr,"where 1=1");
	strcat((char *) stmt.arr,"and to_char(fromdate,'YYYY') <= to_char(to_date(rtrim('");
	strcat((char *) stmt.arr,(char *) crtdocdte.arr);
	strcat((char *) stmt.arr,"'),'MM/DD/YYYY'),'YYYY') ");
	strcat((char *) stmt.arr,"and supplier<>'76823' ");
	if(strncmp((char *) vendor_code.arr,"76823",5)==0)
	{
		strcat((char *) stmt.arr,"and to_char(todate,'YYYY')='2006' ");
	}
	else
	{
		strcat((char *) stmt.arr,"and to_char(todate,'YYYY')=to_char(sysdate,'YYYY') ");
	}
	strcat((char *) stmt.arr,"order by 1 desc ");

	stmt.len = strlen((char *) stmt.arr);

	EXEC SQL PREPARE get_all_escalation_price_stmt FROM :stmt;
	EXEC SQL DECLARE get_all_escalation_price_amt CURSOR FOR get_all_escalation_price_stmt;


	#if DEBUG
		printf("\n\tretrieve_all_escalation_adjmnt");
		printf("\n\tSQL (%s) ",stmt.arr);
		fflush(stdout);
	#endif
			
	EXEC SQL OPEN get_all_escalation_price_amt;

	memset((char *) escalation_fromdate.arr,' ',4);
	memset((char *) escalation_currdate.arr,' ',4);
	short escalation_currdate_i;
	escalation_pcnt=0;
	escalation_price=0;

	if (sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH get_all_escalation_price_amt INTO
			escalation_fromdate:escalation_fromdate_i,
			escalation_pcnt,
			escalation_currdate:escalation_currdate_i;

		if (sqlca.sqlcode == 0)
		{
			if(escalation_fromdate_i==0)
			{
				escalation_price=escalation_pcnt * best_price;
			}
			else
			{
				escalation_price=best_price;
				memset((char *) escalation_fromdate.arr,' ',4);
			}
		}
		else
		{
			if(sqlca.sqlcode == NOTFND)
			{
				escalation_pcnt=0;
				escalation_price=0;
				escalation_price=best_price;
				memset((char *) escalation_fromdate.arr,' ',4);
			}
			else
			{
				printf("\n\tSQL (%s) ",stmt.arr);
				printf("\nGold Order No (%s) ",(char *) order_no.arr);
				db_err("retrieve_all_escalation_adjmnt - Fetch Cursor");
				exit;
			}
		}
	}
	else
	{
		printf("\n\tSQL (%s) ",stmt.arr);
		printf("\nGold Order No (%s) ",(char *) order_no.arr);
		db_err("retrieve_all_escalation_adjmnt - Open Cursor");
		exit;
	}

	#if DEBUG
		printf("\n\t\tBest price = %.2f",best_price);
		printf("\n\t\tEscalation Percent  = %.2f",escalation_pcnt);
		printf("\n\t\tEscalation Price  = %.2f",escalation_price);
		printf("\n\t\tEscalation FromDate  = %s",(char *) escalation_fromdate.arr);
		fflush(stdout);
	#endif
}

/*

*/
void calculate_ngc_escalation_adjmnt()
{

	#if DEBUG
		printf("\n\tcalculate_ngc_escalation_adjmnt");
		printf("\n\tcrtdocdte (%s)",(char *) crtdocdte.arr);
		printf("\n\tcrtdodte_year (%s)",(char *) crtdocdte_year.arr);
		printf("\n\tBest price = %.2f",best_price);
		printf("\n\tValue of crtdocdte_year Compare %i",strncmp((char *) crtdocdte_year.arr,"2006",4));
		fflush(stdout);
	#endif

	if(strncmp((char *) crtdocdte_year.arr,"2006",4) < 0)
	{
		escalation_temp_price=0;
		retrieve_all_escalation_adjmnt();
		escalation_temp_price=escalation_price;
		escalation_price=0;
		retrieve_ngc_escalation_adjmnt();
	}
	else
	{
		escalation_temp_price=best_price;
		retrieve_ngc_escalation_adjmnt();
	}

}

/*

*/
void retrieve_ngc_escalation_adjmnt()
{

	#if DEBUG
		printf("\n\tretrieve_ngc_escalation_adjmnt");
		printf("\n\tcrtdocdte (%s)",(char *) crtdocdte.arr);
		printf("\n\tcrtdodte_year (%s)",(char *) crtdocdte_year.arr);
		printf("\n\tEscalation Temp Price = %.2f\n",escalation_temp_price);
		fflush(stdout);
	#endif

	memset((char *) stmt.arr, ' ', 5000);

	strcpy((char *) stmt.arr,"select to_char(fromdate,'YYYY'),escalation_amt, to_char(sysdate,'YYYY')");
	strcat((char *) stmt.arr,"from scm.acdc_price_escalation_info ");
	strcat((char *) stmt.arr,"where 1=1");
	if(strncmp((char *) vendor_code.arr,"76823",5)==0)
	{
		strcat((char *) stmt.arr,"and supplier='76823' ");
	}
	if(strncmp((char *) crtdocdte_year.arr,"2006",4) < 0)
	{
		strcat((char *) stmt.arr,"and to_char(fromdate,'YYYY') ='2006'");
	}
	else
	{
		strcat((char *) stmt.arr,"and to_char(fromdate,'YYYY') <= to_char(to_date(rtrim('");
		strcat((char *) stmt.arr,(char *) crtdocdte.arr);
		strcat((char *) stmt.arr,"'),'MM/DD/YYYY'),'YYYY') ");
	}
	strcat((char *) stmt.arr,"and to_char(todate,'YYYY')=to_char(sysdate,'YYYY') ");
	strcat((char *) stmt.arr,"order by 1 desc ");

	stmt.len = strlen((char *) stmt.arr);

	EXEC SQL PREPARE get_ngc_escalation_price_stmt FROM :stmt;
	EXEC SQL DECLARE get_ngc_escalation_price_amt CURSOR FOR get_ngc_escalation_price_stmt;


	#if DEBUG
		printf("\n\tretrieve_ngc_escalation_adjmnt");
		printf("\n\tSQL (%s) ",stmt.arr);
		fflush(stdout);
	#endif
			
	EXEC SQL OPEN get_ngc_escalation_price_amt;

	memset((char *) escalation_fromdate.arr,' ',4);
	escalation_pcnt=0;
	escalation_price=0;

	if (sqlca.sqlcode == 0)
	{
		EXEC SQL FETCH get_ngc_escalation_price_amt INTO
			escalation_fromdate:escalation_fromdate_i,
			escalation_pcnt,
			escalation_currdate;

		if (sqlca.sqlcode == 0)
		{
			if(escalation_fromdate_i==0)
			{
				escalation_price=escalation_pcnt * escalation_temp_price;
			}
			else
			{
				escalation_price=escalation_temp_price;
				memset((char *) escalation_fromdate.arr,' ',4);
				memset((char *) escalation_currdate.arr,' ',4);
			}
		}
		else
		{
			if(sqlca.sqlcode == NOTFND)
			{
				escalation_pcnt=0;
				escalation_price=0;
				escalation_price=escalation_temp_price;
				memset((char *) escalation_fromdate.arr,' ',4);
				memset((char *) escalation_currdate.arr,' ',4);
			}
			else
			{
				printf("\n\tSQL (%s) ",stmt.arr);
				printf("\nGold Order No (%s) ",(char *) order_no.arr);
				db_err("retrieve_ngc_escalation_adjmnt - Fetch Cursor");
				exit;
			}
		}
	}
	else
	{
		printf("\n\tSQL (%s) ",stmt.arr);
		printf("\nGold Order No (%s) ",(char *) order_no.arr);
		db_err("retrieve_ngc_escalation_adjmnt - Open Cursor");
		exit;
	}

	#if DEBUG
		printf("\n\tretrieve_ngc_escalation_adjmnt - Exit Function");
		printf("\n\t\tEscalation Temp Price  = %.2f",escalation_temp_price);
		printf("\n\t\tEscalation Percent  = %.2f",escalation_pcnt);
		printf("\n\t\tEscalation Price  = %.2f",escalation_price);
		printf("\n\t\tEscalation FromDate  = %s",(char *) escalation_fromdate.arr);
		fflush(stdout);
	#endif
}

/*

*/
void display_record()
{

	#if DEBUG
		printf("\nwrite_output");
		printf("\n\tCUST (%s) (%d) ",cust.arr,cust.len);
		printf("\n\tCUST MODEL (%s) (%d) ",cust_model.arr,cust_model.len);
		printf("\n\tCUST CUST MODEL (%s) (%d) ",cust_cust_model.arr,cust_cust_model.len);
		printf("\n\tSYSTEM (%s) (%d) ",cust_system.arr,cust_system.len);
		printf("\n\tJICC (%s) (%d) ",jicc.arr,jicc.len);
		printf("\n\tOrder Mod (%s) (%d) ",order_mod.arr,order_mod.len);
		printf("\n\tPart (%s) (%d)",part.arr,part.len);
		printf("\n\tCage (%s) (%d)",MFG_cage.arr,MFG_cage.len);
		printf("\n\tVendor (%s) (%d)",vendor_code.arr,vendor_code.len);
		printf("\n\tRelease Type (%s) (%d)",releaseType.arr,releaseType.len);
		printf("\n\tIMS Designator (%s) (%d)",ims_designator_code.arr,ims_designator_code.len);
		printf("\n\tOrder No (%s) (%d)",order_no.arr,order_no.len);
		printf("\n\tContract date (%s) (%d)",contract_date.arr,contract_date.len);
		printf("\n\tContract Year (%s) (%d)",contract_year.arr,contract_year.len);
		printf("\n\tContract Month (%s) (%d)",contract_month.arr,contract_month.len);
		printf("\n\tPO (%s) (%d)",po.arr,po.len);
		printf("\n\tPO Line (%s) (%d)",po_line.arr,po_line.len);
		printf("\n\tPO PO Line (%s) (%d)",po_po_line.arr,po_po_line.len);
		printf("\n\tPO PO Line Part (%s) (%d)",po_po_line_part.arr,po_po_line_part.len);
		printf("\n\tCreate Date (%s) (%d)",crtdocdte.arr,crtdocdte.len);
		printf("\n\tCreate Year (%s) (%d)",crtdocdte_year.arr,crtdocdte_year.len);
		printf("\n\tCreate Month (%s) (%d)",crtdocdte_month.arr,crtdocdte_month.len);
		printf("\n\tSMRC (%s) (%d)",smrc.arr,smrc.len);
		printf("\n\tLead Time (%d)",lead_time);
		printf("\n\tLead Time Days (%d)",lead_time_days);
		printf("\n\tEst Sched Date (%s) (%d)",est_sched_date.arr,est_sched_date.len);
		printf("\n\tEst Sched Year (%d)",est_sched_year);
		printf("\n\tEst Sched Month (%d)",est_sched_mo);
		printf("\n\tSched Cat (%s) (%d)",sched_cat.arr,sched_cat.len);
		printf("\n\tQty Ordered (%d)",qty_ordered);
		printf("\n\tBest Price ($%.2f) ",best_price);
		printf("\n\tBest Price Extended ($%.2f) ",best_ext_price);
		printf("\n\tBest Price Source (%s) (%d)",best_price_source.arr,best_price_source.len);
		printf("\n\tBest Price Cat (%s) (%d)",best_price_cat.arr,best_price_cat.len);
		printf("\n\tStatus (%s) (%d)",mystatus.arr,mystatus.len);
		printf("\n\tBuy Auth Need (%s) (%d)",buyAuthNeed.arr,buyAuthNeed.len);
		printf("\n\tBuyer (%s) (%d)",(char *) buyer.arr,buyer.len);
		printf("\n\tRemarks (%s) (%d)",remarks.arr,remarks.len);
		printf("\n\tUser Ref2 (%s) (%d)",user_ref2.arr,user_ref2.len);
		printf("\n\tCommit Amount ($%.2f) ",commit_amt);
		printf("\n\tLiquid Amount ($%.2f) ",liq_amt);
		printf("\n\tCommit Qty (%d) ",commit_qty);
		printf("\n\tLiquid Amount (%d) ",liq_qty);
		printf("\n\tRemain Amount ($%.2f) ",rem_amt);
		printf("\n\tRemain Qty (%d) ",rem_qty);
		printf("\n\tAs Of Date (%s) (%d)",asofdate.arr,asofdate.len); 
		printf("\n\tVendor Name ICHS (%s) (%d)",vendor_name_ichs.arr,vendor_name_ichs.len);
		printf("\n\tVendor Name (%s) (%d)",vendor_name.arr,vendor_name.len);
		printf("\n\tCost Acct (%s) (%d)",cost_acct.arr,cost_acct.len);
		printf("\n\tLISN SSN (%s) (%d) ",lisn_ssn.arr,lisn_ssn.len);
		printf("\n\tEscalation Percent  = %.2f ",escalation_pcnt);
		printf("\n\tEscalation Price  = %.2f ",escalation_price);
		printf("\n\tEscalation FromDate  = (%s) (%d) ",(char *) escalation_fromdate.arr,escalation_fromdate.len);
		printf("\n\tPC Release Date = (%s) (%d) ",(char *) pc_release_date.arr,pc_release_date.len);
		printf("\n\tPrice Type = (%s) (%d) ",(char *) price_type.arr,price_type.len);
		fflush(stdout);
	#endif
}
