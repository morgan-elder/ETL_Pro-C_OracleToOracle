/*     Program -  Proof/SLIC HA Table Update Program */

/*
 **************************************************************************
 *  PROGRAM NAME: 
 *
 *  PURPOSE: This application pulls from SLIC/PROOF those items that are 
 *          candidates for moving to the IMS PROOF Data Base in SAMS.  This
 *          is the main program.  It runs for F-18, F-15 and T45.  Determination
 *          of which Program is being run is based upon a parmeter being passed.
 *          If the selected Part Number/Cage does not have the
 *          PROOF_TRANSFR_FLAG set to "Y" on the HAX, then it will be set.
 *        
 *
 *  INPUTS:
 *	    1.  Input Program Code (F18/F15/T45)
 *	    2.  Output Dataset Name for Extract Data
 *          3.  Output Dataset Name for Program Counts
 *           
 *
 *  OUTPUTS: 
 *	    1.  Output Extract Data
 *          2.  Output Program Counts
 *           
 *
 *  CHANGE HISTORY:
 *   REV     DATE     Programmer                 CHANGE
 *   ---  --------    ----------------------     ------
 *    00  5/27/1996   Original Author                Initial coding 
 *    01  1/23/1998   Original Author                Added F15 SLIC/PROOF
 *    02  6/11/1998   Original Author                Added AV8 SLIC/PROOF
 *    03  9/21/1998   Original Author                Added Harpoon SLIC/PROOF
 *    04  10/14/2003  Contributor             Removed check of COG and MANUF CODE
 *    05  11/11/2014  Douglas Elder              commented out the cog & mat nsn
 *
 **************************************************************************
 **************************************************************************
 * $Original Author
 * $Locker: m181203 $                                                             
 ************************************************************************** 
*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <time.h>

#ifdef __linux__
#include <unistd.h>
#endif

#ifdef _WIN32
#include "XGetopt.h"
#include <direct.h> /* _getcwd */
#endif



#include "btch18slpf_struct.h"
#include "btch18slpf.h"

FILE *outfp;

struct cnt_rcd {
	char	processed_mdl[10];
	char	filler1;
	char	process_cnt[9];
	char	filler2;
	char	process_date[19];
	char	nline;
	};

/* #define SQLCA_STORAGE_CLASS extern */

#define NOT_FND 1403
#define FND 0


EXEC SQL BEGIN DECLARE SECTION;

/*      Oracle User Sign-on Area   */
	varchar	UIDS[21];
	varchar	PWDS[21];
	varchar SID[30];


EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE SQLCA;

/*      Global Variables   */
char	output_filename[100];
char	count_filename[100];
char	model[11];
short	model_i;


/*	Time variables   */

static time_t	tnow;
static struct tm *tmstruct;

/*       Record Counts      */
static int	rcds_created=0;
static int	rcds_written=0;
static char	outData[500];
static struct config_rcd CONFIG_RCD;
static char userid[30];
static char password[30];
static 	char cwd[256]; // current working directory


int main(int argc, char **argv)
{

	FILE	*fp_cntrcd;
	
	struct	cntrl_rcd CNTRL_RCD;
	struct	cnt_rcd CNT_RCD;
	int	errcode=0;
	int	numrecs=0;
	char	pgmtime[21];
	getCurrentWorkingDirectory();
	getConfig(&CONFIG_RCD);
	if (strlen(CONFIG_RCD.output_file) > 0) {
		strcpy(output_filename,CONFIG_RCD.output_file);
    }
	if (strlen(CONFIG_RCD.count_file) > 0) {
		strcpy(count_filename,CONFIG_RCD.count_file);
	}
	sprintf(model,"%-10s",CONFIG_RCD.model);
	time(&tnow);
	tmstruct=localtime(&tnow);
	strftime(pgmtime,sizeof(pgmtime),"%m/%d/%Y-%H:%M:%S",tmstruct);
	printf("\n\n**************************************************************************");
    printf("\n%s compiled on %s at %s\n", __FILE__, __DATE__, __TIME__) ;

	printf("\nStarting Time (%s)\n",&pgmtime);

	errcode=btchslpf_signon(); 
	if (errcode == FND)
	{
		errcode=get_btchsp_argmnt(argc, argv, &CNTRL_RCD); 
		if (errcode == FND)
		{
			printf("\n\tProcessing Model\t(%s)",model);
			strncpy(CNT_RCD.processed_mdl,model,10);
			printf("\n\tOutput Data File\t(%s)",output_filename);
			printf("\n\tOutput Count File\t(%s)",count_filename);
#ifdef DEBUG
			showConfig();
#endif
			CNTRL_RCD.built_01='N';
			CNTRL_RCD.built_04='Y';
			CNTRL_RCD.built_05='Y';
			CNTRL_RCD.built_08='N';
			CNTRL_RCD.rcds_created=0;
	 		if (strcmp(model,"F18       ") == 0)
			{
				printf("\nentering Qualify");
				errcode=qualify_f18_proof_candidates((char *) &output_filename, &CNTRL_RCD);
			}
			else
			{
				printf("\n*********************************");
				printf("\n\t\tUnidentified input model (%s)",model);
				printf("\n\t\tLength of Model (%d)",strlen(model));
				printf("\n*********************************");
				errcode=100;
			}
		}
		else
		{
			printf("\n\t\tNo processing.\n");
			printf("\n\t\tUnable to prcess input");
			errcode=101;
		}
	}
	else
	{
		printf("\n\t\tUnable to Connect to Oracle\n");
		btchslpf_dberr();
	}

	printf("\n\tNumber of records Created\t%d",rcds_created);
	printf("\n\tNumber of records Written\t%d",rcds_written);

	if (errcode == FND)
	{
		printf("\n\tWork Committed");
		EXEC SQL COMMIT WORK RELEASE;
	}
	else
	{
		printf("\n\tWork not Committed - Errcode (%d)",errcode);
		EXEC SQL ROLLBACK WORK RELEASE;
	}

	time(&tnow);
	tmstruct=localtime(&tnow);
	strftime(pgmtime,sizeof(pgmtime),"%m/%d/%Y-%H:%M:%S",tmstruct);
/*	sprintf(CNT_RCD.process_cnt,"%09d",rcds_created); */
	sprintf(CNT_RCD.process_cnt,"%09d",rcds_written);
	strncpy(CNT_RCD.process_date,pgmtime,strlen(pgmtime));
	CNT_RCD.filler1=' ';
	CNT_RCD.filler2=' ';
	CNT_RCD.nline='\n';
	
	fp_cntrcd=(fopen(count_filename,"w"));
	
	numrecs=fwrite(&CNT_RCD,sizeof(CNT_RCD),1,fp_cntrcd);
	if (numrecs >0)
	{
	}
	else
	{
		printf("\nError Writing Number Record File");
	}
		
	printf("\nEnding Time (%s)\n",&pgmtime);

	exit(errcode);
}
static int	get_btchsp_argmnt(int argc, char **argv,struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;
	char opt;
	char	spaces[]={"                                       "};
	while ((opt=getopt (argc, argv,"a:b:c:A:B:C:")) !=EOF)
	{	
		switch (opt)
		{
			case 'a':
	                case 'A':		
				strncpy(output_filename,spaces,100);
				strncpy(output_filename,optarg,strlen(optarg));
				strncat(output_filename,spaces,100-strlen(output_filename));
				output_filename[strlen(optarg)]='\0'; 
				break;		
			case 'b':
	                case 'B':		
				strncpy(count_filename,spaces,100);
				strncpy(count_filename,optarg,strlen(optarg));
				strncat(count_filename,spaces,100-strlen(count_filename));
				count_filename[strlen(optarg)]='\0'; 
			case 'c':
	                case 'C':		
				strncpy(model,spaces,10);
				strncpy(model,optarg,10);
				strncat(model,spaces,10-strlen(model));
				strncpy(CNTRL_RCD->mdl_acft_prf,model,10);
				model[11]='\0';
				break;
			case '?':
				errcode=12;
				break;
		}
	}	
	return(errcode);
}
static int	btchslpf_signon(void)
{
	int	errcode=0;

	#if DEBUG
		printf("\nsignon");
	#endif
	strcpy((char *) SID.arr,CONFIG_RCD.host);
	SID.len = (unsigned short) strlen(CONFIG_RCD.host);
	strcpy((char *) UIDS.arr,CONFIG_RCD.userid);
	UIDS.len= (unsigned short) strlen((char *) UIDS.arr);
	strcpy((char *) PWDS.arr,CONFIG_RCD.password);
	PWDS.len = (unsigned short) strlen((char *) PWDS.arr);


	#if DEBUG
		printf("\nsignon");
		printf("\n (%s) (%d)",UIDS.arr,UIDS.len);
		printf("\n (%s) (%d)\n",PWDS.arr,PWDS.len);
	#endif

	EXEC SQL CONNECT :UIDS IDENTIFIED BY :PWDS USING :SID;
	
	#if DEBUG
		printf("\nExit signon");
	#endif

	return(sqlca.sqlcode);
}
static void	btchslpf_dberr()
{
	char msg_buf[201];
	size_t  buf_size=sizeof(200);
	size_t  msg_len;
    memset(msg_buf,'\0',sizeof(msg_buf));
	#if DEBUG
		printf("\nbtchslpf_dberr");
	#endif

	sqlglm(msg_buf, &buf_size, &msg_len);
	sqlglm(msg_buf, &buf_size, &msg_len);
	msg_buf[msg_len]='\0';
	
	printf("\n\nData Base Error has occurred:\n");
	printf("\n%70s\n",msg_buf);
	printf("SQLCODE: %d\n",sqlca.sqlcode);
	printf("SQLERR MSG %s\n",sqlca.sqlerrm.sqlerrmc);
	
	EXEC SQL ROLLBACK RELEASE;
	return;
}
/*
 **************************************************************************
 *  PROGRAM NAME: btchsp18sel.pc
 *
 *  PURPOSE: This application qualifies the PROOF Information being processed
 *          against the 1388 Tables.  
 *
 *  INPUTS:   N/A
 *            
 *           
 *
 *  OUTPUTS:  N/A 
 *            
 *           
 *
 *  CHANGE HISTORY:
 *   REV     DATE    Programmer                 CHANGE
 *   ---  --------   ----------------------     ------
 *    00  05/24/1996 Original Author                Initial coding
 *    01  04/02/1998 Original Author                Added Multiple EIAC Capability 
 *    02  08/13/1998 Original Author                Converted Program to use SLIC
 *   						Tailor Tables.
 *
 **************************************************************************
*/

EXEC SQL BEGIN DECLARE SECTION;

/*	PROOF HOST VARIABLES   */

	varchar	refnumha[33];
	varchar	cagecdxh[6];
	varchar	eiacodxa[11];
	varchar	prev_eiacodxa[11];
	varchar	hg_lsaconxb[19];
	varchar	hg_altlcnxb[3];
	int	num_eff;
	short	num_eff_i;
	
/*	1388 HAX Table Host Variables */

	char	proof_transfer_flag;
	short	proof_transfer_i;

/*	SLIC Extension HA Table       */

	char	ha_cog_pos1;
	
/*	SLIC Extension HBX Table   */

	varchar	hbx_refnumha[33];
	varchar	hbx_cagecdxh[6];
	varchar	hbx_addrefhb[33];
	varchar	hbx_adcagehb[6];
			

/*	1388 HG Table Host variables */


	varchar	hg_eiacodxa[11];
	varchar	lsaconxb[19];
	varchar	altlcnxb[3];
	varchar	qtypeihg[6];
	short	qtypeihg_i;
	varchar	itmcathg[3];
	short	itmcathg_i;
	char	smrcodhg_pos1;
	short	smrcodhg_pos1_i;

/*      HGX Extension Table Host Variables */

	varchar	hgx_refnumha[33];
	varchar	hgx_cagecdxh[6];
	varchar	hgx_suplyrcd[6];
	short	hgx_suplyrcd_i;
	varchar	hgx_nharefno[33];
	short	hgx_nharefno_i;
	varchar	hgx_nhacgecd[6];
	short	hgx_nhacgecd_i;

/*      SAMS PROOF Table 34 Host Variables */
	varchar	mdl_acft_prf[10];
	varchar cn[2];
	varchar prev_cn[2];
	
EXEC SQL END DECLARE SECTION;

int	qualify_f18_proof_candidates(char *filename,struct cntrl_rcd *CNTRL_RCD) 

{
	struct	prtsc01 SEGMNT01;
	struct	prtsc02 SEGMNT02;
	struct	prtsc03 SEGMNT03;
	struct	prtsc04 SEGMNT04;
	struct	prtsc05 SEGMNT05;
	struct	prtsc08 SEGMNT08;

	int	errcode=0;
	char	spaces[]="                                        ";
	

	#if DEBUG
		printf("\nqualify_f18_proof_candidates");
	#endif
	
	CNTRL_RCD->built_01='N';
	CNTRL_RCD->built_04='Y';
	CNTRL_RCD->built_05='Y';
	CNTRL_RCD->valid_application='N';
	strncpy(CNTRL_RCD->mdl_acft_prf,spaces,10);
	strncpy(CNTRL_RCD->cn,spaces,2);
	strncpy(CNTRL_RCD->ha_eiac,spaces,10);
	strncpy(CNTRL_RCD->ha_ref_no,spaces,32);
	strncpy(CNTRL_RCD->ha_cage_code,spaces,5);
	strncpy(CNTRL_RCD->hb_ref_no,spaces,32);
	strncpy(CNTRL_RCD->hb_cage_code,spaces,5);
	strncpy((char *) prev_cn.arr,spaces,2);

/*  Setup Oracle Host variables   */


	if ((outfp=fopen(filename,"w")) == NULL)
	{
		printf("\nCould not open Output file %s",filename);
		errcode=500;
	}
	else
	{
		strncpy(CNTRL_RCD->ha_hb_code,"HA",2);
		errcode=fetch_f18_proof_HA_candidates(CNTRL_RCD,&SEGMNT01,&SEGMNT02,&SEGMNT03,&SEGMNT04,&SEGMNT05,&SEGMNT08); 
		if (errcode==0)
		{
			strncpy(CNTRL_RCD->ha_hb_code,"HB",2);
			errcode=select_f18_proof_HB_candidates(CNTRL_RCD,&SEGMNT01,&SEGMNT02,&SEGMNT03,&SEGMNT04,&SEGMNT05,&SEGMNT08);
		}
	}

	return(errcode);		
}

EXEC SQL DECLARE selct_f18_HA_candidate_info_csr CURSOR for 
    select distinct slic_hg.refnumha,
    	   slic_hg.cagecdxh,
    	   slic_hg.eiacodxa,
    	   slic_hg.lsaconxb,
    	   slic_hg.altlcnxb,
	   slic_hg.qtypeihg,
	   slic_hg.itmcathg,
	   substr(slic_hg.smrcodhg,1,1),
	   substr(slic_ha.cognsnha,1,2),
	   intrfce.proof_transfer_flag
       from slic2b20.f18_ha slic_ha,
	    slic2b20.F18_XAX01 XAX01,
	    prov.f18_intrfce_ext intrfce,
	    slic2b20.f18_hg slic_hg
        where
	      slic_hg.can_int = 0
	  and slic_hg.lcntypxb = 'P'
	  and slic_hg.refnumha = slic_ha.refnumha
          and slic_hg.cagecdxh = slic_ha.cagecdxh
          and slic_hg.can_int  = slic_ha.can_int
          and rtrim(slic_ha.refnumha) = intrfce.ref_no
	  and slic_ha.cagecdxh = intrfce.cage_code
	  and intrfce.ha_hb_ind = 'HA'
	  and slic_hg.itmcathg > ' '
	  and exists (select *
			from slic2b20.f18_xax01 axa01,
			     prov.ms2_sliceiac ms2_sliceiac
			  where
          		     	    slic_hg.can_int = xax01.can_int
				and rtrim(xax01.xaxprovmdl) = ms2_sliceiac.eiac
	  			and xax01.eiacodxa = slic_hg.eiacodxa)
          order by 1,2;

int     fetch_f18_proof_HA_candidates(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02,struct prtsc03 *SEGMNT03,struct prtsc04 *SEGMNT04,struct prtsc05 *SEGMNT05,struct prtsc08 *SEGMNT08)

{
	
	int	errcode=0;
	int     fetched_row=0;
	int	fetched_ctr=0;
	char    spaces[]={"                                        "};
	/*char	*Leftstr();*/
	
	#if DEBUG
		printf("\nfetch_f18_proof_HA_candidates");
	#endif

	EXEC SQL OPEN selct_f18_HA_candidate_info_csr;
	
	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			errcode=initlze_segmnt08_host_var();
			EXEC SQL FETCH selct_f18_HA_candidate_info_csr
			   INTO :hgx_refnumha,
				:hgx_cagecdxh,
				:hg_eiacodxa,
				:lsaconxb,
			   	:altlcnxb,
		   		:qtypeihg:qtypeihg_i,
				:itmcathg:itmcathg_i,
				:smrcodhg_pos1:smrcodhg_pos1_i,
				:ha_cog_pos1,
				:proof_transfer_flag:proof_transfer_i;
			
			if (sqlca.sqlcode == FND)
			{
				errcode=check_f18_cntrl(CNTRL_RCD);
				if (errcode == 0)
				{
					strncpy(SEGMNT03->hg_icc,spaces,2);
					strncpy(SEGMNT03->hg_icc,(char *) itmcathg.arr,itmcathg.len);
					
					strncpy(CNTRL_RCD->ha_eiac,(char *) hg_eiacodxa.arr,hg_eiacodxa.len);
					strncpy(CNTRL_RCD->ha_ref_no,(char *) hgx_refnumha.arr,hgx_refnumha.len);
					strncpy(CNTRL_RCD->ha_cage_code,(char *) hgx_cagecdxh.arr,hgx_cagecdxh.len);
					
					strncpy((char *) refnumha.arr,CNTRL_RCD->ha_ref_no,32);
					refnumha.arr[32]='\0';
					refnumha.len = (unsigned short) strlen((char *) refnumha.arr);
					strncpy((char *) cagecdxh.arr,CNTRL_RCD->ha_cage_code,5);
					cagecdxh.len=5;
					cagecdxh.arr[5]='\0';
					strncpy((char *) eiacodxa.arr,(char *) hg_eiacodxa.arr,hg_eiacodxa.len);
					eiacodxa.arr[10]='\0';
					eiacodxa.len=10;
					strncpy(CNTRL_RCD->hg_lcn,(char *) lsaconxb.arr,lsaconxb.len);
					strncpy(CNTRL_RCD->hg_alc,(char *) altlcnxb.arr,altlcnxb.len);
					errcode=validate_f18_hg_rcd(CNTRL_RCD);
					if (CNTRL_RCD->valid_application == 'Y')
					{
						errcode=validate_f18_lcn(CNTRL_RCD);
					}
					if (CNTRL_RCD->valid_application == 'Y')
					{
						errcode=get_f18_hgx_data(CNTRL_RCD);
					}
					if (CNTRL_RCD->valid_application == 'Y')
					{
						fetched_ctr++;
						if (strncmp((char *) prev_eiacodxa.arr,(char *) eiacodxa.arr,10)==0)
						{
						}
						else
						{
							errcode=get_customer_model(CNTRL_RCD);
							strncpy((char *) prev_eiacodxa.arr,"          ",10);
							strncpy((char *) prev_eiacodxa.arr,(char *) eiacodxa.arr,eiacodxa.len);
						}
						if (errcode==0)
						{
							errcode=gather_f18_proof_data(CNTRL_RCD,SEGMNT01,SEGMNT02,SEGMNT03,SEGMNT04,SEGMNT05,SEGMNT08);
							if(errcode==0) 
							{
							}
							else
							{
								fetched_row=1;
							}
						}
						else
						{
							fetched_row=1;
						}
					}
				}
				else
				{
				}
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
					if(fetched_ctr>0)
					{
					}
					else
					{
						CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
						errcode=1011;
					}
				}
				else
				{
					printf("\nfetch_proof_HA_candidates");
					printf("\n\tBad SQLCODE on Fetch of Cursor");
					printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
					printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
					printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
					printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
					printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
					printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
					printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					01000;
					btchslpf_dberr();
				}
			}			   	
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			printf("\nfetch_proof_HA_candidates");
			printf("\n\tUnable to locate information on Initial Select");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1001;
		}
		else
		{
			printf("\nfetch_proof_HA_candidates");
			printf("\n\tBad SQLCODE on Open of Cursor");
			btchslpf_dberr();
			errcode=1002;
		}
	}		
			
	EXEC SQL CLOSE selct_f18_HA_candidate_info_csr;
	return(errcode);
}

EXEC SQL DECLARE selct_f18_HB_candidate_info_csr CURSOR for 
    select distinct slic_hb.refnumhb,
    	   slic_hb.cagecdhb,
    	   slic_hb.addrefhb,
    	   slic_hb.adcagehb,
    	   intrfce.proof_transfer_flag
    	 from prov.f18_intrfce_ext intrfce,
	      slic2b20.f18_hb slic_hb
        where
          intrfce.proof_transfer_flag = 'Y'
	  and rtrim(slic_hb.addrefhb) = intrfce.ref_no
	  and slic_hb.adcagehb = intrfce.cage_code
	  and intrfce.ha_hb_ind = 'HB'
	  and slic_hb.can_int = '0'
             order by 1,2;

int     select_f18_proof_HB_candidates(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02,struct prtsc03 *SEGMNT03,struct prtsc04 *SEGMNT04,struct prtsc05 *SEGMNT05,struct prtsc08 *SEGMNT08)

{
	int	errcode=0;
	int     fetched_row=0;
	int	fetched_ctr=0;
		char    spaces[]={"                                        "};


	#if DEBUG
		printf("\nselect_f18_proof_HB_candidates");
	#endif
	
	CNTRL_RCD->built_01='N';
	CNTRL_RCD->built_04='Y';
	CNTRL_RCD->built_05='Y';
	CNTRL_RCD->valid_application='N';
	
	EXEC SQL OPEN selct_f18_HB_candidate_info_csr;
	
	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			errcode=initlze_segmnt08_host_var();
			EXEC SQL FETCH selct_f18_HB_candidate_info_csr
			   INTO :hbx_refnumha,
				:hbx_cagecdxh,
				:hbx_addrefhb,
				:hbx_adcagehb,
				:proof_transfer_flag:proof_transfer_i;

			if (sqlca.sqlcode == FND)
			{
				errcode=check_f18_hb_cntrl(CNTRL_RCD);
				if (errcode == 0)
				{
					#if DEBUG
						printf("\naddrefhb (%s)",(char *) hbx_addrefhb.arr);
						printf("\nadcagehb (%s)",(char *) hbx_adcagehb.arr);
						printf("\nrefnumha (%s)",(char *) hbx_refnumha.arr);
						printf("\ncagecdxh (%s)",(char *) hbx_cagecdxh.arr);
					#endif
					strncpy(CNTRL_RCD->ha_ref_no,spaces,32);
					strncpy(CNTRL_RCD->ha_cage_code,spaces,5);
					strncpy(CNTRL_RCD->hb_ref_no,spaces,32);
					strncpy(CNTRL_RCD->hb_cage_code,spaces,5);
					strncpy(CNTRL_RCD->hb_ref_no,(char *) hbx_addrefhb.arr,hbx_addrefhb.len);
					strncpy(CNTRL_RCD->hb_cage_code,(char *) hbx_adcagehb.arr,hbx_adcagehb.len);
					strncpy(CNTRL_RCD->ha_ref_no,(char *) hbx_refnumha.arr,hbx_refnumha.len);
					strncpy(CNTRL_RCD->ha_cage_code,(char *) hbx_cagecdxh.arr,hbx_cagecdxh.len);
					errcode=fetch_f18_proof_HB_candidates(CNTRL_RCD,SEGMNT01,SEGMNT02,SEGMNT03,SEGMNT04,SEGMNT05,SEGMNT08);
					if(errcode==0)
					{
					}
					else
					{
						fetched_row=1;
						return(errcode);
					}
				}
				else
				{
				}
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
				}
				else
				{
					printf("\nselect_proof_HB_candidates");
					printf("\n\tBad SQLCODE on Fetch of Cursor");
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					errcode=1003;
					btchslpf_dberr();
				}
			}			   	
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
		}
		else
		{
			printf("\nselect_proof_HB_candidates");
			printf("\n\tBad SQLCODE on Open of Cursor");
			errcode=1004;
			btchslpf_dberr();
		}
	}		
			
	EXEC SQL CLOSE selct_f18_HB_candidate_info_csr;
	return(errcode);
}
/*	This function checks to see if the FETCHED HB REF_NO/CAGE CODE are equal to what was previously
	processed.  If not, then it allows the HB reference number to be processed.  If it has been
	processed, then will not process it again.

	Setting errcode equal to 1, signifies the HB REF_NO/CAGE CODE has been processed.

	      */
	      
int	check_f18_hb_cntrl(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;
	char    spaces[]={"                                        "};

	#if DEBUG
		printf("\ncheck_f18_hb_cntrl");
	#endif
	
	if ((strncmp((char *) hbx_refnumha.arr,CNTRL_RCD->hb_ref_no,32) == 0) &&
	   (strncmp((char *) hbx_cagecdxh.arr,CNTRL_RCD->hb_cage_code,5) == 0))
	{
	}
	else
	{
		errcode=0;
		strncpy(CNTRL_RCD->hb_ref_no,(char *) hbx_refnumha.arr,hbx_refnumha.len);
		strncpy(CNTRL_RCD->hb_cage_code,(char *) hbx_cagecdxh.arr,hbx_cagecdxh.len);
		CNTRL_RCD->built_01='N';
		CNTRL_RCD->built_04='Y';
		CNTRL_RCD->built_05='Y';
	}
	return(errcode);
}

/*
	This function processing takes the information passed from the select_proof_HB_candidates
	checks it against the HA/HG table using the ARN_ITEM_REF_NO and ARN_ITEM_CAGE_CODE to determine
	which HA/HG information to use for the HBX REF_NO/CAGE CODE.

			*/
			
EXEC SQL DECLARE fetch_f18_HB_candidate_info_csr CURSOR for 
    select distinct slic_hg.refnumha,
    	   slic_hg.cagecdxh,
    	   slic_hg.eiacodxa,
    	   slic_hg.lsaconxb,
    	   slic_hg.altlcnxb,
	   slic_hg.qtypeihg,
	   slic_hg.itmcathg,
	   ' ',
	   substr(slic_hg.smrcodhg,1,1),
	   intrfce.proof_transfer_flag
       from prov.f18_intrfce_ext intrfce,
	    slic2b20.f18_hg slic_hg
        where
	      slic_hg.can_int = 0
	  and slic_hg.lcntypxb = 'P'
	  and slic_hg.refnumha = :hbx_refnumha
	  and slic_hg.cagecdxh = :hbx_cagecdxh
	  and intrfce.ref_no = rtrim(:hbx_addrefhb)
	  and intrfce.cage_code = rtrim(:hbx_adcagehb)
	  and ha_hb_ind = 'HB'
	  and slic_hg.itmcathg > ' '
	  and exists (select *
			from slic2b20.f18_xax01 xax01,
			     prov.ms2_sliceiac ms2_sliceiac
				where
	  			    xax01.eiacodxa = slic_hg.eiacodxa
	  			and rtrim(xax01.xaxprovmdl) = ms2_sliceiac.eiac
				and slic_hg.can_int = xax01.can_int)
             order by 1,2;

int     fetch_f18_proof_HB_candidates(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02,struct prtsc03 *SEGMNT03,struct prtsc04 *SEGMNT04,struct prtsc05 *SEGMNT05,struct prtsc08 *SEGMNT08)

{
	int	errcode=0;
	int     fetched_row=0;
	int	fetched_ctr=0;
	char    spaces[]={"                                        "};
	/*char	*Leftstr();*/


	#if DEBUG
		printf("\nfetch_f18_proof_HB_candidates");
		printf("\naddrefhb (%s)",(char *) hbx_addrefhb.arr);
		printf("\nadcagehb (%s)",(char *) hbx_adcagehb.arr);
		printf("\nrefnumha (%s)",(char *) hbx_refnumha.arr);
		printf("\ncagecdxh (%s)",(char *) hbx_cagecdxh.arr);
	#endif

	EXEC SQL OPEN fetch_f18_HB_candidate_info_csr;
	
	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			EXEC SQL FETCH fetch_f18_HB_candidate_info_csr
			   INTO :hgx_refnumha,
				:hgx_cagecdxh,
				:hg_eiacodxa,
				:lsaconxb,
			   	:altlcnxb,
		   		:qtypeihg:qtypeihg_i,
				:itmcathg:itmcathg_i,
				:ha_cog_pos1,
				:smrcodhg_pos1:smrcodhg_pos1_i,
				:proof_transfer_flag:proof_transfer_i;
			if (sqlca.sqlcode == FND)
			{
				errcode=check_f18_cntrl(CNTRL_RCD);
				if (errcode == 0)
				{
					strncpy(SEGMNT03->hg_icc,(char *) itmcathg.arr,itmcathg.len);
					strncpy((char *) refnumha.arr,CNTRL_RCD->ha_ref_no,32);
					strncpy((char *) cagecdxh.arr,CNTRL_RCD->ha_cage_code,5);
					refnumha.arr[32]='\0';
					refnumha.len = (unsigned short) strlen((char *) refnumha.arr);
					cagecdxh.len=5;
					cagecdxh.arr[5]='\0';
					strncpy((char *) eiacodxa.arr,(char *) hg_eiacodxa.arr,hg_eiacodxa.len);
					eiacodxa.arr[10]='\0';
					eiacodxa.len=10;
					strncpy(CNTRL_RCD->hg_lcn,(char *) lsaconxb.arr,lsaconxb.len);
					strncpy(CNTRL_RCD->hg_alc,(char *) altlcnxb.arr,altlcnxb.len);
					errcode=validate_f18_hg_rcd(CNTRL_RCD);
					if (CNTRL_RCD->valid_application == 'Y')
					{
						errcode=get_f18_hgx_data(CNTRL_RCD);
					}
					/*lsaconxb_pos4=Leftstr((char *) lsaconxb.arr,6);*/
					if (strncmp((char *) lsaconxb.arr,"XEMD99",6)==0)
					{
						CNTRL_RCD->valid_application='N';
					}
					else
					{
						if(lsaconxb.arr[0] == 'X')
						{
							CNTRL_RCD->valid_application='Y';
						}
						else
						{
						}
					}
					if (CNTRL_RCD->valid_application == 'Y')
					{
						fetched_ctr++;
						if (strncmp((char *) prev_eiacodxa.arr,(char *) eiacodxa.arr,10)==0)
						{
						}
						else
						{
							errcode=get_customer_model(CNTRL_RCD);
							strncpy((char *) prev_eiacodxa.arr,"          ",10);
							strncpy((char *) prev_eiacodxa.arr,(char *) eiacodxa.arr,eiacodxa.len);
						}
						if (errcode==0)
						{
							errcode=gather_f18_proof_data(CNTRL_RCD,SEGMNT01,SEGMNT02,SEGMNT03,SEGMNT04,SEGMNT05,SEGMNT08);
							if (errcode==0)
							{
							}
							else
							{
								fetched_row=1;
							}
						}
						else
						{
							fetched_row=1;
						}
					}
				}
				else
				{
					fetched_row=1;
				}
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
					if(fetched_ctr>0)
					{
					}
					else
					{
						CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					}
				}
				else
				{
					printf("\nfetch_proof_HB_candidates");
					printf("\n\tBad SQLCODE on Fetch of Cursor");
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					errcode=1005;
					btchslpf_dberr();
				}
			}			   	
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			printf("\nfetch_proof_HB_candidates");
			printf("\n\tUnable to locate information on Initial Select");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1006;
		}
		else
		{
			printf("\nfetch_proof_HB_candidates");
			printf("\n\tBad SQLCODE on Open of Cursor");
			errcode=1007;
			btchslpf_dberr();
		}
	}		
			
	EXEC SQL CLOSE fetch_f18_HB_candidate_info_csr;
	return(errcode);
}
/*	This function retrieve the Customer/Model Information based upon the EIAC  */

int	get_customer_model(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;
	
	#if DEBUG
		printf("\nget_customer_model");
	#endif

/*  LDM Changes */	
	EXEC SQL
		select distinct eiac,cn
		     into :mdl_acft_prf,cn
		  from prov.ms2_sliceiac tble34,
		       slic2b20.f18_xax01 xax01
		   where
		         rtrim(xaxprovmdl) = rtrim(tble34.eiac)
		     and rtrim(xax01.eiacodxa) = rtrim(:eiacodxa)
		     and xax01.can_int = 0;
		     
	if (sqlca.sqlcode == FND)
	{
		strncpy(CNTRL_RCD->mdl_acft_prf,"          ",10);
		strncpy(CNTRL_RCD->cn,"  ",2);
		strncpy(CNTRL_RCD->mdl_acft_prf,(char *) mdl_acft_prf.arr,mdl_acft_prf.len);
		strncpy(CNTRL_RCD->cn,(char *) cn.arr,cn.len);
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			printf("\nUnable to locate SAMS Model in MS2_SLICEIAC Table");
			printf("\n\tProcessing EIAC (%s) (%d)",(char *) eiacodxa.arr,eiacodxa.len);
			printf("\n\tProcessing REFNUMHA (%s) (%d)",(char *) refnumha.arr,refnumha.len);
			printf("\n\tProcessing CAGECDXH (%s) (%d)",(char *) cagecdxh.arr,cagecdxh.len);
			printf("\n\tProcessing LSACONXB (%s) (%d)",(char *) lsaconxb.arr,lsaconxb.len);
			printf("\n\tProcessing ALTLCNXB (%s) (%d)",(char *) altlcnxb.arr,altlcnxb.len);
			errcode=1012;
		}
		else
		{
			printf("\nFUNCTION: get_customer_model");
			printf("\nBad SQLCODE");
			errcode=1013;
			btchslpf_dberr();
		}
	}  
		     
	return(errcode);
}


int     get_f18_hgx_data(struct cntrl_rcd *CNTRL_RCD)
{
	
	int	errcode=0;
	
	#if DEBUG
		printf("\nget_f18_hgx_data");
	#endif

	EXEC SQL 
	    select hgx.nharefno,
	  	   hgx.nhacgecd,
	   	   hgx.suplyrcd
	   	INTO :hgx_nharefno:hgx_nharefno_i,
		     :hgx_nhacgecd:hgx_nhacgecd_i,
		     :hgx_suplyrcd:hgx_suplyrcd_i
       		from slic2b20.f18_hgx01 hgx
        	where
	      		hgx.can_int = 0
	  	    and hgx.lcntypxb = 'P'
	  	    and hgx.eiacodxa = :hg_eiacodxa
          	    and hgx.lsaconxb = :lsaconxb
          	    and hgx.altlcnxb = :altlcnxb
          	    and hgx.refnumha = :hgx_refnumha
          	    and hgx.cagecdxh = :hgx_cagecdxh;
			
	if (sqlca.sqlcode == FND)
	{
		#if DEBUG
			printf("\nget_f18_hgx_data - Data Found");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			printf("\nNHA (%s)",(char *) hgx_nharefno.arr);
			printf("\nNHA Cage (%s)",(char *) hgx_nhacgecd.arr);
			printf("\nSuplyr (%s)",(char *) hgx_suplyrcd.arr);
		#endif
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			#if DEBUG
				printf("\nget_f18_hgx_data - Data Found");
				printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
				printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
				printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
				printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
				printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
				printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
				printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			#endif
			hgx_nharefno_i=1;
			hgx_nhacgecd_i=1;
			hgx_suplyrcd_i=1;
		}
		else
		{
			if (sqlca.sqlcode == -2112)
			{
				strncpy((char *) hgx_nharefno.arr,"MULTIPLE NHA-UNABLE TO DETERMINE",32);
				hgx_nharefno.len=32;
				hgx_nharefno_i=0;
			}
			else
			{
				printf("\nget_f18_hgx_data");
				printf("\n\tBad SQLCODE on Fetch of Cursor");
				printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
				printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
				printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
				printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
				printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
				printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
				printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
				CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
				errcode=1014;
				btchslpf_dberr();
			}
		}
	}
	
			
	return(errcode);
}
/*	This function checks to see if the FETCHED REF_NO/CAGE CODE are equal to what was previously
	processed.  If not, then it sets up previous information and resets the "built_??" indicators to
	"N".
	      */
int	check_f18_cntrl(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;

	#if DEBUG
		printf("\ncheck_f18_cntrl");
	#endif

	if ((strncmp((char *) hgx_refnumha.arr,CNTRL_RCD->ha_ref_no,32) == 0) &&
	   (strncmp((char *) hgx_cagecdxh.arr,CNTRL_RCD->ha_cage_code,5) == 0))
	{
	}
	else
	{
		strncpy(CNTRL_RCD->ha_ref_no,(char *) hgx_refnumha.arr,hgx_refnumha.len);
		strncpy(CNTRL_RCD->ha_cage_code,(char *) hgx_cagecdxh.arr,hgx_cagecdxh.len);
		CNTRL_RCD->built_01='N';
		CNTRL_RCD->built_04='Y';
		CNTRL_RCD->built_05='Y';
	}
	return(errcode);
}

/*	This function checks to see if the information is a valid application.  It must have a "Y" on the
	PROOF_TRANSFER_FLAG on the HAX or Effectivity.  If neither of these conditions are true then this
	application is not processed.
	
	*/
	
int	validate_f18_hg_rcd(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;
	
	CNTRL_RCD->valid_application = 'N';

	#if DEBUG
		printf("\nvalidate_f18_hg_rcd - BEFORE");
		printf("\nRef No (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nRef No (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nLCN (%s)",(char *) lsaconxb.arr);
		printf("\nValid Application Flag (%c)",CNTRL_RCD->valid_application);
		printf("\nPROOF Transfer Flag (%c)",proof_transfer_flag);
	#endif	
	
	if (proof_transfer_flag == 'Y')
	{
		CNTRL_RCD->valid_application = 'Y';
	}
	else
	{
		errcode=check_f18_eff_exist(CNTRL_RCD);
		if (CNTRL_RCD->valid_application == 'Y')
		{
			if (smrcodhg_pos1_i == 0)
			{
				if (smrcodhg_pos1 == 'P')
				{
					#if DEBUG
						printf("\nSMRCODE P/COG 9 Validation");
					#endif	
					CNTRL_RCD->valid_application = 'Y';
				}
				else
				{
					#if DEBUG
						printf("\nSMRCODE/COG Validation");
					#endif	
					CNTRL_RCD->valid_application = 'N';
				}
			}
			else
			{
				CNTRL_RCD->valid_application='N';
				#if DEBUG
					printf("\nNo SMRCODE Validation");
				#endif	
			}
		}
		if (CNTRL_RCD->valid_application == 'Y')
		{
			#if DEBUG
				printf("\nCheck ICC");
			#endif	
			errcode=check_f18_itmcathg(CNTRL_RCD);
		}
	}	
	
	#if DEBUG
		printf("\nvalidate_f18_hg_rcd - AFTER");
		printf("\nRef No (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nRef No (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nLCN (%s)",(char *) lsaconxb.arr);
		printf("\nValid Application Flag (%c)",CNTRL_RCD->valid_application);
		printf("\nPROOF Transfer Flag (%c)",proof_transfer_flag);
	#endif	

	return(errcode);
}
int	validate_f18_lcn(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;
	/*char	*Leftstr();*/
	
	#if DEBUG
		printf("\nvalidate_f18_lcn - BEFORE");
		printf("\nRef No (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nRef No (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nLCN (%s)",(char * ) lsaconxb.arr);
		printf("\nValid Application Flag (%c)",CNTRL_RCD->valid_application);
		printf("\nPROOF Transfer Flag (%c)",proof_transfer_flag);
	#endif
	
	
	/*lsaconxb_pos6=Leftstr((char *) lsaconxb.arr,6);*/
	if (strncmp((char *) lsaconxb.arr,"XEMD99",6)==0)
	{
		CNTRL_RCD->valid_application='N';
	}
	else
	{
		if(lsaconxb.arr[0] == 'X')
		{
			CNTRL_RCD->valid_application='Y';
		}
		else
		{
		}
	}
	
	#if DEBUG
		printf("\nvalidate_f18_lcn - AFTER");
		printf("\nRef No (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nRef No (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nLCN (%s)",(char *) lsaconxb.arr);
		printf("\nValid Application Flag (%c)",CNTRL_RCD->valid_application);
		printf("\nPROOF Transfer Flag (%c)",proof_transfer_flag);
	#endif	

	return(errcode);
}
/*



				*/
EXEC SQL DECLARE cnt_f18_effecty_csr CURSOR for
	select count(*)
	from slic2b20.f18_hgx01a hgx2	     
	    where hgx2.refnumha = :refnumha
	     and hgx2.cagecdxh  = :cagecdxh
	     and hgx2.eiacodxa = :eiacodxa
	     and hgx2.lcntypxb   = 'P'
	     and hgx2.lsaconxb = :hg_lsaconxb
	     and hgx2.altlcnxb = :hg_altlcnxb
	     and hgx2.can_int = 0
	union
	select count(*)
	from slic2b20.f18_hpx01a hpx2  
 	   where hpx2.refnumha = :refnumha
	     and hpx2.cagecdxh = :cagecdxh
	     and hpx2.eiacodxa = :eiacodxa
	     and hpx2.lcntypxb  = 'P'
	     and hpx2.lsaconxb = :hg_lsaconxb
	     and hpx2.altlcnxb = :hg_altlcnxb
	     and hpx2.can_int = 0;

int	check_f18_eff_exist(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;
	int	fetched_row=0;
	int	number_rows=0;
	
	strncpy((char *) hg_lsaconxb.arr,CNTRL_RCD->hg_lcn,18);
	hg_lsaconxb.arr[18]='\0';
	hg_lsaconxb.len = (unsigned short) strlen((char *) hg_lsaconxb.arr);
	strncpy((char *) hg_altlcnxb.arr,CNTRL_RCD->hg_alc,2);
	hg_altlcnxb.arr[2]='\0';
	hg_altlcnxb.len=2;

	#if DEBUG
		printf("\ncheck_f18_eff_exist");
		printf("\nrefnumha (%s) (%d) (%d)",(char *) refnumha.arr,strlen((char *) refnumha.arr),refnumha.len);
		printf("\ncagecdxh (%s) (%d) (%d)",(char *) cagecdxh.arr,strlen((char *) cagecdxh.arr),cagecdxh.len);
		printf("\neiacodxa (%s) (%d) (%d)",(char *) eiacodxa.arr,strlen((char *) eiacodxa.arr),eiacodxa.len);
		printf("\nlsaconxb (%s) (%d) (%d)",(char *) hg_lsaconxb.arr,(char *) hg_lsaconxb.len,strlen((char *) hg_lsaconxb.arr));
		printf("\nlsaconxb (%s) (%d) (%d)",(char *) lsaconxb.arr,lsaconxb.len,strlen((char *) lsaconxb.arr));
		printf("\naltlcnxb (%s) (%d)",(char *) hg_altlcnxb.arr,hg_altlcnxb.len);
	#endif

	EXEC SQL OPEN cnt_f18_effecty_csr;

	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			EXEC SQL FETCH cnt_f18_effecty_csr
			  into 	:num_eff:num_eff_i;

			if (sqlca.sqlcode == FND)
			{
				if (num_eff_i == 0)
				{
					if (num_eff > 0)
					{
						number_rows=number_rows+num_eff;
						CNTRL_RCD->valid_application = 'Y';
					}
					else
					{
					}
				}
				else
				{
				}
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
					if (number_rows > 0)
					{
					}
					else
					{
						CNTRL_RCD->valid_application = 'N';
					}
				}
				else
				{
					printf("\nFUNCTION: fetch_eff");
					printf("\n\tFETCH Data Failure");
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					errcode=1008;
					btchslpf_dberr();
				}
			}
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			CNTRL_RCD->valid_application = 'N';
		}
		else
		{
			printf("\nFUNCTION: fetch_eff");
			printf("\n\tOpen Cursor Failure");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1009;
			btchslpf_dberr();
			
		}
	}

	EXEC SQL CLOSE cnt_f18_effecty_csr;
	
	#if DEBUG
		printf("\ncheck_f18_eff_exist - Exit Function");
		printf("\nNumber Rows Effectvty (%d)",number_rows);
	#endif
	
	return(errcode);
}

/*	This function qualifies the selected application based upon the value of the Item category
	on the SLIC HG Record.
		*/
int	check_f18_itmcathg(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;
	char	lsaconxb_pos1;
	/*char	*Leftstr();*/
	
	#if DEBUG
		printf("\ncheck_f18_itmcathg");
	#endif

	lsaconxb_pos1=lsaconxb.arr[0];

	if (strncmp((char *) itmcathg.arr,"  ",2)==0)
	{
		if (lsaconxb_pos1 == 'X')
		{
			#if DEBUG
				printf("\nBlank ICC LCN POSTN 1 == X Validation");
			#endif	
			CNTRL_RCD->valid_application = 'Y';
		}
		else
		{
			#if DEBUG
				printf("\nBlank ICC LCN POSTN 1 <> X Validation");
			#endif	
			CNTRL_RCD->valid_application = 'N';
		}
	}
	 	 
	return(errcode);
}
/*

		*/
static int	gather_f18_proof_data(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02,struct prtsc03 *SEGMNT03,struct prtsc04 *SEGMNT04,struct prtsc05 *SEGMNT05,struct prtsc08 *SEGMNT08)
{
	int	errcode=0;

	#if DEBUG
		printf("\ngather_f18_proof_data");
	#endif

	if (prev_cn.arr[0] == ' ')
	{
		strncpy((char *) prev_cn.arr,CNTRL_RCD->cn,2);
	}
	else
	{
		if (strncmp((char *) prev_cn.arr,CNTRL_RCD->cn,2)==0)
		{
		}
		else
		{
			errcode=set_f18_custmr(CNTRL_RCD,SEGMNT02);
			errcode=write_f18_segmnt02(CNTRL_RCD,SEGMNT02);
			CNTRL_RCD->built_04 = 'Y';
			CNTRL_RCD->built_05 = 'Y';
			strncpy((char *) prev_cn.arr,CNTRL_RCD->cn,2);
		}
	}
	if (CNTRL_RCD->built_01 == 'Y')
	{
	}
	else
	{
		errcode=create_f18_0102(CNTRL_RCD,SEGMNT01,SEGMNT02);
	}

/*	if(errcode == 0)
	{
		errcode=create_f18_03(CNTRL_RCD,SEGMNT03);
	}
	else
	{
	}   */

	if (CNTRL_RCD->built_04 == 'Y')
	{
	}
	else
	{
		if (errcode == 0)
		{
			errcode=create_f18_04(CNTRL_RCD,SEGMNT04);
		}
		else
		{
		}
	}

	if (CNTRL_RCD->built_05 == 'Y')
	{
	}
	else
	{
		if (errcode == 0)
		{
			errcode=create_f18_05(CNTRL_RCD,SEGMNT05);
		}
		else
		{
		}
	}

	if (errcode == 0)
	{
		errcode=build_f18_prtsc08_rcd(SEGMNT08,CNTRL_RCD);
	}
	else
	{
	}
	
	return(errcode);
}

/*

	This is the main processing function for building the
	PROOF interface Record.
	*/

static int     build_f18_prtsc08_rcd(struct prtsc08 *SEGMNT08,struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;
	int	i=0;
	char    spaces[]={"                                        "};

	#if DEBUG
		printf("\nbuild_f18_prtsc08_rcd");
	#endif
	
	errcode=initlze_segmnt08(SEGMNT08);

	
	
	if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
	{
		strncpy(SEGMNT08->ref_no,(char *) hgx_refnumha.arr,hgx_refnumha.len);
		strncpy(SEGMNT08->cage_code,(char *) hgx_cagecdxh.arr,hgx_cagecdxh.len);
	}
	else
	{
		if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
		{
			strncpy(SEGMNT08->ref_no,CNTRL_RCD->hb_ref_no,32);
			strncpy(SEGMNT08->cage_code,CNTRL_RCD->hb_cage_code,5);
		}
		else
		{
			printf("\nUnable to determine HA/HB Record Type");
			printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
			errcode=1010;
			return(errcode);
		}
	}
	strncpy(SEGMNT08->hg_end_item_acrnym,CNTRL_RCD->mdl_acft_prf,10);
	strncat(SEGMNT08->hg_end_item_acrnym,spaces,10-mdl_acft_prf.len);
	strncpy(SEGMNT08->prtsc08a,"08",2);
	strncpy(SEGMNT08->hg_alt_lsa,(char *) altlcnxb.arr,altlcnxb.len);
	strncpy(SEGMNT08->hg_lsaconxb,(char *) lsaconxb.arr,lsaconxb.len);
	strncpy(SEGMNT08->hg_08_icc,(char *) itmcathg.arr,itmcathg.len);
	if (hgx_suplyrcd_i == 0)
	{
		strncpy(SEGMNT08->hgx_suplyr_cage,(char *) hgx_suplyrcd.arr,hgx_suplyrcd.len);
	}
	else
	{
		strncpy(SEGMNT08->hgx_suplyr_cage,spaces,5);
	}
        if (qtypeihg_i == 0)
	{
		strncpy(SEGMNT08->hg_qpei,(char *) qtypeihg.arr,qtypeihg.len);
	}
	else
	{
		strncpy(SEGMNT08->hg_qpei,spaces,5);
	}
        if (hgx_nhacgecd_i == 0)
	{
		strncpy(SEGMNT08->hgx_nha_cage,(char *) hgx_nhacgecd.arr,hgx_nhacgecd.len);
	}
	else
	{
		strncpy(SEGMNT08->hgx_nha_cage,spaces,5);
	}

       if (hgx_nharefno_i == 0)
       {
	       strncpy(SEGMNT08->hgx_nha_ref_number,(char *) hgx_nharefno.arr,hgx_nharefno.len);
       }
       else
       {
	       strncpy(SEGMNT08->hgx_nha_ref_number,spaces,32);
	}


	SEGMNT08->prtsc08_eof='\0';
	SEGMNT08->prtsc08_newline='\n';
	#if DEBUG
		printf("\nSegmnt 08 (%s)",SEGMNT08);
	#endif
	memset(outData,'\0',sizeof(outData));
	memcpy(outData,SEGMNT08,sizeof(SEGMNT08));
	errcode=write_f18_rcd((char *) outData,CNTRL_RCD);

	return(errcode);
}
/*
    
			  */
static int	write_f18_rcd(char * outData,struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;
	int	numrecs=0;

	#if DEBUG
		printf("\nwrite_f18_rcd (%s) (%d)",(char *) outData,strlen((char *) outData));
	#endif

	numrecs=fwrite((char *) outData,strlen((char *) outData),1,outfp);
	rcds_written=rcds_written+numrecs;
	rcds_created++;

	return(errcode);
}
/*
 **************************************************************************
 *  PROGRAM NAME: btchsp180102.pc
 *
 *  PURPOSE: This application creates the information for the PRTSC01A and
 *          PRTSC02A Segment of the PROOF IMS Data Base.  
 *
 *  INPUTS:   N/A
 *            
 *           
 *
 *  OUTPUTS:  N/A 
 *            
 *           
 *
 *  CHANGE HISTORY:
 *   REV     DATE    Programmer                 CHANGE
 *   ---  --------   ----------------------     ------
 *    00  05/31/1996 Original Author                Initial coding 
 *    01  08/13/1998 Larry MIlls                Converted Program to use
 *                                              SLIC Tailor Tables
 *
 **************************************************************************
*/

EXEC SQL BEGIN DECLARE SECTION;

/*	PROOF HOST VARIABLES   */

	varchar	 hb_refnumha[33];
	varchar	 hb_cagecdxh[6];
	
/*	1388 HA Table		*/

	varchar	ha_itnameha[20];
	short	ha_itnameha_i;
	char	ha_physecha;
	short	ha_physecha_i;
	char	ha_shlifeha;
	short	ha_shlifeha_i;
	varchar	ha_unitisha[3];
	short	ha_unitisha_i;
	varchar	ha_prdldtha[5];
	short	ha_prdldtha_i;
	varchar	ha_cognsnha[3];
	short	ha_cognsnha_i;
	varchar	ha_smmnsnha[3];
	short	ha_smmnsnha_i;
	char	ha_matnsnha;
	short	ha_matnsnha_i;
	varchar	ha_fscnsnha[5];
	short	ha_fscnsnha_i;
	varchar	ha_niinsnha[10];
	short	ha_niinsnha_i;
        char    ha_applccha;
        short	ha_applccha_i;


/*	1388 HAX Extension      */

	varchar	hax_sctldtme[3];
	short	hax_sctldtme_i;
	char	hax_scttstfg;
	short	hax_scttstfg_i;
	varchar	hax_sctcmpdt[11];
	short	hax_sctcmpdt_i;
	varchar	hax_sctauth[16];
	short	hax_sctauth_i;
	varchar	hax_nicncog[3];
	short	hax_nicncog_i;
	char	hax_nicnmcc;
	short	hax_nicnmcc_i;
	varchar	hax_nicnfsc[5];
	short	hax_nicnfsc_i;
	varchar	hax_nicnniin[10];
	short	hax_nicnniin_i;
	varchar	hax_nicnsmic[3];
	short  	hax_nicnsmic_i;
	varchar hax_psind[4];
	short	hax_psind_i;
	varchar hax_psscdno[23];
	short   hax_psscdno_i;
	char	hax_proof_transfer_flag;
	short	hax_proof_transfer_flag_i;

/*      1388 HB Table definition   */

	varchar addrefhb[33];
	short   addrefhb_i;
	varchar adcagehb[6];
	short   adcagehb_i;
	char    arn_rncc;
	short   arn_rncc_i;
	char	arn_type_code;
	short	arn_type_code_i;

		
/*	1388 HF Table		*/

	varchar	hf_qtyupkhf[4];
	short	hf_qtyupkhf_i;
	
/*      1388 EA Table definition   */

	char    se_cfegfeea;
	short   se_cfegfeea_i;
	
/*	1388 HG Extension Table Elements  */
/*	varchar	hgx_suplyrcd[6];
	short	hgx_suplyrcd_i; */
	char	cat_resp_ind;
	char	se_item_ind;


EXEC SQL END DECLARE SECTION;

static int	create_f18_0102(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02) 

{

	int	errcode=0;

	#if DEBUG
		printf("\ncreate_f18_0102");
	#endif
	
        strncpy((char *) refnumha.arr,CNTRL_RCD->ha_ref_no,32);
	refnumha.arr[32]='\0';
	refnumha.len = (unsigned short) strlen((char *) refnumha.arr);
	strncpy((char *) cagecdxh.arr,CNTRL_RCD->ha_cage_code,5);
	cagecdxh.arr[5]='\0';
	cagecdxh.len=5;
	
	errcode=initlze_segmnt0102_host_var();

	if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
	{
	#if DEBUG
		printf("\ncreate_f18_0102 #1");
	#endif
		errcode=get_PRTSC01A_f18_ha(CNTRL_RCD,SEGMNT01,SEGMNT02);		
	}
	else
	{
	#if DEBUG
		printf("\ncreate_f18_0102 #2");
	#endif
		if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
		{
			        strncpy((char *) hb_refnumha.arr,CNTRL_RCD->hb_ref_no,32);
				hb_refnumha.arr[32]='\0';
				hb_refnumha.len=32;
				strncpy((char *) hb_cagecdxh.arr,CNTRL_RCD->hb_cage_code,5);
				hb_cagecdxh.arr[5]='\0';
				hb_cagecdxh.len=5;
				errcode=get_PRTSC01A_f18_hb(CNTRL_RCD,SEGMNT01,SEGMNT02);			
		}
		else
		{
			printf("\ncreate_0102");
			printf("\nUnable to determine HA/HB Record Type");
			printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1100;
			return(errcode);
		}
	}
	
	return(errcode);		
}


/*	This function the PRTSC01A information is the request is for F18
				*/

static int     get_PRTSC01A_f18_ha(struct cntrl_rcd *CNTRL_RCD, struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02)

{
	int	errcode=0;

	#if DEBUG
		printf("\nget_PRTSC01A_F18_ha");
		printf("\nrefnumha (%s) (%d) (%d)",(char *) refnumha.arr,strlen((char *) refnumha.arr),refnumha.len);
		printf("\ncagecdxh (%s) (%d) (%d)",(char *) cagecdxh.arr,strlen((char *) cagecdxh.arr),cagecdxh.len);
	#endif

	EXEC SQL
            select  ha.itnameha,
		substr(to_char(ha.prdldtha,'0009'),2,4),
                ha.physecha,
                ha.shlifeha,
		ha.unitisha,
                ha.cognsnha,
		ha.smmnsnha,
		ha.matnsnha,
		ha.fscnsnha,
		ha.niinsnha,
		ha.aaplccha,
		intrfce.proof_transfer_flag
		into :ha_itnameha:ha_itnameha_i,
		    :ha_prdldtha:ha_prdldtha_i,
		    :ha_physecha:ha_physecha_i,
		    :ha_shlifeha:ha_shlifeha_i,
		    :ha_unitisha:ha_unitisha_i,
		    :ha_cognsnha:ha_cognsnha_i,
		    :ha_smmnsnha:ha_smmnsnha_i,
		    :ha_matnsnha:ha_matnsnha_i,
		    :ha_fscnsnha:ha_fscnsnha_i,
		    :ha_niinsnha:ha_niinsnha_i,
		    :ha_applccha:ha_applccha_i,
        	    :hax_proof_transfer_flag:hax_proof_transfer_flag_i
            from prov.f18_intrfce_ext intrfce,
		 slic2b20.f18_ha ha
            where
                  ha.can_int = 0
	      and rtrim(ha.refnumha) = intrfce.ref_no
	      and ha.cagecdxh = intrfce.cage_code
              and ha.refnumha = :refnumha
              and ha.cagecdxh = :cagecdxh
              and intrfce.ha_hb_ind = 'HA';


	if (sqlca.sqlcode == FND)
	{
		errcode=get_f18_hax01_data(CNTRL_RCD);
		if (errcode == 0)
		{
			errcode=get_f18_hax01a_data(CNTRL_RCD);
		}
		if (errcode == 0)
		{
			errcode=get_PRTSC01A_f18_hf(CNTRL_RCD);
		}
		if(errcode == 0 && (hax_proof_transfer_flag == 'N' ||
		                    hax_proof_transfer_flag_i == -1))
		{
			SEGMNT01->proof_transfer_flag='N';
			errcode=updte_f18_hax_xfer_flag(CNTRL_RCD);
		}
		else
		{
			SEGMNT01->proof_transfer_flag=hax_proof_transfer_flag;
		}
		if (errcode == 0)
		{
			errcode=get_f18_SE_info_ea(CNTRL_RCD);
		}
		if(errcode == 0)
		{
			errcode=get_f18_arn_info(CNTRL_RCD);
		}
		if(errcode == 0)
		{
			errcode=determine_f18_se_data(CNTRL_RCD,SEGMNT01);
		}
		if(errcode == 0)
		{
			errcode=determine_f18_cat_resp(CNTRL_RCD);
		}
		if (errcode == 0)
		{
			errcode=build_f18_prtsc0102_rcd(CNTRL_RCD,SEGMNT01,SEGMNT02);
			CNTRL_RCD->built_01='Y';
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			printf("\nget_PRTSC01A_F18_ha");
			printf("\nUnable to locate HA Record for selected HG");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1101;
		}
		else
		{
			printf("\nget_PRTSC01A_F18_ha");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1102;
			btchslpf_dberr();
		}
	}

	return(errcode);		
}
static int     get_f18_hax01_data(struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;

	#if DEBUG
		printf("\nget_f18_hax01_data");
		printf("\nrefnumha (%s) (%d) (%d)",(char *) refnumha.arr,strlen((char *) refnumha.arr),refnumha.len);
		printf("\ncagecdxh (%s) (%d) (%d)",(char *) cagecdxh.arr,strlen((char *) cagecdxh.arr),cagecdxh.len);
	#endif

	EXEC SQL
            select hax.nicncog,
		hax.nicnmcc,
		hax.nicnfsc,
		hax.nicnniin,
		hax.nicnsmic 
		into :hax_nicncog:hax_nicncog_i,
		     :hax_nicnmcc:hax_nicnmcc_i,
		     :hax_nicnfsc:hax_nicnfsc_i,
		     :hax_nicnniin:hax_nicnniin_i,
		     :hax_nicnsmic:hax_nicnsmic_i
            from slic2b20.f18_hax01 hax
            where
                  hax.can_int = 0
	      and hax.refnumha = :refnumha
              and hax.cagecdxh = :cagecdxh;


	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			hax_nicncog_i=1;
			hax_nicnmcc_i=1;
			hax_nicnfsc_i=1;
			hax_nicnniin_i=1;
			hax_nicnsmic_i=1;
		}
		else
		{
			printf("\nget_F18_hax_data");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1114;
			btchslpf_dberr();		
		}
	}
	
	return(errcode);
}
static int     get_f18_hax01a_data(struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;

	#if DEBUG
		printf("\nget_f18_hax01a_data");
		printf("\nrefnumha (%s) (%d) (%d)",(char *) refnumha.arr,strlen((char *) refnumha.arr),refnumha.len);
		printf("\ncagecdxh (%s) (%d) (%d)",(char *) cagecdxh.arr,strlen((char *) cagecdxh.arr),cagecdxh.len);
	#endif

	EXEC SQL
            select substr(to_char(hax01a.sctldtme,'09'),2,2),
	        hax01a.scttstfg,
		substr(hax01a.sctcmpdt,6,2)||
		'/'||
		substr(hax01a.sctcmpdt,9,2)||
		'/'||
		substr(hax01a.sctcmpdt,1,4),
                hax01a.sctauth,
		hax01a.psind,
		hax01a.psscdno
		into :hax_sctldtme:hax_sctldtme_i,
		    :hax_scttstfg:hax_scttstfg_i,
		    :hax_sctcmpdt:hax_sctcmpdt_i,
		    :hax_sctauth:hax_sctauth_i,
		    :hax_psind:hax_psind_i,
		    :hax_psscdno:hax_psscdno_i
            from slic2b20.f18_hax01a hax01a
            where
                  hax01a.can_int = 0
	      and hax01a.refnumha = :refnumha
              and hax01a.cagecdxh = :cagecdxh;

	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			hax_sctldtme_i=1;
			hax_sctcmpdt_i=1;
			hax_scttstfg_i=1;
			hax_sctauth_i=1;
			hax_psind_i=1;
			hax_psscdno_i=1;
		}
		else
		{
			printf("\nget_F18_hax_data");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1115;
			btchslpf_dberr();
		}
	}
	
	return(errcode);
}
/*
	This function updates the Proof_TRANSFER_FLAG on the HAX to "Y"
	*/
	
static int	updte_f18_hax_xfer_flag(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;

	#if DEBUG
		printf("\nupdte_f18_hax_xfer_flag");
	#endif
	
	EXEC SQL
		update prov.f18_intrfce_ext
		 	set proof_transfer_flag = 'Y'
		 where
		 	ref_no = rtrim(:refnumha)
		 and	cage_code = :cagecdxh
		 and	ha_hb_ind='HA';
		
	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		printf("\nupdte_f18_hax_xfer_flag");
		printf("\nUnable to update HAX Proof Transfer Flag");
		CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
		printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
		printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
		printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
		printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
		printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
		errcode=1103;
		btchslpf_dberr();
	}

	return(errcode);		
}

/*	This function the PRTSC01A information is the request is for F18
				*/

static int     get_PRTSC01A_f18_hb(struct cntrl_rcd *CNTRL_RCD, struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02)

{
	int	errcode=0;

	#if DEBUG
		printf("\nget_PRTSC01A_f18_hb");
		printf("\nrefnumha (%s) (%d) (%d)",(char *) refnumha.arr,strlen((char *) refnumha.arr),refnumha.len);
		printf("\ncagecdxh (%s) (%d) (%d)",(char *) cagecdxh.arr,strlen((char *) cagecdxh.arr),cagecdxh.len);
	#endif

	EXEC SQL
            select  ha.itnameha,
		substr(to_char(ha.prdldtha,'0009'),2,4),
                ha.physecha,
                ha.shlifeha,
		ha.unitisha,
                ha.cognsnha,
		ha.smmnsnha,
		ha.matnsnha,
		ha.fscnsnha,
		ha.niinsnha,
		ha.aaplccha,
		intrfce.proof_transfer_flag
		into :ha_itnameha:ha_itnameha_i,
		    :ha_prdldtha:ha_prdldtha_i,
		    :ha_physecha:ha_physecha_i,
		    :ha_shlifeha:ha_shlifeha_i,
		    :ha_unitisha:ha_unitisha_i,
		    :ha_cognsnha:ha_cognsnha_i,
		    :ha_smmnsnha:ha_smmnsnha_i,
		    :ha_matnsnha:ha_matnsnha_i,
		    :ha_fscnsnha:ha_fscnsnha_i,
		    :ha_niinsnha:ha_niinsnha_i,
		    :ha_applccha:ha_applccha_i,
        	    :hax_proof_transfer_flag:hax_proof_transfer_flag_i
            from prov.f18_intrfce_ext intrfce,
                 f18_ha ha,
                 f18_hb hb
            where
		  ha.can_int = 0
	      and ha.cagecdxh = :cagecdxh
              and ha.refnumha = :refnumha
              and hb.refnumhb = ha.refnumha
              and hb.cagecdhb = ha.cagecdxh
              and hb.addrefhb = :hb_refnumha
              and hb.adcagehb = :hb_cagecdxh
              and ha.can_int = hb.can_int
              and hb.addrefhb = rpad(intrfce.ref_no,32,' ')
              and hb.adcagehb = intrfce.cage_code
              and intrfce.ha_hb_ind = 'HB';


	if (sqlca.sqlcode == FND)
	{
		errcode=get_f18_hbx_data(CNTRL_RCD);
		if (errcode == 0)
		{
			errcode=get_f18_hax01_data(CNTRL_RCD);
		}
		if (errcode == 0)
		{
			errcode=get_f18_hax01a_data(CNTRL_RCD);
		}
		if(errcode == 0)
		{
			errcode=get_PRTSC01A_f18_hf(CNTRL_RCD);
		}
		if(errcode == 0 && (hax_proof_transfer_flag == 'N' ||
		                    hax_proof_transfer_flag_i == -1))
		{
			SEGMNT01->proof_transfer_flag='N';
			errcode=updte_f18_hbx_xfer_flag(CNTRL_RCD);
		}
		else
		{
			SEGMNT01->proof_transfer_flag=hax_proof_transfer_flag;
		}
		if (errcode == 0)
		{
			errcode=get_f18_SE_info_ea(CNTRL_RCD);
		}
		if(errcode == 0)
		{
			errcode=get_f18_arn_info(CNTRL_RCD);
		}
		if(errcode == 0)
		{
			errcode=determine_f18_se_data(CNTRL_RCD,SEGMNT01);
		}
		if(errcode == 0)
		{
			errcode=determine_f18_cat_resp(CNTRL_RCD);
		}
		if (errcode == 0)
		{
			errcode=build_f18_prtsc0102_rcd(CNTRL_RCD,SEGMNT01,SEGMNT02);
			CNTRL_RCD->built_01='Y';
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			printf("\nget_PRTSC01A_F18_hb");
			printf("\nUnable to locate HA Record for selected HB Record");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1104;
		}
		else
		{
			printf("\nget_PRTSC01A_F18_hb");
			printf("\nBad SQLCODE");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1105;
			btchslpf_dberr();
		}
	}

	return(errcode);		
}
static int     get_f18_hbx_data(struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;

	#if DEBUG
		printf("\nget_F18_hbx_data");
		printf("\nrefnumha (%s) (%d) (%d)",(char *) refnumha.arr,strlen((char *) refnumha.arr),refnumha.len);
		printf("\ncagecdxh (%s) (%d) (%d)",(char *) cagecdxh.arr,strlen((char *) cagecdxh.arr),cagecdxh.len);
	#endif

	EXEC SQL
            select hbx.arncog,
		hbx.arnmcc,
		hbx.arnfsc,
		hbx.arnniin,
		hbx.arnsmic 
		into :hax_nicncog:hax_nicncog_i,
		     :hax_nicnmcc:hax_nicnmcc_i,
		     :hax_nicnfsc:hax_nicnfsc_i,
		     :hax_nicnniin:hax_nicnniin_i,
		     :hax_nicnsmic:hax_nicnsmic_i 
            from slic2b20.f18_hbx01 hbx
            where
                  hbx.can_int   = 0
              and hbx.refnumhb  = :refnumha
              and hbx.cagecdhb  = :cagecdxh
              and hbx.adrefhb   = :hb_refnumha
              and hbx.adcagehb  = :hb_cagecdxh;


	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			hax_nicncog_i=1;
			hax_nicnmcc_i=1;
			hax_nicnfsc_i=1;
			hax_nicnniin_i=1;
			hax_nicnsmic_i=1;
		}
		else
		{
		}
	}
	
	return(errcode);
}
/*
	This function updates the Proof_TRANSFER_FLAG on the HBX to "Y"
	*/
	
static int	updte_f18_hbx_xfer_flag(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;

	#if DEBUG
		printf("\nupdte_f18_hbx_xfer_flag");
	#endif
	
	EXEC SQL
		update prov.f18_intrfce_ext
		 	set proof_transfer_flag = 'Y'
		 where
		          ref_no    = rtrim(:hb_refnumha)
	       	      and cage_code = :hb_cagecdxh
	       	      and ha_hb_ind='HB';
		
	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		printf("\nupdte_f18_hbx_xfer_flag");
		printf("\nUnable to update HBX PROOF Transfer Flag");
		printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
		printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
		printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
		printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
		printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
		errcode=1106;
		CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
		btchslpf_dberr();
	}

	return(errcode);		
}

/*
	This function gets the Packaging Preservation information from
	the 1388 HF Table.
				*/

static int	get_PRTSC01A_f18_hf(struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;

	#if DEBUG
		printf("\nget_PRTSC01A_F18_HF");
	#endif

	EXEC SQL
	    select qtyupkhf
		into :hf_qtyupkhf:hf_qtyupkhf_i
            from slic2b20.f18_hf hf
            where
                  hf.cagecdxh = :cagecdxh
              and hf.refnumha = :refnumha
              and hf.can_int = 0
	      and hf.degprohf in (select max(hf1.degprohf)
				      from slic2b20.f18_hf hf1
				     where hf.cagecdxh = hf1.cagecdxh
				       and hf.refnumha = hf1.refnumha
				       and hf.can_int = hf1.can_int);

	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			strncpy((char *) hf_qtyupkhf.arr,"   ",3);
		}
		else
		{
			printf("\nget_PRTSC01A_F18_HF");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;	
			errcode=1107;
			btchslpf_dberr();
		}
	}

	return(errcode);		
}

static int     get_f18_SE_info_ea(struct cntrl_rcd *CNTRL_RCD)

{
	int     errcode=0;

	#if DEBUG
		printf("\nget_f18_SE_info_ea");
	#endif

	EXEC SQL
	    select cfegfeea
		    into :se_cfegfeea:se_cfegfeea_i
		  from slic2b20.f18_ea ea
	     where
		    ea.secageea = :cagecdxh
	      	and ea.serefnea = :refnumha
	      	and ea.can_int=0;

	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			se_cfegfeea=' ';
		}
		else
		{
			printf("\nget_f18_SE_info_ea");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1108;
			btchslpf_dberr();
		}
	}

	return(errcode);

}
/*  This function retrieves those HB Reference numbers that have a RNCC 
    of 7 (SCD Reference Numbers).  If none are found then it checks to see if it
    has an HB with an RNCC of D (Procurement Spec Reference Number)
				*/
				
	EXEC SQL DECLARE process_f18_arn_info_csr CURSOR for
	 select '1',hb.addrefhb,
	           hb.adcagehb,
		   hb.adrncchb
	          from slic2b20.f18_hb hb
            where
	      	    hb.cagecdhb = :cagecdxh
	      	and hb.refnumhb = :refnumha
	      	and hb.can_int = 0
		and hb.adrncchb = '7'
	union all
	select '2',hb.addrefhb,
	           hb.adcagehb,
		   hb.adrncchb
	          from slic2b20.f18_hb hb
            where
	      	    hb.cagecdhb = :cagecdxh
	      	and hb.refnumhb = :refnumha
	      	and hb.can_int = 0
		and hb.adrncchb = 'D';
		
static int	get_f18_arn_info(struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;
	char	spaces[]={"                                        "};

	#if DEBUG
		printf("\nget_f18_arn_info");
	#endif

	EXEC SQL OPEN process_f18_arn_info_csr;
	
	if (sqlca.sqlcode == FND)
	{
		EXEC SQL FETCH process_f18_arn_info_csr
	    		into :arn_type_code:arn_type_code_i,
			     :addrefhb:addrefhb_i,
			     :adcagehb:adcagehb_i,
			     :arn_rncc:arn_rncc_i;

		if (sqlca.sqlcode == FND)
		{
		}
		else
		{
			if (sqlca.sqlcode == NOT_FND)
			{
				strncpy((char *) addrefhb.arr,spaces,32);
				addrefhb.len=32;
				arn_rncc=' ';
			}
			else
			{
				printf("\nget_f18_arn_info");
				printf("\nBad SQLCODE on FETCH");
				printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
				printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
				printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
				printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
				printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
				printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
				printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
				CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
				errcode=1109;
				btchslpf_dberr();
			}
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
				strncpy((char *) addrefhb.arr,spaces,32);
				strncpy((char *) adcagehb.arr,spaces,5);
				addrefhb.len=32;
				adcagehb.len=5;
				arn_rncc=' ';
		}
		else
		{
			printf("\nget_f18_arn_info");
			printf("\nBad SQLCODE on OPEN CURSOR");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1110;
			btchslpf_dberr();
		}
	}
	
	EXEC SQL CLOSE process_f18_arn_info_csr;

	return(errcode);		
}
/*
	This function determines whether the Ref_NO/CAGE is and SE Item
					*/
	EXEC SQL DECLARE determine_f18_se_csr CURSOR for
	 select count(*)
	        from slic2b20.f18_hgx01a hgx
	   where 
	         hgx.can_int = 0
	     and hgx.lcntypxb = 'P'
	     and hgx.refnumha = :refnumha
	     and hgx.cagecdxh = :cagecdxh
	     and (hgx.lsaconxb like 'X____S%')
	 union all
	 select count(*)
	   from slic2b20.f18_hgx01a hgx,
	        slic2b20.f18_hg slic_hg
	   where
	         slic_hg.can_int  = 0
	     and slic_hg.lsaconxb = 'P'
	     and slic_hg.eiacodxa = hgx.eiacodxa
	     and slic_hg.refnumha = hgx.refnumha
	     and slic_hg.cagecdxh = hgx.cagecdxh
	     and slic_hg.lsaconxb = hgx.lsaconxb
	     and slic_hg.altlcnxb = hgx.altlcnxb
	     and slic_hg.lcntypxb = hgx.lcntypxb
	     and slic_hg.can_int = hgx.can_int
	     and slic_hg.refnumha = :refnumha
	     and slic_hg.cagecdxh = :cagecdxh
	     and (slic_hg.lsaconxb like 'S%' and
	  	  (slic_hg.itmcathg in (' 1',' 2',' 3',' 4',' 5',' 6',' 7',' 8',' D',' G',' H',' M',' N',' E',' P',' R')));

static int	determine_f18_se_data(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01)
{
	int	errcode=0;
	int	fetched_row=0;
	int	fetched_ctr=0;

EXEC SQL BEGIN DECLARE SECTION;
	int	row_count=0;
	short	row_count_i; 
EXEC SQL END DECLARE SECTION;

	#if DEBUG
		printf("\ndetermine_f18_se_data");
		printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
		printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
	#endif
	
	se_item_ind='N';
	EXEC SQL OPEN determine_f18_se_csr;
	
	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			row_count=0;
			EXEC SQL FETCH determine_f18_se_csr
			  into :row_count:row_count_i;
	   		if (sqlca.sqlcode == FND)
			{
				if (row_count_i == FND)
				{
					fetched_ctr=row_count+fetched_ctr;
				}
				else
				{
				}
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
					if (fetched_ctr > 0)
					{
						se_item_ind='Y';
					}
					else
					{
						se_item_ind='N';
					}
				}
				else
				{
					printf("\ndetermine_f18_se_data");
					printf("\nFETCH CURSOR");
					printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
					printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
					printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
					printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
					printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
					printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
					printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					errcode=1111;
					btchslpf_dberr();
				}
			}
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
		}
		else
		{
			printf("\ndetermine_f18_se_data");
			printf("\nOpen CURSOR");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1112;
			btchslpf_dberr();
		}
	}
	
	EXEC SQL CLOSE determine_f18_se_csr;
	
	return(errcode);
}

/*
	This function determines the Category Responsibility Code   */
	
	EXEC SQL DECLARE determine_f18_cat_resp_csr CURSOR for
		select distinct '1',suplyrcd
	            from slic2b20.f18_hgx01 hgx01
	             where hgx01.refnumha = :refnumha
	               and hgx01.cagecdxh = :cagecdxh
	               and hgx01.suplyrcd = '76301'
	     	       and hgx01.lcntypxb = 'P'
	               and hgx01.can_int = 0
	        union all
	        select distinct '2',suplyrcd
	            from slic2b20.f18_hgx01 hgx01
	              where hgx01.refnumha = :refnumha
	                and hgx01.cagecdxh = :cagecdxh
	                and hgx01.can_int = 0
	     	        and hgx01.lcntypxb = 'P'
	                and hgx01.suplyrcd not in ('76301','     ')
	        union all
	        select distinct '3',suplyrcd
	            from slic2b20.f18_hgx01 hgx01
	              where hgx01.refnumha = :refnumha	
	                and hgx01.cagecdxh = :cagecdxh
	     	        and hgx01.lcntypxb = 'P'
	                and (hgx01.suplyrcd is null or
	                     hgx01.suplyrcd = '     ')
	                and hgx01.can_int=0
	        order by 1;
	                    	
static int	determine_f18_cat_resp(struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;
	char	fetched_row=0;
	char	spaces[]={"                                        "};
	
	EXEC SQL OPEN determine_f18_cat_resp_csr;
	
	strncpy((char *) hgx_suplyrcd.arr,spaces,5);
	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			EXEC SQL FETCH determine_f18_cat_resp_csr
			  into :cat_resp_ind,
			       :hgx_suplyrcd:hgx_suplyrcd_i;
	   		if (sqlca.sqlcode == FND)
			{
				if (hgx_suplyrcd_i == FND)
				{
					fetched_row=1;
				}
				else
				{
					strncpy((char *) hgx_suplyrcd.arr,spaces,5);
				}
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
				}
				else
				{
					printf("\ndetermine_f18_cat_resp");
					printf("\nFETCH CURSOR");
					printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
					printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
					printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
					printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
					printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
					printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
					printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					errcode=1113;
					btchslpf_dberr();
				}
			}
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
		}
		else
		{
			printf("\ndetermine_f18_cat_resp");
			printf("\nOpen CURSOR");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1114;
			btchslpf_dberr();
		}
	}
	
	EXEC SQL CLOSE determine_f18_cat_resp_csr;
	
	return(errcode);
}
/*
	This function sets up the output area with information from the
	selects   */

static int	build_f18_prtsc0102_rcd(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02)

{
	int	errcode=0;
	char	spaces[]={"                                        "};
	int	i=0;
	
	#if DEBUG
		printf("\nbuild_f18_prtsc0102_rcd");
		printf("\nHA Ref No (%s)",(char *) refnumha.arr);
		printf("\nHA Ref No Cage (%s)",(char *) cagecdxh.arr);
		printf("\nHB Ref No (%s)",(char *) hb_refnumha.arr);
		printf("\nHB Ref No Cage (%s)",(char *) hb_cagecdxh.arr);
	#endif

	errcode=initlze_segmnt0102(SEGMNT01,SEGMNT02);
	
	errcode=set_f18_custmr(CNTRL_RCD,SEGMNT02);
		
	if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
	{
		strncpy(SEGMNT01->ref_no,(char *) refnumha.arr,refnumha.len);
		strncpy(SEGMNT01->cage_code,(char *) cagecdxh.arr,cagecdxh.len);
	}
	else
	{
		if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
		{
			strncpy(SEGMNT01->ref_no,(char *) hb_refnumha.arr,hb_refnumha.len);
			strncpy(SEGMNT01->cage_code,(char *) hb_cagecdxh.arr,hb_cagecdxh.len);
		}
		else
		{
			printf("\nbuild_f18_prtsc0102_rcd");
			printf("\nUnable to determine HA/HB Record Type - Creation of SEGMNT01 Record");
			printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1115;
			return(errcode);
		}
	}
	
	strncpy(SEGMNT01->prtsc01a,"01",2);
	strncpy(SEGMNT01->filler,spaces,10);
	strncpy(SEGMNT01->ref_no_type,CNTRL_RCD->ha_hb_code,2);
	strncpy(SEGMNT01->ha_item_nme,(char *) ha_itnameha.arr,ha_itnameha.len);
	strncpy(SEGMNT01->ha_prod_lead_time,(char *) ha_prdldtha.arr,ha_prdldtha.len);
	SEGMNT01->se_item=se_item_ind;

	if (hax_sctldtme_i == 0)
	{
		strncpy(SEGMNT01->hax_sct_lead_time,(char *) hax_sctldtme.arr,hax_sctldtme.len);
	}
	else
	{
		strncpy(SEGMNT01->hax_sct_lead_time,spaces,2);
	}
	SEGMNT01->ha_physcl_secrty=ha_physecha;
	SEGMNT01->ha_shlf_life=ha_shlifeha;
	strncpy(SEGMNT01->ha_unit_issue,(char *) ha_unitisha.arr,ha_unitisha.len);
	if (hax_sctcmpdt_i == 0)
	{
		strncpy(SEGMNT01->hax_sct_compltn_date,(char *) hax_sctcmpdt.arr,hax_sctcmpdt.len);
	}
	else
	{
		strncpy(SEGMNT01->hax_sct_compltn_date,spaces,10);
	}
	if (hax_scttstfg_i == 0)
	{
		SEGMNT01->hax_sct_tst_reqd_flag=hax_scttstfg;
	}
	else
	{
		SEGMNT01->hax_sct_tst_reqd_flag=' ';
	}
	if (hax_sctauth_i == 0)
	{
		strncpy(SEGMNT01->hax_sct_authrztn_no,(char *) hax_sctauth.arr,hax_sctauth.len);
	}
	else
	{
		strncpy(SEGMNT01->hax_sct_authrztn_no,spaces,15);
	}
	if (hf_qtyupkhf_i == 0)
	{
		strncpy(SEGMNT01->hf_qup,(char *) hf_qtyupkhf.arr,hf_qtyupkhf.len);
	}
	else
	{
		strncpy(SEGMNT01->hf_qup,spaces,3);
	}
	if (hax_psind_i == 0)
	{
		strncpy(SEGMNT01->hax_ps_ind,(char *) hax_psind.arr,hax_psind.len);
	}
	else
	{
		strncpy(SEGMNT01->hax_ps_ind,spaces,3);
	}
	if (hax_psscdno_i == 0)
	{
		strncpy(SEGMNT01->hax_ps_scd_no,(char *) hax_psscdno.arr,hax_psscdno.len);
	}
	else
	{
		strncpy(SEGMNT01->hax_ps_scd_no,spaces,22);
	}
	

	/* strncpy(SEGMNT02->ha_nsn_cog_code,(char *) ha_cognsnha.arr,ha_cognsnha.len);  cog is no longer needed per Patricia White's request */
	/* SEGMNT02->ha_nsn_matl=ha_matnsnha; */
	strncpy(SEGMNT02->ha_nsn_fsc,(char *) ha_fscnsnha.arr,ha_fscnsnha.len);
	strncpy(SEGMNT02->ha_nsn_niin,(char *) ha_niinsnha.arr,ha_niinsnha.len);
	strncpy(SEGMNT02->ha_nsn_spec_ident,(char *) ha_smmnsnha.arr,ha_smmnsnha.len);
	
	if(hax_nicncog_i == 0)
	{
		strncpy(SEGMNT02->hax_nsn_cog_code,(char *) hax_nicncog.arr,hax_nicncog.len);
	}
	else
	{
		strncpy(SEGMNT02->hax_nsn_cog_code,spaces,2);
	}
	
	if (hax_nicnmcc_i == 0)
	{
		SEGMNT02->hax_nsn_matl=hax_nicnmcc;
	}
	else
	{
		SEGMNT02->hax_nsn_matl=' ';
	}
	
	if(hax_nicnfsc_i == 0)
	{
		strncpy(SEGMNT02->hax_nsn_fsc,(char *) hax_nicnfsc.arr,hax_nicnfsc.len);
	}
	else
	{
		strncpy(SEGMNT02->hax_nsn_fsc,spaces,4);
	}
	
	if(hax_nicnniin_i == 0)
	{
		strncpy(SEGMNT02->hax_nsn_niin,(char *) hax_nicnniin.arr,hax_nicnniin.len);
	}
	else
	{
		strncpy(SEGMNT02->hax_nsn_niin,spaces,9);
	}
	
	if(hax_nicnsmic_i == 0)
	{
		strncpy(SEGMNT02->hax_nsn_spec_ident,(char *) hax_nicnsmic.arr,hax_nicnsmic.len);
	}
	else
	{
		strncpy(SEGMNT02->hax_nsn_spec_ident,spaces,2);
	}
	

	strncpy(SEGMNT02->prtsc02a,"02",2);
	SEGMNT02->ha_aaplccha=ha_applccha;
	strncpy(SEGMNT02->hgx_suplyr_cage_code,(char *) hgx_suplyrcd.arr,hgx_suplyrcd.len); 

	if (addrefhb_i == 0)
	{
		strncpy(SEGMNT01->hb_arn_ref_no,(char *) addrefhb.arr,addrefhb.len);
	}
	else
	{
		strncpy(SEGMNT01->hb_arn_ref_no,spaces,32);
	}
	
	if (adcagehb_i == 0)
	{
		strncpy(SEGMNT01->hb_arn_cage,(char *) adcagehb.arr,adcagehb.len);
	}
	else
	{
		strncpy(SEGMNT01->hb_arn_cage,spaces,5);
	}
	
	if (arn_rncc_i == 0)
	{
		SEGMNT01->hb_arn_rncc=arn_rncc;
	}
	else
	{
		SEGMNT01->hb_arn_rncc=' ';
	}
	
	if (se_cfegfeea_i == 0)
	{
		SEGMNT01->ea_cfe_gfe=se_cfegfeea;
	}
	else
	{
		SEGMNT01->ea_cfe_gfe=' ';
	}
	
	
	SEGMNT01->prtsc01_eof='\0';
	SEGMNT01->prtsc01_newline='\n';
	#if DEBUG
		printf("\nSegmnt 01 (%s)",SEGMNT01);
	#endif
	memset(outData,'\0',sizeof(outData));
	memcpy(outData,SEGMNT01,sizeof(SEGMNT01));
	errcode=write_f18_rcd((char *) &outData,CNTRL_RCD);
	
	for (i=0;i<500;i++)
	{
		outData[i]=' ';
	}

	if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
	{
		strncpy(SEGMNT02->ref_no,(char *) refnumha.arr,refnumha.len);
		strncpy(SEGMNT02->cage_code,(char *) cagecdxh.arr,cagecdxh.len);
	}
	else
	{
		if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
		{
			strncpy(SEGMNT02->ref_no,(char *) hb_refnumha.arr,hb_refnumha.len);
			strncpy(SEGMNT02->cage_code,(char *) hb_cagecdxh.arr,hb_cagecdxh.len);
		}
		else
		{
			printf("\nbuild_f18_prtsc0102_rcd");
			printf("\nUnable to determine HA/HB Record Type - Creation of SEGMNT02 Record");
			printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1116;
			return(errcode);
		}
	}
	
	errcode=write_f18_segmnt02(CNTRL_RCD,SEGMNT02);
	
	return(errcode);		
}
static int	write_f18_segmnt02(struct cntrl_rcd *CNTRL_RCD,struct prtsc02 *SEGMNT02)
{
	int	errcode=0;
	int	fetched_row=0;
	int	fetched_ctr=0;
	char	outData[500];

	SEGMNT02->prtsc02_eof='\0';
	SEGMNT02->prtsc02_newline='\n';
	#if DEBUG
		printf("\nwrite_f18_segmnt02");
		printf("\nSegmnt 02 (%s)",SEGMNT02);
	#endif
	memset(outData,'\0',sizeof(outData));
	memcpy(outData,SEGMNT02,sizeof(SEGMNT02));
	errcode=write_f18_rcd((char *) &outData,CNTRL_RCD);		
	return(errcode);
}

static int	set_f18_custmr(struct cntrl_rcd *CNTRL_RCD,struct prtsc02 *SEGMNT02)
{
	int	errcode=0;
		
	#if DEBUG
		printf("\nset_f18_custmr");
	#endif
	
	strncpy(SEGMNT02->hg_end_item_acrnym,CNTRL_RCD->mdl_acft_prf,10);
	strncpy(SEGMNT02->custmr,CNTRL_RCD->cn,2);
		
	return(errcode);
}
/*
 **************************************************************************
 *  PROGRAM NAME: btchsp1803.pc
 *
 *  PURPOSE: This a pulls the Effectivity Information from the HGX/HPX Tables
 *
 *  INPUTS:   N/A
 *            
 *           
 *
 *  OUTPUTS:  N/A 
 *            
 *           
 *
 *  CHANGE HISTORY:
 *   REV     DATE    Programmer                 CHANGE
 *   ---  --------   ----------------------     ------
 *    00  05/24/1996 Original Author                Initial coding
 *    01  08/13/1998 Original Author                Converted Program to use SLIC
 *   						Tailor Tables.
 *
 **************************************************************************
*/

EXEC SQL BEGIN DECLARE SECTION;

/*	PROOF HOST VARIABLES   */

/*	1388 HG Table Host Variables */

	varchar	hg_03lsaconxb[19];
	varchar	hg_03altlcnxb[3];

/*	Effectivity Host Variables   */

	char	series_cd;
	short	series_cd_i;
	varchar	efffrom[6];
	short	efffrom_i;
	varchar	effto[6];
	short	effto_i;

EXEC SQL END DECLARE SECTION;


static int	create_f18_03(struct cntrl_rcd *CNTRL_RCD,struct prtsc03 *SEGMNT03)

{
	int	errcode=0;

	#if DEBUG
		printf("\ncreate_f18_03");
		printf("\nRefno (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nCage (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nEIAC (%s)",CNTRL_RCD->ha_eiac);
		printf("\nLCN (%s)",CNTRL_RCD->hg_lcn);
		printf("\nALC (%s)",CNTRL_RCD->hg_alc);
	#endif
	
	strncpy((char *) refnumha.arr,CNTRL_RCD->ha_ref_no,32);
	refnumha.arr[32]='\0';
	refnumha.len=32;
	strncpy((char *) cagecdxh.arr,CNTRL_RCD->ha_cage_code,5);
	cagecdxh.arr[5]='\0';
	cagecdxh.len=5;
	strncpy((char *) eiacodxa.arr,CNTRL_RCD->ha_eiac,10);
	eiacodxa.len=10;
	strncpy((char *) hg_03lsaconxb.arr,CNTRL_RCD->hg_lcn,18);
	hg_03lsaconxb.arr[18]='\0';
	hg_03lsaconxb.len=18;
	strncpy((char *) hg_03altlcnxb.arr,CNTRL_RCD->hg_alc,2);
	hg_03altlcnxb.arr[2]='\0';
	hg_03altlcnxb.len=2;

	errcode=fetch_f18_eff(CNTRL_RCD,SEGMNT03);

	return(errcode);		
}

EXEC SQL DECLARE effecty_f18_csr CURSOR for
	select distinct	hgx2.refnumha,
    	   	hgx2.cagecdxh,
    	   	hgx2.eiacodxa,
    	   	model,
		to_char(efffrom,'0009'),
		to_char(effto,'0009')
	from slic2b20.f18_hgx01a hgx2	     
	    where hgx2.refnumha = :refnumha
	     and hgx2.cagecdxh  = :cagecdxh
	     and hgx2.eiacodxa = :eiacodxa
	     and hgx2.lcntypxb   = 'P'
	     and hgx2.lsaconxb = :hg_03lsaconxb
	     and hgx2.altlcnxb = :hg_03altlcnxb
	     and hgx2.can_int = 0
	union
	select distinct	hpx2.refnumha,
    	   	hpx2.cagecdxh,
    	   	hpx2.eiacodxa,
    	   	mdlhp,    
		to_char(uoefffrm,'0009'),
		to_char(uoeffto,'0009')
	from slic2b20.f18_hpx01a hpx2  
 	   where hpx2.refnumha = :refnumha
	     and hpx2.cagecdxh = :cagecdxh
	     and hpx2.eiacodxa = :eiacodxa
	     and hpx2.lcntypxb  = 'P'
	     and hpx2.lsaconxb = :hg_03lsaconxb
	     and hpx2.altlcnxb = :hg_03altlcnxb
	     and hpx2.can_int = 0
	order by 1,2,3,4,5,6;
		
static int     fetch_f18_eff(struct cntrl_rcd *CNTRL_RCD,struct prtsc03 *SEGMNT03)

{
	char    spaces[]={"                                        "};
	int     errcode=0;
	int	fetched_row=0;
	int	fetched_ctr=0;

	#if DEBUG
		printf("\nfetch_f18_eff");
		printf("\nrefnumha (%s) (%d) (%d)",(char *) refnumha.arr, refnumha.len, strlen((char *) refnumha.arr));
		printf("\ncagecdxh (%s) (%d) (%d)",(char *) cagecdxh.arr,cagecdxh.len,strlen((char *) cagecdxh.arr));
		printf("\neiacodxa (%s) (%d) (%d)",(char *) eiacodxa.arr,eiacodxa.len,strlen((char *) eiacodxa.arr));
		printf("\nlsaconxb (%s) (%d) (%d)",(char *) hg_03lsaconxb.arr,hg_03lsaconxb.len, strlen((char *) hg_03lsaconxb.arr));
		printf("\naltlcnxb (%s) (%d) (%d)",(char *) hg_03altlcnxb.arr,hg_03altlcnxb.len,strlen((char *) hg_03altlcnxb.arr));
	#endif

	EXEC SQL OPEN effecty_f18_csr;

	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			errcode=initlze_segmnt03_host_var();

			EXEC SQL FETCH effecty_f18_csr
			  into :hgx_refnumha,
				:hgx_cagecdxh,
				:hg_eiacodxa,
				:series_cd:series_cd_i,
			  	:efffrom:efffrom_i,
			  	:effto:effto_i;
			if (sqlca.sqlcode == FND)
			{
				errcode=initlze_segmnt03(SEGMNT03);
				fetched_ctr++;
				if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
				{
					strncpy(SEGMNT03->ref_no,(char *) refnumha.arr,refnumha.len);
					strncpy(SEGMNT03->cage_code,(char *) cagecdxh.arr,cagecdxh.len);
				}
				else
				{
					if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
					{
						strncpy(SEGMNT03->ref_no,CNTRL_RCD->hb_ref_no,32);
						strncpy(SEGMNT03->cage_code,CNTRL_RCD->hb_cage_code,5);
					}
					else
					{
						printf("\nfetch_f18_eff");
						printf("\nUnable to determine HA/HB Record Type");
						printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
						printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
						printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
						printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
						printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
						printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
						printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
						printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
						errcode=1200;
						return(errcode);
					}
				}
				
				#if DEBUG
					printf("\nfetch_f18_eff - Display Info");
					printf("\nmodel (%c)",series_cd);
				#endif

				strncpy(SEGMNT03->prtsc03a,"03",2);
				strncpy(SEGMNT03->hg_end_item_acrnym,CNTRL_RCD->mdl_acft_prf,10);
				strncpy(SEGMNT03->hg_lsaconxb,CNTRL_RCD->hg_lcn,18);
				strncpy(SEGMNT03->hg_alt_lsa,CNTRL_RCD->hg_alc,2);
				SEGMNT03->mdl_instld_on_eff=series_cd;
				if (strncmp((char *) efffrom.arr," 9999",5)==0)
				{
					strncpy(SEGMNT03->from_eff," 0000",5);
				}
				else
				{
					strncpy(SEGMNT03->from_eff,(char *) efffrom.arr,efffrom.len);
				}
				
				strncpy(SEGMNT03->to_eff,(char *) effto.arr,effto.len);

				errcode=build_f18_prtsc03_rcd(CNTRL_RCD,SEGMNT03);
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
					if (fetched_ctr > 0)
					{
					}
					else
					{
						CNTRL_RCD->valid_application = 'N';
					}
				}
				else
				{
					printf("\nFUNCTION: fetch_eff");
					printf("\n\tFETCH Data Failure");
					printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
					printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
					printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
					printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
					printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
					printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
					printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					errcode=1201;
					btchslpf_dberr();
					
				}
			}
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			CNTRL_RCD->valid_application = 'N';
		}
		else
		{
			printf("\nFUNCTION: fetch_eff");
			printf("\n\tOpen Cursor Failure");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1202;
			btchslpf_dberr();
			
		}
	}

	EXEC SQL CLOSE effecty_f18_csr;
	
	return(errcode);
}
/*

	This is the main processing function for building the
	PROOF interface Record.
	*/

static int     build_f18_prtsc03_rcd(struct cntrl_rcd *CNTRL_RCD,struct prtsc03 *SEGMNT03)

{
	int	errcode=0;
	char    spaces[]={"                                        "};
	int	i=0;
	char	outData[500];


	#if DEBUG
		printf("\nbuild_f18_prtsc03_rcd");
	#endif

	for (i=0;i<500;i++)
	{
		outData[i]=' ';
	}
	
	SEGMNT03->prtsc03_eof='\0';
	SEGMNT03->prtsc03_newline='\n';
	#if DEBUG
		printf("\nSegmnt 03 (%s)",SEGMNT03);
	#endif
	memset(outData,'\0',sizeof(outData));
	memcpy(outData,SEGMNT03,sizeof(SEGMNT03));
	errcode=write_f18_rcd((char *) &outData,CNTRL_RCD);
	
	return(errcode);
}
/*
 **************************************************************************
 *  PROGRAM NAME: btchspf1804.pc
 *
 *  PURPOSE: This application qualifies the PROOF Information being processed
 *          against the 1388 Tables.  
 *
 *  INPUTS:   N/A
 *            
 *           
 *
 *  OUTPUTS:  N/A 
 *            
 *           
 *
 *  CHANGE HISTORY:
 *   REV     DATE    Programmer                 CHANGE
 *   ---  --------   ----------------------     ------
 *    00  05/24/1996 Original Author                Initial coding 
 *    01  08/13/1998 Original Author                Converted Program to use SLIC
 *   						Tailor Tables.*
 **************************************************************************
*/

EXEC SQL BEGIN DECLARE SECTION;

/*	PROOF HOST VARIABLES   */

	varchar	hpx_refnumha[33];
	varchar	hpx_cagecdxh[6];
	short	hpx_cagecdxh_i;
	varchar	hpx_eiacodxa[11];
	short	hpx_eiacodxa_i;
	varchar	rsrefno[33];
	short	rsrefno_i;
	char	rsind;
	short	rsind_i;
	varchar	canumbhp[17];
	short	canumbhp_i;
	varchar	repsupid[3];
	short	repsupid_i;

EXEC SQL END DECLARE SECTION;

static int	create_f18_04(struct cntrl_rcd *CNTRL_RCD,struct prtsc04 *SEGMNT04) 

{

	int	errcode=0;

	#if DEBUG
		printf("\ncreate_f18_04");
	#endif
	
        strncpy((char *) refnumha.arr,CNTRL_RCD->ha_ref_no,32);
	refnumha.arr[32]='\0';
	refnumha.len = (unsigned short) strlen((char *) refnumha.arr);
	strncpy((char *) cagecdxh.arr,CNTRL_RCD->ha_cage_code,5);
	cagecdxh.arr[5]='\0';
	cagecdxh.len=5;
	strncpy((char *) eiacodxa.arr,CNTRL_RCD->ha_eiac,10);
	eiacodxa.arr[10]='\0';
	eiacodxa.len = (unsigned short) strlen((char *) eiacodxa.arr);

	errcode=get_f18_supsdure_info(CNTRL_RCD,SEGMNT04);

	return(errcode);		
}

/*
	The following Function select the supersedure information for the
	Part Number in question
				*/

EXEC SQL DECLARE supsdure_f18_csr CURSOR for
	select distinct refnumha,
		cagecdxh,
		eiacodxa,
		rsrefno,
		rsind,
		canumbhp,
		repsupid
	   from slic2b20.f18_hpx01 hpx01
	     where
		    hpx01.can_int=0
		and hpx01.refnumha = :refnumha	
		and hpx01.cagecdxh = :cagecdxh
		and hpx01.eiacodxa = :eiacodxa
		and hpx01.lcntypxb = 'P'
		and rsind in ('R','S');

static int	get_f18_supsdure_info(struct cntrl_rcd *CNTRL_RCD, struct prtsc04 *SEGMNT04)
{
	int	errcode=0;
		
	#if DEBUG
		printf("\nget_f18_supsdure_info");
		printf("\nrefnumha (%s) (%d) (%d)",(char *) refnumha.arr,strlen((char *) refnumha.arr),refnumha.len);
		printf("\ncagecdxh (%s) (%d) (%d)",(char *) cagecdxh.arr,strlen((char *) cagecdxh.arr),cagecdxh.len);
		printf("\neiacodxa (%s) (%d) (%d)",(char *) eiacodxa.arr,strlen((char *) eiacodxa.arr),eiacodxa.len);
	#endif

	EXEC SQL OPEN supsdure_f18_csr;

	if (sqlca.sqlcode == FND)
	{
		errcode=fetch_f18_supsdure_info(CNTRL_RCD,SEGMNT04);
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
		}
		else
		{
			printf("\nget_f18_supsdure_info");
			printf("\nUnable to Open Cursor");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1300;
			btchslpf_dberr();
		}
	}

	EXEC SQL CLOSE supsdure_f18_csr;

	return(errcode);
}

static int	fetch_f18_supsdure_info(struct cntrl_rcd *CNTRL_RCD, struct prtsc04 *SEGMNT04)
{
	int	errcode=0;
	int	fetched_row=0;
	int	fetched_ctr=0;
	char	spaces[]={"                                        "};
	char	outData[500];
	int	i;
		
	#if DEBUG
		printf("\nfetch_f18_supsdure_info");
	#endif

	while(!fetched_row)
	{
		errcode=initlze_segmnt04_host_var();

		EXEC SQL FETCH supsdure_f18_csr into
			:hpx_refnumha,
			:hpx_cagecdxh:hpx_cagecdxh_i,
			:hpx_eiacodxa:hpx_eiacodxa_i, 
			:rsrefno:rsrefno_i,
			:rsind:rsind_i,
			:canumbhp:canumbhp_i,
			:repsupid:repsupid_i;

		if (sqlca.sqlcode == FND)
		{
			fetched_ctr++;
			errcode=initlze_segmnt04(SEGMNT04);
			if (hpx_cagecdxh_i == 0)
			{
			}
			else
			{
				strncpy((char *) hpx_cagecdxh.arr,spaces,5);
			}
			if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
			{
				strncpy(SEGMNT04->ref_no,(char *) refnumha.arr,refnumha.len);
				strncpy(SEGMNT04->cage_code,(char *) cagecdxh.arr,cagecdxh.len);
			}
			else
			{
				if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
				{
					strncpy(SEGMNT04->ref_no,CNTRL_RCD->hb_ref_no,32);
					strncpy(SEGMNT04->cage_code,CNTRL_RCD->hb_cage_code,5);
				}
				else
				{
					printf("\nfetch_f18_supsdure_info");
					printf("\nUnable to determine HA/HB Record Type");
					printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
					printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
					printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
					printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
					printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
					printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
					printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
					printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
					errcode=1301;
					return(errcode);
				}
			}
			strncpy(SEGMNT04->hg_end_item_acrnym,CNTRL_RCD->mdl_acft_prf,10);
			strncpy(SEGMNT04->prtsc04a,"04",2);
			if (rsrefno_i == 0)
			{
				strncpy(SEGMNT04->hpx_replcng_prt_no,(char *) rsrefno.arr,rsrefno.len);
			}
			else
			{
				strncpy(SEGMNT04->hpx_replcng_prt_no,spaces,32);
			}
			if (rsind_i == 0)
			{
				SEGMNT04->hpx_replcng_indctr=rsind;
			}
			else
			{
				SEGMNT04->hpx_replcng_indctr=' ';
			}
			if (canumbhp_i == 0)
			{
				strncpy(SEGMNT04->hpx_replcng_chng_authrty_no,(char *) canumbhp.arr,canumbhp.len);
			}
			else
			{
				strncpy(SEGMNT04->hpx_replcng_chng_authrty_no,spaces,15);
			}
			if (repsupid_i == 0)
			{
				strncpy(SEGMNT04->hpx_replcng_intrchng_code,(char *) repsupid.arr,repsupid.len);
			}
			else
			{
				strncpy(SEGMNT04->hpx_replcng_intrchng_code,spaces,2);
			}
		
			SEGMNT04->prtsc04_eof='\0';
			SEGMNT04->prtsc04_newline='\n';

			for (i=0;i<500;i++)
			{
				outData[i]=' ';
			}
	
			#if DEBUG
				printf("\nSegmnt 04 (%s)",SEGMNT04);
			#endif
			memset(outData,'\0',sizeof(outData));
			memcpy(outData,SEGMNT04,sizeof(SEGMNT04));
			errcode=write_f18_rcd((char *) &outData,CNTRL_RCD);
		}
		else
		{
			fetched_row=1;
			CNTRL_RCD->built_04='Y';
			if (sqlca.sqlcode == NOT_FND)
			{
			}
			else
			{
				printf("\nfetch_f18_supsdure_info");
				printf("\nUnable to Open Cursor");
				printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
				printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
				printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
				printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
				printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
				printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
				printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
				CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
				errcode=1302;
				btchslpf_dberr();
			}
		}
	}

	return(errcode);
}
/*
 **************************************************************************
 *  PROGRAM NAME: btchspf1805.pc
 *
 *  PURPOSE: This application qualifies the PROOF Information being processed
 *          against the 1388 Tables.  
 *
 *  INPUTS:   N/A
 *            
 *           
 *
 *  OUTPUTS:  N/A 
 *            
 *           
 *
 *  CHANGE HISTORY:
 *   REV     DATE    Programmer                 CHANGE
 *   ---  --------   ----------------------     ------
 *    00  05/24/1996 Original Author                Initial coding 
 *    01  08/13/1998 Original Author                Converted Program to use SLIC
 *   						Tailor Tables.*
 **************************************************************************
*/
EXEC SQL BEGIN DECLARE SECTION;

/*	PROOF HOST VARIABLES   */

	varchar	hd_refnumha[33];
	varchar	hd_cagecdxh[6];
	varchar	fiscyrhd[3];
	short	fiscyrhd_i;
	varchar	uiprichd[12];
	short	uiprichd_i;

EXEC SQL END DECLARE SECTION;

static int	create_f18_05(struct cntrl_rcd *CNTRL_RCD,struct prtsc05 *SEGMNT05) 

{

	int	errcode=0;

	#if DEBUG
		printf("\ncreate_f18_05");
	#endif
	
        strncpy((char *) refnumha.arr,CNTRL_RCD->ha_ref_no,32);
	refnumha.arr[32]='\0';
	refnumha.len=32;
	strncpy((char *) cagecdxh.arr,CNTRL_RCD->ha_cage_code,5);
	cagecdxh.arr[5]='\0';
	cagecdxh.len=5;

	errcode=get_f18_pricing_info(CNTRL_RCD,SEGMNT05);

	return(errcode);		
}

EXEC SQL DECLARE pricing_f18_csr CURSOR for
	select refnumha,
		cagecdxh,
		fiscyrhd,
		to_char(uiprichd,'00000000V09')
		from slic2b20.f18_hd slic_hd
		where slic_hd.refnumha = :refnumha
		  and slic_hd.cagecdxh = :cagecdxh
		  and fiscyrhd > ' '
		  and prouiphd = 'Y'
		  and can_int = 0;

static int	get_f18_pricing_info(struct cntrl_rcd *CNTRL_RCD, struct prtsc05 *SEGMNT05)
{
	int	errcode=0;
		
	#if DEBUG
		printf("\nget_f18_pricing_info");
		printf("\nPart Number (%s)",(char *) refnumha.arr);
		printf("\nCage (%s)",(char *) cagecdxh.arr);
	#endif

	EXEC SQL OPEN pricing_f18_csr;

	if (sqlca.sqlcode == FND)
	{
		errcode=fetch_f18_pricing_info(CNTRL_RCD,SEGMNT05);
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
		}
		else
		{
			printf("\nget_f18_pricing_info");
			printf("\nUnable to Open Cursor");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1500;
			btchslpf_dberr();
		}
	}

	EXEC SQL CLOSE pricing_f18_csr;

	return(errcode);
}

static int	fetch_f18_pricing_info(struct cntrl_rcd *CNTRL_RCD, struct prtsc05 *SEGMNT05)
{
	int	errcode=0;
	char	spaces[]="                                ";
	int	fetched_row=0;
	int	i=0;
	char	outData[500];
		
	#if DEBUG
		printf("\nfetch_f18_pricing_info");
	#endif

	while(!fetched_row)
	{
		errcode=initlze_segmnt05_host_var();
		EXEC SQL FETCH pricing_f18_csr into
			:hd_refnumha,
			:hd_cagecdxh,
			:fiscyrhd,
			:uiprichd;

		#if DEBUG
			printf("\nfetch_f18_pricing_info - Display Prices");
			printf("\nSQLCODE (%d)",sqlca.sqlcode);
			printf("\nPart Number (%s)",(char *) refnumha.arr);
			printf("\nCage (%s)",(char *) cagecdxh.arr);
		#endif
		if (sqlca.sqlcode == FND)
		{
			#if DEBUG
				printf("\nfetch_f18_pricing_info - Display Prices");
				printf("\nUnit Prices (%s)",(char *) uiprichd.arr);
				printf("\nUnit Price I (%d)",uiprichd_i);
			#endif
			if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
			{
				strncpy(SEGMNT05->ref_no,(char *) hd_refnumha.arr,hd_refnumha.len);
				strncpy(SEGMNT05->cage_code,(char *) hd_cagecdxh.arr,hd_cagecdxh.len);
			}
			else
			{
				if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
				{
					strncpy(SEGMNT05->ref_no,CNTRL_RCD->hb_ref_no,32);
					strncpy(SEGMNT05->cage_code,CNTRL_RCD->hb_cage_code,5);
				}
				else
				{
					printf("\nfetch_f18_pricing_info");
					printf("\nUnable to determine HA/HB Record Type");
					printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
					printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
					printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
					printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
					printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
					printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
					printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
					printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
					errcode=1501;
					return(errcode);
				}
			}
			strncpy(SEGMNT05->prtsc05a,"05",2);
			strncpy(SEGMNT05->hg_end_item_acrnym,CNTRL_RCD->mdl_acft_prf,10);
			strncpy(SEGMNT05->hd_fiscal_year,(char *) fiscyrhd.arr,fiscyrhd.len);
			strncpy(SEGMNT05->hd_unit_issue_price,(char *) uiprichd.arr,uiprichd.len);
			SEGMNT05->hd_unit_issue_price[10]=' ';			for (i=0;i<500;i++)
			{
				outData[i]=' ';
			}
			SEGMNT05->prtsc05_eof='\0';
			SEGMNT05->prtsc05_newline='\n';
			#if DEBUG
				printf("\nSegmnt 05 (%s)",SEGMNT05);
			#endif
			memset(outData,'\0',sizeof(outData));
			memcpy(outData,SEGMNT05,sizeof(SEGMNT05));
			errcode=write_f18_rcd((char *) &outData,CNTRL_RCD);
		}
		else
		{
			CNTRL_RCD->built_05='Y';
			fetched_row=1;
			if (sqlca.sqlcode == NOT_FND)
			{
			}
			else
			{
				printf("\nfetch_f18_pricing_info");
				printf("\nUnable to Open Cursor");
				printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
				printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
				printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
				printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
				printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
				printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
				printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
				CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
				errcode=1502;
				btchslpf_dberr();
			}
		}
	}

	return(errcode);
}
/*

		*/
static int	initlze_segmnt0102(struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02)
{
	int	errcode=0;
	char	spaces[]={"                                        "};

	#if DEBUG
		printf("\ninitlze_segmnt0102");
	#endif
	strncpy(SEGMNT01->ref_no,spaces,32);
	strncpy(SEGMNT01->cage_code,spaces,5);
	strncpy(SEGMNT01->filler,spaces,10);
	strncpy(SEGMNT01->ha_item_nme,spaces,19);
	strncpy(SEGMNT01->ha_prod_lead_time,spaces,4);
	strncpy(SEGMNT01->hax_sct_lead_time,spaces,2);
	strncpy(SEGMNT01->ha_unit_issue,spaces,2);
	SEGMNT01->ha_physcl_secrty=' ';
	SEGMNT01->ha_shlf_life=' ';
	strncpy(SEGMNT01->hf_qup,spaces,3);
	SEGMNT01->hax_sct_tst_reqd_flag=' ';
	strncpy(SEGMNT01->hax_sct_compltn_date,spaces,10);
	strncpy(SEGMNT01->hax_sct_authrztn_no,spaces,15);
	strncpy(SEGMNT01->hax_ps_ind,spaces,3);
	strncpy(SEGMNT01->hax_ps_scd_no,spaces,22);
	SEGMNT01->hb_arn_rncc=' ';
	strncpy(SEGMNT01->hb_arn_ref_no,spaces,32);
	strncpy(SEGMNT01->hb_arn_cage,spaces,32);
	SEGMNT01->ea_cfe_gfe=' ';
	SEGMNT01->se_item='N';
	SEGMNT01->proof_transfer_flag=' ';
	strncpy(SEGMNT02->ref_no,spaces,32);
	strncpy(SEGMNT02->cage_code,spaces,5);
	strncpy(SEGMNT02->hg_end_item_acrnym,spaces,10);
	strncpy(SEGMNT02->custmr,spaces,2);
	strncpy(SEGMNT02->ha_nsn_cog_code,spaces,2);
	SEGMNT02->ha_nsn_matl=' ';
	strncpy(SEGMNT02->ha_nsn_fsc,spaces,4);
	strncpy(SEGMNT02->ha_nsn_niin,spaces,9);
	strncpy(SEGMNT02->ha_nsn_spec_ident,spaces,2);
	strncpy(SEGMNT02->hax_nsn_cog_code,spaces,2);
	SEGMNT02->hax_nsn_matl=' ';
	strncpy(SEGMNT02->hax_nsn_fsc,spaces,4);
	strncpy(SEGMNT02->hax_nsn_niin,spaces,9);
	strncpy(SEGMNT02->hax_nsn_spec_ident,spaces,2);
	SEGMNT02->ha_aaplccha=' ';
	strncpy(SEGMNT02->hgx_suplyr_cage_code,spaces,5);

	return(errcode);
}
/*

		*/
static int	initlze_segmnt0102_host_var()
{
	int	errcode=0;
	char	spaces[]={"                                        "};

	#if DEBUG
		printf("\ninitlze_segmnt0102_host_var");
	#endif
	
	strncpy((char *) hb_refnumha.arr,spaces,32);
	strncpy((char *) ha_itnameha.arr,spaces,19);
	ha_physecha=' ';
	ha_shlifeha=' ';
	strncpy((char *) ha_unitisha.arr,spaces,2);
	strncpy((char *) ha_prdldtha.arr,spaces,4);
	strncpy((char *) ha_cognsnha.arr,spaces,2);
	strncpy((char *) ha_smmnsnha.arr,spaces,2);
	ha_matnsnha=' ';
	strncpy((char *) ha_fscnsnha.arr,spaces,4);
	strncpy((char *) ha_niinsnha.arr,spaces,9);
        ha_applccha=' ';;

	strncpy((char *) hax_sctldtme.arr,spaces,2);
	hax_scttstfg=' ';
	strncpy((char *) hax_sctcmpdt.arr,spaces,11);
	strncpy((char *) hax_sctauth.arr,spaces,16);
	strncpy((char *) hax_nicncog.arr,spaces,2);
	hax_nicnmcc=' ';
	strncpy((char *) hax_nicnfsc.arr,spaces,4);
	strncpy((char *) hax_nicnniin.arr,spaces,9);
	strncpy((char *) hax_nicnsmic.arr,spaces,2);
	strncpy((char *) hax_psind.arr,spaces,3);
	strncpy((char *) hax_psscdno.arr,spaces,22);
	hax_proof_transfer_flag=' ';
	
	strncpy((char *) addrefhb.arr,spaces,32);
	strncpy((char *) adcagehb.arr,spaces,5);
	arn_rncc=' ';
	arn_type_code=' ';
	
	strncpy((char *) hf_qtyupkhf.arr,spaces,3);
	
	se_cfegfeea=' ';
	se_item_ind='N';
	strncpy((char *) hgx_suplyrcd.arr,spaces,5);

	return(errcode);
}
/*

		*/
static int	initlze_segmnt03(struct prtsc03 *SEGMNT03)
{
	int	errcode=0;
	char    spaces[]={"                                        "};

	#if DEBUG
		printf("\ninitlze_segmnt03");
	#endif
	
	SEGMNT03->mdl_instld_on_eff=' ';
	strncpy(SEGMNT03->from_eff,spaces,5);
	strncpy(SEGMNT03->to_eff,spaces,5);
	
	return(errcode);
}

/*

		*/
static int	initlze_segmnt03_host_var()
{
	int	errcode=0;
	char    spaces[]={"                                        "};	
	
	#if DEBUG
		printf("\ninitlze_segmnt03_host_var");
	#endif
	
	series_cd=' ';
	strncpy((char *) efffrom.arr,spaces,5);
	strncpy((char *) effto.arr,spaces,5);
	
	return(errcode);
}	
/*

	*/
static int	initlze_segmnt04(struct prtsc04 *SEGMNT04)
{
	int	errcode=0;
	char	spaces[]="                                        ";

	#if DEBUG
		printf("\ninitlze-segmnt04");
	#endif	
	strncpy(SEGMNT04->ref_no,spaces,32);
	strncpy(SEGMNT04->cage_code,spaces,5);
	strncpy(SEGMNT04->hg_end_item_acrnym,spaces,10);
	SEGMNT04->hpx_replcng_indctr=' ';
	strncpy(SEGMNT04->hpx_replcng_prt_no,spaces,32);
	strncpy(SEGMNT04->hpx_replcng_chng_authrty_no,spaces,15);
	strncpy(SEGMNT04->hpx_replcng_intrchng_code,spaces,2);
	
	return(errcode);
}

/*
		*/
static int	initlze_segmnt04_host_var()
{
	int	errcode=0;
	char	spaces[]="                                        ";
	
	strncpy((char *) hpx_refnumha.arr,spaces,32);
	strncpy((char *) hpx_cagecdxh.arr,spaces,5);
	strncpy((char *) hpx_eiacodxa.arr,spaces,10);
	strncpy((char *) rsrefno.arr,spaces,32);
	rsind=' ';
	strncpy((char *) canumbhp.arr,spaces,15);
	strncpy((char *) repsupid.arr,spaces,2);
	
	return(errcode);
}
/*

		*/
static int	initlze_segmnt05(struct prtsc05 *SEGMNT05)
{
	int	errcode=0;
	char	spaces[]="                                ";
		
	#if DEBUG
		printf("\ninitlze_segmnt05");
	#endif
	
	strncpy(SEGMNT05->ref_no,spaces,32);
	strncpy(SEGMNT05->cage_code,spaces,5);
	strncpy(SEGMNT05->hg_end_item_acrnym,spaces,10);
	strncpy(SEGMNT05->hd_fiscal_year,spaces,2);
	strncpy(SEGMNT05->hd_unit_issue_price,spaces,10);
	
	return(errcode);
}

/*

		*/
static int	initlze_segmnt05_host_var()
{
	int	errcode=0;
	char	spaces[]="                                ";
		
	#if DEBUG
		printf("\ninitlze_segmnt05host_var");
	#endif
		
	strncpy((char *) hd_refnumha.arr,spaces,32);
	strncpy((char *) hd_cagecdxh.arr,spaces,5);
	strncpy((char *) fiscyrhd.arr,spaces,2);
	strncpy((char *) uiprichd.arr,spaces,10);
	
	return(errcode);
}
/*

			*/
static int	initlze_segmnt08(struct prtsc08 *SEGMNT08)
{
	int	errcode=0;
	char    spaces[]={"                                        "};

	#if DEBUG
		printf("\ninitlze_segmnt08");
	#endif

	strncpy(SEGMNT08->ref_no,spaces,32);
	strncpy(SEGMNT08->cage_code,spaces,5);
	strncpy(SEGMNT08->hg_alt_lsa,spaces,2);
	strncpy(SEGMNT08->hg_lsaconxb,spaces,18);
	strncpy(SEGMNT08->hg_08_icc,spaces,2);
	strncpy(SEGMNT08->hgx_suplyr_cage,spaces,5);
	strncpy(SEGMNT08->hg_qpei,spaces,5);
	strncpy(SEGMNT08->hgx_nha_ref_number,spaces,32);
	strncpy(SEGMNT08->hgx_nha_cage,spaces,5);

	return(errcode);
}

/*

			*/
static int	initlze_segmnt08_host_var()
{
	int	errcode=0;
	char    spaces[]={"                                        "};

	#if DEBUG
		printf("\ninitlze_segmnt08_host_var");
	#endif
	
	proof_transfer_flag=' ';

	strncpy((char *) hbx_addrefhb.arr,spaces,32);
	strncpy((char *) hbx_adcagehb.arr,spaces,5);
	strncpy((char *) hbx_refnumha.arr,spaces,32);
	strncpy((char *) hbx_cagecdxh.arr,spaces,5);

	strncpy((char *) eiacodxa.arr,spaces,10);
	strncpy((char *) lsaconxb.arr,spaces,18);
	strncpy((char *) altlcnxb.arr,spaces,02);
	strncpy((char *) qtypeihg.arr,spaces,05);
	strncpy((char *) itmcathg.arr,spaces,2);
	smrcodhg_pos1=' ';
	
	strncpy((char *) hgx_refnumha.arr,spaces,32);
	strncpy((char *) hgx_cagecdxh.arr,spaces,5);
	strncpy((char *) hgx_suplyrcd.arr,spaces,5);
	strncpy((char *) hgx_nharefno.arr,spaces,32);
	strncpy((char *) hgx_nhacgecd.arr,spaces,5);

	return(errcode);
}

static void getCurrentWorkingDirectory(void) {
#ifdef __linux__
		if (getcwd(cwd, sizeof(cwd)) == NULL) {
			perror("Unable to get current working directory\n");
			exit(4);
		}
#endif
#ifdef _WIN32
	{ 
		char *buffer = NULL;

		if ((buffer = _getcwd(NULL,0)) == NULL) {
			perror("Unable to get the current working directory\n");
			exit(4);
		} else {
			strcpy(cwd,buffer);
			free(buffer);
		}
	}
#endif
#ifdef DEBUG
	printf("cwd: %s",cwd);
#endif

}
static void getConfig(struct config_rcd *CONFIG_RCD) {
  FILE *fp;
#define MAXCHAR 512
#define MAXSTR 256
  char config_filename[MAXCHAR];
  char name[MAXSTR];
  char value[MAXSTR];

  char line[MAXSTR];
  char msg[MAXSTR];
  int i = 0;
  printf("cwd: %s\n",cwd);
  strcpy(config_filename,cwd);
  #ifdef __linux__
  strcat(config_filename,"/.config");
  #endif
  #ifdef _WIN32
  strcat(config_filename,"\\.config");
  #endif
  
  strcpy(CONFIG_RCD->userid,"ops$provftp");
  strcpy(CONFIG_RCD->password,"mvWQjcTPiuEO9e");
  strcpy(CONFIG_RCD->host,"stl_prodsup01");
  strcpy(CONFIG_RCD->output_file,"");
  strcpy(CONFIG_RCD->count_file,"");
  strcpy(CONFIG_RCD->count_file,"F18slicprf_cnt.dat");
  strcpy(CONFIG_RCD->model,"F18");


  fp = fopen(config_filename,"r");
  if (fp == NULL) {
    sprintf(msg,"Could not open file %s using defaults", config_filename);
	perror(msg);
	return;
  }

  while(fgets(line,MAXSTR, fp) != NULL) {
	for (i=0; i < MAXSTR; i++) {
		if (line[i] == '=') {
			strncpy(name,line,i);
			name[i] = '\0';
			strcpy(value, &line[i+1]);
			value[strlen(value) - 1] = '\0';
			break;
		}
	}
	if (i > MAXSTR) {
		sprintf(msg,"bad config string %s",line);
		perror(msg);
		exit(4);
	}
	if (strcmp(name,"userid") == 0) {
		strcpy(CONFIG_RCD->userid,value);
	} else if (strcmp(name,"password") == 0) {
		strcpy(CONFIG_RCD->password,value);
	} else if (strcmp(name,"host") == 0) {
		strcpy(CONFIG_RCD->host,value);
	} else if (strcmp(name,"outfile") == 0)  {
		strcpy(CONFIG_RCD->output_file,value);
	} else if (strcmp(name,"countfile") == 0) {
		strcpy(CONFIG_RCD->count_file,value);
	} else if (strcmp(name,"model") == 0) {
		strcpy(CONFIG_RCD->model,value);
	} else {
		sprintf(msg,"Unknown name/value pair: %s=%s\n", name,value);
		perror(msg);
	}	
  }
  fclose(fp);
}
static void showConfig(void) {
  printf("   userid: (%s)\n", CONFIG_RCD.userid);
  printf("     host: (%s)\n", CONFIG_RCD.host);
  printf("  outfile: (%s)\n", CONFIG_RCD.output_file);
  printf("countfile: (%s)\n", CONFIG_RCD.count_file);
  printf("    model: (%s)\n", CONFIG_RCD.model);
}