/* vim: syn=c:ff=unix:ts=2:sw=2:
 */
/*     Program -  Proof/SLIC HA Table Update Program */

/*
 **************************************************************************
 *  PROGRAM NAME: 
 *
 *  PURPOSE: This application pulls from SLIC/PROOF those items that are 
 *          candidates for moving to the IMS PROOF Data Base in SAMS.  This
 *          is the main program.  It runs for F-18, F-15 and T45.  Determination
 *          of which Program is being run is based upon a parmeter being passed.
 *          If the selected Part Number/Cage does not have the
 *          PROOF_TRANSFR_FLAG set to "Y" on the HAX, then it will be set.
 *        
 *
 *  INPUTS:
 *	    1.  Input Program Code (F18/F15/T45)
 *	    2.  Output Dataset Name for Extract Data
 *          3.  Output Dataset Name for Program Counts
 *           
 *
 *  OUTPUTS: 
 *	    1.  Output Extract Data
 *          2.  Output Program Counts
 *           
 *
 *  CHANGE HISTORY:
 *   REV     DATE    Programmer                 CHANGE
 *   ---  --------   ----------------------     ------
 *    00  5/27/1996  Original Author                Initial coding 
 *    01  1/23/1998  Original Author                Added F15 SLIC/PROOF
 *    02  6/11/1998  Original Author                Added AV8 SLIC/PROOF
 *    03  9/21/1998  Original Author                Added Harpoon SLIC/PROOF
 *    04  6/23/2005  David Hurshman             Modified query to pull HB data
 *    05  11/10/2014 Maintainer                  Removed COGNSN and MATNSN from the output file.
 *
 **************************************************************************
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <assert.h>
#ifdef __linux__
#include <unistd.h>
#endif

#ifdef _WIN32
#include "XGetopt.h"
#endif


#include "btchv8slpf_structs.h"
#include "btchv8slpf.h"

static FILE *outfp;
static char *oracle_instance ;

struct cnt_rcd {
	char	processed_mdl[10];
	char	filler1;
	char	process_cnt[9];
	char	filler2;
	char	process_date[19];
	char	nline;
	};

static char userid[30] ;
static char password[30]  ;


/* #define SQLCA_STORAGE_CLASS extern */
#define NOT_FND 1403
#define FND 0


EXEC SQL BEGIN DECLARE SECTION;

/*      Oracle User Sign-on Area   */
	varchar	UIDS[21];
	varchar	PWDS[21];

/*	PROOF HOST VARIABLES   */

	varchar	refno[33];
	varchar	cage_code[6];
	varchar	eiac[11];
	varchar	hg_lcn[19];
	varchar	hg_alc[3];
	int	num_eff;
	short	num_eff_i;
	
/*	1388 HAX Table Host Variables */

	char	proof_transfer_flag;
	short	proof_transfer_i;

	char	ha_cog_pos1;
	
/*	SLIC Extension HBX Table   */

	varchar	hbx_ref_no[33];
	varchar	hbx_cage_code[6];
	varchar	hbx_ha_ref_no[33];
	varchar	hbx_ha_cage_code[6];
			

/*	1388 HG Table Host variables */


	varchar	hg_eiac[11];
	varchar	lsaconxb[19];
	varchar	altlcnxb[3];
	varchar	qtypeihg[6];
	short	qtypeihg_i;
	varchar	itmcathg[3];
	short	itmcathg_i;
	char	smrcodhg_pos1;
	short	smrcodhg_pos1_i;
	
/*	1388 HG Table Host variables */

	varchar	xc_altlcnxb[3];

/*      HGX Extension Table Host Variables */

	varchar	hgx_ref_no[33];
	varchar	hgx_cage_code[6];
	varchar	hgx_suplyr_code[6];
	short	hgx_suplyr_code_i;
	varchar	hgx_nha[33];
	short	hgx_nha_i;
	varchar	hgx_nha_cage_code[6];
	short	hgx_nha_cage_code_i;

/*      SAMS PROOF Table 34 Host Variables */
	varchar	mdl_acft_prf[10];
	varchar cn[2];
	varchar prev_cn[2];

/*	PROOF HOST VARIABLES   */

	varchar	hd_refno[33];
	varchar	hd_cage_code[6];
	varchar	fiscyrhd[3];
	short	fiscyrhd_i;
	varchar	uiprichd[12];
	short	uiprichd_i;

/*	PROOF HOST VARIABLES   */

/*	1388 HG Table Host Variables */

	varchar	hg_03lcn[19];
	varchar	hg_03alc[3];

/*	Effectivity Host Variables   */

	char	series_cd;
	short	series_cd_i;
	varchar	ef_from[6];
	short	ef_from_i;
	varchar	ef_to[6];
	short	ef_to_i;

	/*	PROOF HOST VARIABLES   */

	varchar	 cage[6];
	varchar	 hb_refno[33];
	varchar	 hb_cage[6];
	
/*	1388 HA Table		*/

	varchar	ha_itnameha[20];
	short	ha_itnameha_i;
	char	ha_physecha;
	short	ha_physecha_i;
	char	ha_shlifeha;
	short	ha_shlifeha_i;
	varchar	ha_unitisha[3];
	short	ha_unitisha_i;
	varchar	ha_prdldtha[5];
	short	ha_prdldtha_i;
	varchar	ha_cognsnha[3];
	short	ha_cognsnha_i;
	varchar	ha_smmnsnha[3];
	short	ha_smmnsnha_i;
	char	ha_matnsnha;
	short	ha_matnsnha_i;
	varchar	ha_fscnsnha[5];
	short	ha_fscnsnha_i;
	varchar	ha_niinsnha[10];
	short	ha_niinsnha_i;
        char    ha_aaplccha;
        short	ha_applccha_i;


/*	1388 HAX Extension      */

	varchar	hax_sctldtme[3];
	short	hax_sctldtme_i;
	char	hax_scttstfg;
	short	hax_scttstfg_i;
	varchar	hax_sctcmpdt[11];
	short	hax_sctcmpdt_i;
	varchar	hax_sctauth[16];
	short	hax_sctauth_i;
	varchar	hax_nicncog[3];
	short	hax_nicncog_i;
	char	hax_nicnmcc;
	short	hax_nicnmcc_i;
	varchar	hax_nicnfsc[5];
	short	hax_nicnfsc_i;
	varchar	hax_nicnniin[10];
	short	hax_nicnniin_i;
	varchar	hax_nicnsmic[3];
	short  	hax_nicnsmic_i;
	varchar hax_psind[4];
	short	hax_psind_i;
	varchar hax_psscdno[23];
	short   hax_psscdno_i;
	char	intrfce_proof_transfer_flag;
	short	intrfce_proof_transfer_flag_i;

/*      1388 HB Table definition   */

	varchar arn_refnumha[33];
	short   arn_refnumha_i;
	varchar arn_cage[6];
	short   arn_cage_i;
	char    arn_rncc;
	short   arn_rncc_i;
	char	arn_type_code;
	short	arn_type_code_i;

		
/*	1388 HF Table		*/

	varchar	hf_qtyupkhf[4];
	short	hf_qtyupkhf_i;
	
/*      1388 EA Table definition   */

	char    se_cfegfeea;
	short   se_cfegfeea_i;

/*	1388 HG Extension Table Elements  */
	varchar	hgx_suplyrcd[6];
	short	hgx_suplyrcd_i;
	char	cat_resp_ind;
	char	se_item_ind;


/*	PROOF HOST VARIABLES   */

	varchar	hpx_ref_no[33];
	varchar	hpx_cage_code[6];
	short	hpx_cage_code_i;
	varchar	hpx_eiac[11];
	short	hpx_eiac_i;
	varchar	supsdure_refno[33];
	short	supsdure_ref_no_i;
	char	supsdure_ind;
	short	supsdure_ind_i;
	varchar	chng_athrty_no[17];
	short	chng_athrty_no_i;
	varchar	intrchng_code[3];
	short	intrchng_code_i;

	
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE pricing_av8b_csr CURSOR for
	select refnumha,
		cagecdxh,
		fiscyrhd,
		to_char(uiprichd,'00000000V09')
		from slic2b20.av8b_hd
		where refnumha = :refno
		  and cagecdxh = :cage_code
		  and prouiphd = 'Y'
		  and fiscyrhd > ' '
		  and can_int = 0;

EXEC SQL DECLARE selct_av8b_HA_candidate_info_csr CURSOR for 
    select distinct slic_hg.refnumha,
    	   slic_hg.cagecdxh,
    	   slic_hg.eiacodxa,
    	   slic_hg.lsaconxb,
    	   slic_hg.altlcnxb,
	   slic_hg.qtypeihg,
	   slic_hg.itmcathg,
	   substr(slic_hg.smrcodhg,1,1),
	   substr(slic_ha.cognsnha,1,2),
	   intrfce.proof_transfer_flag,
	   xax01.xaxprovmdl
       from slic2b20.av8b_ha slic_ha,
	    prov.av8b_intrfce_ext intrfce,
	    slic2b20.av8b_hg slic_hg,
	    slic2b20.av8b_xax01 xax01,
	    prov.ms2_sliceiac ms2_sliceiac
        where
	      slic_hg.can_int = 0
          and slic_hg.refnumha = slic_ha.refnumha
	  and slic_hg.can_int = slic_ha.can_int
          and slic_hg.cagecdxh = slic_ha.cagecdxh
	  and slic_hg.lcntypxb = 'P'
          and rtrim(slic_ha.refnumha) = intrfce.ref_no
          and slic_ha.cagecdxh = intrfce.cage_code
          and ha_hb_ind = 'HA'
	  and rtrim(xax01.xaxprovmdl) = ms2_sliceiac.eiac 
	  and xax01.eiacodxa = slic_hg.eiacodxa 
/*	  and slic_hg.refnumha='1136D320' */
	  and xax01.can_int = 0
             order by 1,2;

EXEC SQL DECLARE selct_av8b_HB_candidate_info_csr CURSOR for 
    select distinct slic_hb.addrefhb,
    	   slic_hb.adcagehb,
    	   refnumhb,
    	   cagecdhb,
    	   intrfce.proof_transfer_flag
    	 from prov.av8b_intrfce_ext intrfce,
    	      slic2b20.av8b_hb slic_hb 
        where
          intrfce.proof_transfer_flag = 'Y'
          and rtrim(slic_hb.addrefhb) = intrfce.ref_no
          and slic_hb.adcagehb = intrfce.cage_code
          and ha_hb_ind = 'HB'
	  and slic_hb.can_int = 0
/*	  and slic_hb.addrefhb='1092D064' */
             order by 1,2;


EXEC SQL DECLARE fetch_av8b_HB_candidate_info_csr CURSOR for 
    select distinct slic_hg.refnumha,
    	   slic_hg.cagecdxh,
    	   slic_hg.eiacodxa,
    	   slic_hg.lsaconxb,
    	   slic_hg.altlcnxb,
	   slic_hg.qtypeihg,
	   slic_hg.itmcathg,
	   ' ',
	   substr(slic_hg.smrcodhg,1,1),
	   xax01.xaxprovmdl
       from slic2b20.av8b_hg slic_hg,
	    slic2b20.av8b_xax01 xax01,
	    prov.ms2_sliceiac ms2_sliceiac
        where
	      slic_hg.can_int = 0
	  and slic_hg.lcntypxb = 'P'
	  and slic_hg.refnumha = :hbx_ha_ref_no
	  and slic_hg.cagecdxh = :hbx_ha_cage_code
	  and rtrim(xax01.xaxprovmdl) = ms2_sliceiac.eiac 
	  and xax01.eiacodxa = slic_hg.eiacodxa 
	  and xax01.can_int = 0
             order by 1,2;

EXEC SQL DECLARE cnt_av8b_effecty_csr CURSOR for
	select count(*)
	from slic2b20.av8b_hgx01a hgx2	     
	    where hgx2.refnumha    = :refno
	     and hgx2.cagecdxh  = :cage_code
	     and hgx2.eiacodxa = :eiac
	     and hgx2.lsaconxb = :hg_lcn
	     and hgx2.altlcnxb = :hg_alc
	     and hgx2.lcntypxb = 'P'
	     and hgx2.can_int = 0
	union
	select count(*)
	from slic2b20.av8b_hpx01a hpx2  
 	   where hpx2.refnumha = :refno
	     and hpx2.cagecdxh = :cage_code
	     and hpx2.eiacodxa = :eiac
	     and hpx2.lcntypxb  = 'P'
	     and hpx2.lsaconxb = :hg_lcn
	     and hpx2.altlcnxb = :hg_alc
	     and hpx2.can_int = 0
	     and hpx2.efftyphp = 'U';


EXEC SQL INCLUDE sqlca;


/*      Global Variables   */
static char	filename[100];
static char	cnt_filename[100];
static char	model[11];


/*	Time variables   */

static time_t	tnow;
static struct tm *tmstruct;

/*       Record Counts      */
static int	rcds_created=0;
static int  debug=0;

int main(int argc, char **argv)
{

	FILE	*fp_cntrcd;
	
	struct	cntrl_rcd CNTRL_RCD;
	struct	cnt_rcd CNT_RCD;
	int	errcode=0;
	int	numrecs=0;
	char	pgmtime[21];
#ifdef DEBUG
	printf("Running %s with debug\n", __FILE__);
#ifdef _WIN32
	fflush(stdout);
#endif
#endif
#ifdef __linux__ 
	oracle_instance = getenv("TWO_TASK");
	if (oracle_instance == NULL) {
		printf("\nYou must set environment variable TWO_TASK to the Oracle tnsname");
		fflush(stdout);
		exit(4);
	} else {
		printf("connecting to %s using TWO_TASK env var\n", oracle_instance);
	}
#elif _WIN32
	oracle_instance = getenv("LOCAL");
	if (oracle_instance == NULL) {
		printf("\nYou must set environment variable LOCAL to the Oracle tnsname");
		fflush(stdout);
		my_pause();
		exit(4);
	} else {
		printf("connecting to %s using LOCAL env var\n", oracle_instance);
	}
#else
	printf("\nThis application must run on Linux or Windows!");
	exit(4);
#endif



  printf("\n\n**************************************************************************");
  printf("\n%s compiled on %s at %s\n", __FILE__, __DATE__, __TIME__) ;
#ifdef DEBUG
  printf("\nDebug activated hit ENTER to continue:");
#ifdef _WIN32
  fflush(stdout);
#endif
#endif

	time(&tnow);
	tmstruct=localtime(&tnow);
	strftime(pgmtime,sizeof(pgmtime),"%m/%d/%Y-%H:%M:%S",tmstruct);
	printf("\nStarting Time (%s)\n",&pgmtime);

	errcode=get_btchsp_argmnt(argc, argv, &CNTRL_RCD);
	if (errcode != FND)
	{
		printf("\nInvalid command line switches");				
		printf("\n\t\tNo processing.\n");
		printf("\n\t\tUnable to prcess input");
		errcode=101;

	} else {	    
		if (debug) {
			printf("\n\tOracle Id\t(%s)",userid);
			printf("\n\tOracle Password\t(%s)",password);
		}
		errcode=btchslpf_signon(); 
		if (errcode == FND)
		{
			printf("\n\tProcessing Model\t(%s)",model);
			strncpy(CNT_RCD.processed_mdl,model,10);
			printf("\n\tOutput Data File\t(%s)",filename);
			printf("\n\tOutput Count File\t(%s)",cnt_filename);
			CNTRL_RCD.built_01='N';
			CNTRL_RCD.built_04='Y';
			CNTRL_RCD.built_05='Y';
			CNTRL_RCD.built_08='N';
			CNTRL_RCD.rcds_created=0;
	 		if (strcmp(model,"AV8       ") == 0)
			{
				errcode=qualify_av8b_proof_candidates((char *) &filename, &CNTRL_RCD);
			}
			else
			{
				printf("\n*********************************");
				printf("\n\t\tUnidentified input model (%s)",model);
				printf("\n\t\tLength of Model (%d)",strlen(model));
				printf("\n*********************************");
				errcode=100;
			}
		}
		else
		{
			printf("\n\t\tUnable to Connect to Oracle\n");
			btchslpf_dberr();
		}
		printf("\n\tNumber of records Created\t%d",rcds_created);
	}


	if (errcode == FND)
	{
		printf("\n\tWork Committed");
		EXEC SQL COMMIT WORK RELEASE;
	}
	else
	{
		printf("\n\tWork not Committed - Errcode (%d)",errcode);
		EXEC SQL ROLLBACK WORK RELEASE;
	}

	time(&tnow);
	tmstruct=localtime(&tnow);
	strftime(pgmtime,sizeof(pgmtime),"%m/%d/%Y-%H:%M:%S",tmstruct);
	sprintf(CNT_RCD.process_cnt,"%09d",rcds_created);
	strncpy(CNT_RCD.process_date,pgmtime,strlen(pgmtime));
	CNT_RCD.filler1=' ';
	CNT_RCD.filler2=' ';
	CNT_RCD.nline='\n';
	
	fp_cntrcd=(fopen(cnt_filename,"w"));
	
	numrecs=fwrite(&CNT_RCD,sizeof(CNT_RCD),1,fp_cntrcd);
	if (numrecs >0)
	{
	}
	else
	{
		printf("\nError Writing Number Record File");
	}
		
	printf("\nEnding Time (%s)\n",&pgmtime);

	exit(errcode);
}
static int	get_btchsp_argmnt(char argc, char **argv,struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;
	int gotUserId=0;
	int gotPassword=0;
	int gotOutputFile=0;
	int gotCntFile=0;
	int gotModel=0;

	char opt;
	char	spaces[]={"                                       "};
	while ((opt=getopt (argc,  argv,"a:b:c:A:B:C:du:p:")) !=EOF)
	{	
		switch (opt)
		{
			case 'a':
	                case 'A':		
				strncpy(filename,spaces,100);
				strncpy(filename,optarg,strlen(optarg));
				strncat(filename,spaces,100-strlen(filename));
				filename[strlen(optarg)]='\0'; 
				gotOutputFile = 1;
				break;		
			case 'b':
	                case 'B':		
				strncpy(cnt_filename,spaces,100);
				strncpy(cnt_filename,optarg,strlen(optarg));
				strncat(cnt_filename,spaces,100-strlen(cnt_filename));
				cnt_filename[strlen(optarg)]='\0'; 
				gotCntFile = 1;
			case 'c':
	                case 'C':		
				strncpy(model,spaces,10);
				strncpy(model,optarg,10);
				strncat(model,spaces,10-strlen(model));
				strncpy(CNTRL_RCD->mdl_acft_prf,model,10);
				model[10]='\0';
				gotModel = 1;
				break;
			case 'd':
			    debug = 1;
				break;
		    case 'u':
				strncpy(userid,optarg,strlen(optarg));
				userid[strlen(optarg)] = '\0';
				gotUserId = 1;
				break;
			case 'p':
				strncpy(password,optarg,strlen(optarg));
				password[strlen(optarg)] = '\0';
				gotPassword = 1;
				break;

			case '?':
				errcode=12;
				break;
		}
	}
	if (!gotOutputFile) {
		printf("Missing -aoutput_file\n");
		errcode=2;
	}
	if (!gotCntFile) {
		printf("Missing -bcount_file\n");
		errcode=4;
	}
	if (!gotModel) {
		printf("Missing -cmodel (AV8, T45, or F18)\n");
		errcode=8;
	}
	if (!gotUserId) {
		strcpy(userid,"ops$provftp");
		printf("Warning: using default Oracle id %s - override with -uOracleUserId\n", userid);
	}
	if (!gotPassword) {
		strcpy(password,"mvWQjcTPiuEO9e");
		printf("Warning using last know Oracle password for %s of %s - override with -pOraclePassword\n",userid,password);
	}
	return(errcode);
}
static int	btchslpf_signon(void)
{
	int	errcode=0;

	#if DEBUG
		printf("\nsignon");
		fflush(stdout);
	#endif

	strcpy((char *) UIDS.arr,userid);
	UIDS.len= (unsigned short) strlen((char *) UIDS.arr);
	UIDS.arr[UIDS.len] = '\0';

	strcpy((char *) PWDS.arr,password);
	PWDS.len= (unsigned short) strlen((char *) PWDS.arr);
	PWDS.arr[PWDS.len] = '\0';

	EXEC SQL CONNECT :UIDS IDENTIFIED BY :PWDS;
	
	#if DEBUG
		printf("\nExit signon");
		fflush(stdout);
	#endif

	return(sqlca.sqlcode);
}
static void	btchslpf_dberr()
{
	char msg_buf[200];
	size_t  buf_size=sizeof(msg_buf);
	size_t  msg_len;

	#if DEBUG
		printf("\nbtchslpf_dberr");
	#endif

	sqlglm(msg_buf, &buf_size, &msg_len);
	sqlglm(msg_buf, &buf_size, &msg_len);
	msg_buf[msg_len]='\0';
	
	printf("\n\nData Base Error has occurred:\n");
	printf("\n%70s\n",msg_buf);
	printf("\nOracle user id: <%s>\n", userid);
	printf("              : <%s>\n",password);
	printf("SQLCODE: %d\n",sqlca.sqlcode);
	printf("SQLERR MSG %s\n",sqlca.sqlerrm.sqlerrmc);
	
	EXEC SQL ROLLBACK RELEASE;
	return;
}

static int	qualify_av8b_proof_candidates(char *filename,struct cntrl_rcd *CNTRL_RCD) 

{
	struct	prtsc01 SEGMNT01;
	struct	prtsc02 SEGMNT02;
	struct	prtsc03 SEGMNT03;
	struct	prtsc04 SEGMNT04;
	struct	prtsc05 SEGMNT05;
	struct	prtsc08 SEGMNT08;

	int	errcode=0;
	char	spaces[]="                                        ";
	

	#if DEBUG
		printf("\nqualify_av8b_proof_candidates");
	#endif
	
	CNTRL_RCD->built_01='N';
	CNTRL_RCD->built_04='Y';
	CNTRL_RCD->built_05='Y';
	CNTRL_RCD->valid_application='N';
	strncpy(CNTRL_RCD->mdl_acft_prf,spaces,10);
	strncpy(CNTRL_RCD->cn,spaces,2);
	strncpy(CNTRL_RCD->ha_eiac,spaces,10);
	strncpy(CNTRL_RCD->ha_ref_no,spaces,32);
	strncpy(CNTRL_RCD->ha_cage_code,spaces,5);
	strncpy(CNTRL_RCD->hb_ref_no,spaces,32);
	strncpy(CNTRL_RCD->hb_cage_code,spaces,5);
	strncpy((char *) prev_cn.arr,spaces,2);

/*  Setup Oracle Host variables   */


	if ((outfp=fopen(filename,"w")) == NULL)
	{
		printf("\nCould not open Output file %s",filename);
		errcode=500;
	}
	else
	{
		strncpy(CNTRL_RCD->ha_hb_code,"HA",2);
		errcode=fetch_av8b_proof_HA_candidates(CNTRL_RCD,&SEGMNT01,&SEGMNT02,&SEGMNT03,&SEGMNT04,&SEGMNT05,&SEGMNT08); 
		if (errcode==0)
		{
			strncpy(CNTRL_RCD->ha_hb_code,"HB",2);
			errcode=select_av8b_proof_HB_candidates(CNTRL_RCD,&SEGMNT01,&SEGMNT02,&SEGMNT03,&SEGMNT04,&SEGMNT05,&SEGMNT08);  
		}
	}

	return(errcode);		
}


static int fetch_av8b_proof_HA_candidates(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02,struct prtsc03 *SEGMNT03,struct prtsc04 *SEGMNT04,struct prtsc05 *SEGMNT05,struct prtsc08 *SEGMNT08)

{
	
	int	errcode=0;
	int     fetched_row=0;
	int	fetched_ctr=0;
	char    spaces[]={"                                        "};
	char	*Leftstr();
	char	pgmtime[21];
	
	#if DEBUG
		printf("\nfetch_av8b_proof_HA_candidates");
	#endif
	
	time(&tnow);
	tmstruct=localtime(&tnow);
	strftime(pgmtime,sizeof(pgmtime),"%m/%d/%Y-%H:%M:%S",tmstruct);
	printf("\n\tStarting Gather of HA Candidates (%s)\n",&pgmtime);

	EXEC SQL OPEN selct_av8b_HA_candidate_info_csr;
	
	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			errcode=initlze_segmnt08_host_var();
			EXEC SQL FETCH selct_av8b_HA_candidate_info_csr
			   INTO :hgx_ref_no,
				:hgx_cage_code,
				:hg_eiac,
				:lsaconxb,
			   	:altlcnxb,
		   		:qtypeihg:qtypeihg_i,
				:itmcathg:itmcathg_i,
				:smrcodhg_pos1:smrcodhg_pos1_i,
				:ha_cog_pos1,
				:proof_transfer_flag:proof_transfer_i,
				:mdl_acft_prf;
			if (sqlca.sqlcode == FND)
			{
				errcode=check_av8b_cntrl(CNTRL_RCD);
				if (errcode == 0)
				{
					strncpy(SEGMNT03->hg_icc,spaces,2);
					strncpy(SEGMNT03->hg_icc,(char *) itmcathg.arr,itmcathg.len);

					strncpy(CNTRL_RCD->ha_eiac,(char *) hg_eiac.arr,hg_eiac.len);
					strncpy(CNTRL_RCD->ha_ref_no,(char *) hgx_ref_no.arr,hgx_ref_no.len);
					strncpy(CNTRL_RCD->ha_cage_code,(char *) hgx_cage_code.arr,hgx_cage_code.len);
					
					strncpy((char *) refno.arr,CNTRL_RCD->ha_ref_no,32);
					refno.arr[32]='\0';
					refno.len= (unsigned short) strlen((char *) refno.arr);
					strncpy((char *) cage_code.arr,CNTRL_RCD->ha_cage_code,5);
					cage_code.len=5;
					cage_code.arr[5]='\0';
					strncpy((char *) eiac.arr,(char *) hg_eiac.arr,hg_eiac.len);
					eiac.arr[10]='\0';
					eiac.len=10;
					strncpy(CNTRL_RCD->hg_lcn,(char *) lsaconxb.arr,lsaconxb.len);
					strncpy(CNTRL_RCD->hg_alc,(char *) altlcnxb.arr,altlcnxb.len);
					errcode=validate_av8b_hg_rcd(CNTRL_RCD);
					if (CNTRL_RCD->valid_application == 'Y')
					{
						errcode=get_av8b_hgx_data(CNTRL_RCD);
					}
					if (CNTRL_RCD->valid_application == 'Y')
					{
						fetched_ctr++;
						errcode=check_av8b_set_custmr_model(CNTRL_RCD,SEGMNT01,SEGMNT02,SEGMNT03,SEGMNT04,SEGMNT05,SEGMNT08);
						if(errcode==0) 
						{
						}
						else
						{
							fetched_row=1;
						}
					}
				}
				else
				{
				}
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
					if(fetched_ctr>0)
					{
					}
					else
					{
						printf("\nUnable to locate any Activity");
						CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
						errcode=1011;
					}
				}
				else
				{
					printf("\nfetch_proof_HA_candidates");
					printf("\n\tBad SQLCODE on Fetch of Cursor");
					printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
					printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
					printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
					printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
					printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
					printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
					printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					errcode=1000;
					btchslpf_dberr();
				}
			}			   	
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			printf("\nfetch_proof_HA_candidates");
			printf("\n\tUnable to locate information on Initial Select");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1001;
		}
		else
		{
			printf("\fetch_proof_HA_candidates");
			printf("\n\tBad SQLCODE on Open of Cursor");
			btchslpf_dberr();
			errcode=1002;
		}
	}		
			
	EXEC SQL CLOSE selct_av8b_HA_candidate_info_csr;
	return(errcode);
}

static int     select_av8b_proof_HB_candidates(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02,struct prtsc03 *SEGMNT03,struct prtsc04 *SEGMNT04,struct prtsc05 *SEGMNT05,struct prtsc08 *SEGMNT08)

{
	int	errcode=0;
	int     fetched_row=0;
	int	fetched_ctr=0;
	char    spaces[]={"                                        "};
	char	pgmtime[21];

	#if DEBUG
		printf("\nselect_av8b_proof_HB_candidates");
	#endif
	
	time(&tnow);
	tmstruct=localtime(&tnow);
	strftime(pgmtime,sizeof(pgmtime),"%m/%d/%Y-%H:%M:%S",tmstruct);
	printf("\n\tStarting Gather of HB Candidates (%s)\n",&pgmtime);
	
	CNTRL_RCD->built_01='N';
	CNTRL_RCD->built_04='Y';
	CNTRL_RCD->built_05='Y';
	CNTRL_RCD->valid_application='N';
	
	EXEC SQL OPEN selct_av8b_HB_candidate_info_csr;

	
	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			errcode=initlze_segmnt08_host_var();
			EXEC SQL FETCH selct_av8b_HB_candidate_info_csr
			   INTO :hbx_ref_no,
				:hbx_cage_code,
				:hbx_ha_ref_no,
				:hbx_ha_cage_code,
				:proof_transfer_flag:proof_transfer_i;

			if (sqlca.sqlcode == FND)
			{
				errcode=check_av8b_hb_cntrl(CNTRL_RCD);
				if (errcode == 0)
				{
					#if DEBUG
						printf("\nADDREF (%s)",(char *) hbx_ref_no.arr);
						printf("\nADCAGE (%s)",(char *) hbx_cage_code.arr);
						printf("\nREFNUMHB (%s)",(char *) hbx_ha_ref_no.arr);
						printf("\nADCAGE (%s)",(char *) hbx_ha_cage_code.arr);
					#endif
					strncpy(CNTRL_RCD->ha_ref_no,spaces,32);
					strncpy(CNTRL_RCD->ha_cage_code,spaces,5);
					strncpy(CNTRL_RCD->hb_ref_no,spaces,32);
					strncpy(CNTRL_RCD->hb_cage_code,spaces,5);
					strncpy(CNTRL_RCD->ha_ref_no,(char *) hbx_ha_ref_no.arr,hbx_ha_ref_no.len);
					strncpy(CNTRL_RCD->ha_cage_code,(char *) hbx_ha_cage_code.arr,hbx_ha_cage_code.len);
					strncpy(CNTRL_RCD->hb_ref_no,(char *) hbx_ref_no.arr,hbx_ref_no.len);
					strncpy(CNTRL_RCD->hb_cage_code,(char *) hbx_cage_code.arr,hbx_cage_code.len);
					errcode=fetch_av8b_proof_HB_candidates(CNTRL_RCD,SEGMNT01,SEGMNT02,SEGMNT03,SEGMNT04,SEGMNT05,SEGMNT08);
					if(errcode==0)
					{
					}
					else
					{
						fetched_row=1;
						return(errcode);
					}
				}
				else
				{
				}
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
				}
				else
				{
					printf("\nselect_proof_HB_candidates");
					printf("\n\tBad SQLCODE on Fetch of Cursor");
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					errcode=1003;
					btchslpf_dberr();
				}
			}			   	
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
		}
		else
		{
			printf("\nselect_proof_HB_candidates");
			printf("\n\tBad SQLCODE on Open of Cursor");
			errcode=1004;
			btchslpf_dberr();
		}
	}		
			
	EXEC SQL CLOSE selct_av8b_HB_candidate_info_csr;
	return(errcode);
}
/*	This function checks to see if the FETCHED HB REF_NO/CAGE CODE are equal to what was previously
	processed.  If not, then it allows the HB reference number to be processed.  If it has been
	processed, then will not process it again.

	Setting errcode equal to 1, signifies the HB REF_NO/CAGE CODE has been processed.

	      */
	      
static int	check_av8b_hb_cntrl(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;
	char    spaces[]={"                                        "};

	#if DEBUG
		printf("\ncheck_av8b_hb_cntrl - Before");
		printf("\nPrevious lcn pos1 (%c)",CNTRL_RCD->prev_lcn_pos1);
	#endif
	
	if ((strncmp((char *) hbx_ref_no.arr,CNTRL_RCD->hb_ref_no,32) == 0) &&
	   (strncmp((char *) hbx_cage_code.arr,CNTRL_RCD->hb_cage_code,5) == 0))
	{
	}
	else
	{
		errcode=0;
		strncpy(CNTRL_RCD->hb_ref_no,(char *) hbx_ref_no.arr,hbx_ref_no.len);
		strncpy(CNTRL_RCD->hb_cage_code,(char *) hbx_cage_code.arr,hbx_cage_code.len);
		CNTRL_RCD->built_01='N';
		CNTRL_RCD->built_04='Y';
		CNTRL_RCD->built_05='Y';
	}

	#if DEBUG
		printf("\ncheck_av8b_hb_cntrl - After");
		printf("\nPrevious lcn pos1 (%c)",CNTRL_RCD->prev_lcn_pos1);
	#endif

	return(errcode);
}

/*
	This function processing takes the information passed from the select_proof_HB_candidates
	checks it against the HA/HG table using the ARN_ITEM_REF_NO and ARN_ITEM_CAGE_CODE to determine
	which HA/HG information to use for the HBX REF_NO/CAGE CODE.

			*/
			

int     fetch_av8b_proof_HB_candidates(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02,struct prtsc03 *SEGMNT03,struct prtsc04 *SEGMNT04,struct prtsc05 *SEGMNT05,struct prtsc08 *SEGMNT08)

{
	int	errcode=0;
	int     fetched_row=0;
	int	fetched_ctr=0;
	char    spaces[]={"                                        "};
	char	*Leftstr();


	#if DEBUG
		printf("\nfetch_av8b_proof_HB_candidates");
		printf("\nADDREF (%s)",(char *) hbx_ref_no.arr);
		printf("\nADCAGE (%s)",(char *) hbx_cage_code.arr);
		printf("\nREFNUMHB (%s)",(char *) hbx_ha_ref_no.arr);
		printf("\nADCAGE (%s)",(char *) hbx_ha_cage_code.arr);
	#endif

	EXEC SQL OPEN fetch_av8b_HB_candidate_info_csr;
	
	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			EXEC SQL FETCH fetch_av8b_HB_candidate_info_csr
			   INTO :hgx_ref_no,
				:hgx_cage_code,
				:hg_eiac,
				:lsaconxb,
			   	:altlcnxb,
		   		:qtypeihg:qtypeihg_i,
				:itmcathg:itmcathg_i,
				:ha_cog_pos1,
				:smrcodhg_pos1:smrcodhg_pos1_i,
				:mdl_acft_prf;
			if (sqlca.sqlcode == FND)
			{
				errcode=check_av8b_cntrl(CNTRL_RCD);
				if (errcode == 0)
				{
					strncpy(SEGMNT03->hg_icc,(char *) itmcathg.arr,itmcathg.len);
					strncpy((char *) refno.arr,CNTRL_RCD->ha_ref_no,32);
					strncpy((char *) cage_code.arr,CNTRL_RCD->ha_cage_code,5);
					refno.arr[32]='\0';
					refno.len= (unsigned short) strlen((char *) refno.arr);
					cage_code.len=5;
					cage_code.arr[5]='\0';
					strncpy((char *) eiac.arr,(char *) hg_eiac.arr,hg_eiac.len);
					eiac.arr[10]='\0';
					eiac.len=10;
					strncpy(CNTRL_RCD->hg_lcn,(char *) lsaconxb.arr,lsaconxb.len);
					strncpy(CNTRL_RCD->hg_alc,(char *) altlcnxb.arr,altlcnxb.len);
					errcode=validate_av8b_hg_rcd(CNTRL_RCD);
					if (CNTRL_RCD->valid_application == 'Y')
					{
						errcode=get_av8b_hgx_data(CNTRL_RCD);
					}
					if (CNTRL_RCD->valid_application == 'Y')
					{
						fetched_ctr++;
						errcode=check_av8b_set_custmr_model(CNTRL_RCD,SEGMNT01,SEGMNT02,SEGMNT03,SEGMNT04,SEGMNT05,SEGMNT08);
						if (errcode==0)
						{
						}
						else
						{
							fetched_row=1;
						}
					}
				}
				else
				{
					fetched_row=1;
				}
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
					if(fetched_ctr>0)
					{
					}
					else
					{
						CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					}
				}
				else
				{
					printf("\fetch_proof_HB_candidates");
					printf("\n\tBad SQLCODE on Fetch of Cursor");
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					errcode=1005;
					btchslpf_dberr();
				}
			}			   	
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			printf("\nfetch_proof_HB_candidates");
			printf("\n\tUnable to locate information on Initial Select");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1006;
		}
		else
		{
			printf("\fetch_proof_HB_candidates");
			printf("\n\tBad SQLCODE on Open of Cursor");
			errcode=1007;
			btchslpf_dberr();
		}
	}		
			
	EXEC SQL CLOSE fetch_av8b_HB_candidate_info_csr;
	return(errcode);
}
static int     get_av8b_hgx_data(struct cntrl_rcd *CNTRL_RCD)
{
	
	int	errcode=0;
	
	#if DEBUG
		printf("\nget_av8b_hgx_data");
	#endif

	EXEC SQL 
	    select hgx.nharefno,
	  	   hgx.nhacgecd,
	   	   hgx.suplyrcd
	   	INTO :hgx_nha:hgx_nha_i,
		     :hgx_nha_cage_code:hgx_nha_cage_code_i,
		     :hgx_suplyr_code:hgx_suplyr_code_i
       		from slic2b20.av8b_hgx01 hgx
        	where
	      		hgx.can_int = 0
	  	    and hgx.lcntypxb = 'P'
	  	    and hgx.eiacodxa = :eiac
          	    and hgx.lsaconxb = :hg_lcn
          	    and hgx.altlcnxb = :hg_alc
          	    and hgx.refnumha = :refno
          	    and hgx.cagecdxh = :cage_code;
			
	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
		}
		else
		{
			if (sqlca.sqlcode == -2112)
			{
				strncpy((char *) hgx_nha.arr,"MULTIPLE NHA-UNABLE TO DETERMINE",32);
				hgx_nha.len=32;
				hgx_nha_i=0;
			}
			else
			{
				printf("\nget_av8b_hgx_data");
				printf("\n\tBad SQLCODE on Fetch of Cursor");
				printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
				printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
				printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
				printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
				printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
				printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
				printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
				CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
				errcode=1014;
				btchslpf_dberr();
			}
		}
	}
	
			
	return(errcode);
}
/*	This function checks to see if the FETCHED REF_NO/CAGE CODE are equal to what was previously
	processed.  If not, then it sets up previous information and resets the "built_??" indicators to
	"N".
	      */
static int	check_av8b_cntrl(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;

	#if DEBUG
		printf("\ncheck_av8b_cntrl - Before");
		printf("\nPrevious lcn pos1 (%c)",CNTRL_RCD->prev_lcn_pos1);
	#endif

	if ((strncmp((char *) hgx_ref_no.arr,CNTRL_RCD->ha_ref_no,32) == 0) &&
	   (strncmp((char *) hgx_cage_code.arr,CNTRL_RCD->ha_cage_code,5) == 0))
	{
	}
	else
	{
		strncpy(CNTRL_RCD->ha_ref_no,(char *) hgx_ref_no.arr,hgx_ref_no.len);
		strncpy(CNTRL_RCD->ha_cage_code,(char *) hgx_cage_code.arr,hgx_cage_code.len);
		CNTRL_RCD->built_01='N';
		CNTRL_RCD->built_04='Y';
		CNTRL_RCD->built_05='Y';
		CNTRL_RCD->prev_lcn_pos1=' ';
	}

	#if DEBUG
		printf("\ncheck_av8b_cntrl - Before");
		printf("\nPrevious lcn pos1 (%c)",CNTRL_RCD->prev_lcn_pos1);
	#endif

	return(errcode);
}

/*	This function checks to see if the information is a valid application.  It must have a "Y" on the
	PROOF_TRANSFER_FLAG on the HAX or Effectivity.  If neither of these conditions are true then this
	application is not processed.
	
	*/
	
static int	validate_av8b_hg_rcd(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;
	
	CNTRL_RCD->valid_application = 'N';

	#if DEBUG
		printf("\nvalidate_av8b_hg_rcd - BEFORE");
		printf("\nRef No (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nRef No (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nLCN (%s)",(char *) lsaconxb.arr);
		printf("\nEIAC (%s)",(char *) hg_eiac.arr);
		printf("\nValid Application Flag (%c)",CNTRL_RCD->valid_application);
		printf("\nPROOF Transfer Flag (%c)",proof_transfer_flag);
		printf("\nSMR Pos 1 (%c)",smrcodhg_pos1);
		printf("\nCOG Pos 1 (%c)",ha_cog_pos1);
	#endif	
	
	if (strncmp((char*)hg_eiac.arr,"AV8B",4) == 0)
	{
		if (proof_transfer_flag == 'Y')
		{
			CNTRL_RCD->valid_application = 'Y';
		}
		else
		{
			errcode=check_av8b_eff_exist(CNTRL_RCD);
			if (CNTRL_RCD->valid_application == 'Y')
			{
				if (smrcodhg_pos1_i == 0)
				{
					if ((smrcodhg_pos1 == 'P') &&
			   	   	    (strncmp(CNTRL_RCD->ha_cage_code,"76301",5)==0) &&
					    (ha_cog_pos1 == '9'))
					{
						CNTRL_RCD->valid_application = 'Y';
						#if DEBUG
							printf("\nSMRCODE P/COG 9/CAGE 76301 Validation");
						#endif	
					}
					else
					{
/*						if ((smrcodhg_pos1 == 'P') &&
					     	    (ha_cog_pos1 != '9'))  */
						if (smrcodhg_pos1 == 'P') 
						{
							#if DEBUG
								printf("\nSMRCODE P/COG 9 Validation");
							#endif	
							CNTRL_RCD->valid_application = 'Y';
						}
						else
						{
							#if DEBUG
								printf("\nSMRCODE/COG Validation #1 (%c)",CNTRL_RCD->valid_application);
							#endif	
							CNTRL_RCD->valid_application = 'N';
							#if DEBUG
								printf("\nSMRCODE/COG Validation #1 (%c)",CNTRL_RCD->valid_application);
							#endif	
						}
					}
				}
				else
				{
					#if DEBUG
						printf("\nValid Application Flag SMRCODE #2 (%c)",CNTRL_RCD->valid_application);
					#endif	
					CNTRL_RCD->valid_application='N';
					#if DEBUG
						printf("\nValid Application Flag SMRCODE #2 (%c)",CNTRL_RCD->valid_application);
						printf("\nNo SMRCODE Validation");
					#endif	
				}
			}
		}
	}	
	else
	{
		if ((strncmp((char*)hg_eiac.arr,"GR7",3) == 0)  ||
		    (strncmp((char*)hg_eiac.arr,"GR9",3) == 0) ||
		    (strncmp((char*)hg_eiac.arr,"T10",3) == 0) ||
		    (strncmp((char*)hg_eiac.arr,"T12",3) == 0))
		{
			#if DEBUG
				printf("\nSend based upon EIAC");
			#endif	
			CNTRL_RCD->valid_application = 'Y';
		}
		else
		{
			CNTRL_RCD->valid_application='N';
			#if DEBUG
				printf("\nEIAC Not mattched");
			#endif	
		}

	}
	
	#if DEBUG
		printf("\nvalidate_av8b_hg_rcd - AFTER");
		printf("\nRef No (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nRef No (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nLCN (%s)",(char *) lsaconxb.arr);
		printf("\nValid Application Flag (%c)",CNTRL_RCD->valid_application);
		printf("\nPROOF Transfer Flag (%c)",proof_transfer_flag);
	#endif	

	return(errcode);
}
/*



				*/

int	check_av8b_eff_exist(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;
	int	fetched_row=0;
	int	number_rows=0;
	
	strncpy((char *) hg_lcn.arr,CNTRL_RCD->hg_lcn,18);
	hg_lcn.arr[18]='\0';
	hg_lcn.len = (unsigned short) strlen((char *) hg_lcn.arr);
	strncpy((char *) hg_alc.arr,CNTRL_RCD->hg_alc,2);
	hg_alc.arr[2]='\0';
	hg_alc.len=2;

	#if DEBUG
		printf("\ncheck_av8b_eff_exist");
		printf("\nrefno (%s) (%d) (%d)",(char *) refno.arr,strlen((char *) refno.arr),refno.len);
		printf("\ncage_code (%s) (%d) (%d)",(char *) cage_code.arr,strlen((char *) cage_code.arr),cage_code.len);
		printf("\neiac (%s) (%d) (%d)",(char *) eiac.arr,strlen((char *) eiac.arr),eiac.len);
		printf("\nlcn (%s) (%d) (%d)",(char *) hg_lcn.arr,hg_lcn.len,strlen((char *) hg_lcn.arr));
		printf("\nlsaconxb (%s) (%d) (%d)",(char *) lsaconxb.arr,lsaconxb.len,strlen((char *) lsaconxb.arr));
		printf("\nalc (%s) (%d)",(char *) hg_alc.arr,hg_alc.len);
		printf("\nValid Application Flag (%c) ",CNTRL_RCD->valid_application);
	#endif

	EXEC SQL OPEN cnt_av8b_effecty_csr;

	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			EXEC SQL FETCH cnt_av8b_effecty_csr
			  into 	:num_eff:num_eff_i;

			if (sqlca.sqlcode == FND)
			{
				if (num_eff_i == 0)
				{
					if (num_eff > 0)
					{
						number_rows=number_rows+num_eff;
						CNTRL_RCD->valid_application = 'Y';
					}
					else
					{
					}
				}
				else
				{
				}
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
					if (number_rows > 0)
					{
					}
					else
					{
						CNTRL_RCD->valid_application = 'N';
					}
				}
				else
				{
					printf("\nFUNCTION: fetch_eff");
					printf("\n\tFETCH Data Failure");
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					errcode=1008;
					btchslpf_dberr();
				}
			}
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			CNTRL_RCD->valid_application = 'N';
		}
		else
		{
			printf("\nFUNCTION: fetch_eff");
			printf("\n\tOpen Cursor Failure");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1009;
			btchslpf_dberr();
			
		}
	}

	EXEC SQL CLOSE cnt_av8b_effecty_csr;
	
	#if DEBUG
		printf("\ncheck_av8b_eff_exist - Exit Function");
		printf("\nNumber Rows Effectvty (%d)",number_rows);
		printf("\nValid Application Flag (%c) ",CNTRL_RCD->valid_application);
	#endif
	
	return(errcode);
}
int	check_av8b_set_custmr_model(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02,struct prtsc03 *SEGMNT03,struct prtsc04 *SEGMNT04,struct prtsc05 *SEGMNT05,struct prtsc08 *SEGMNT08)
{
	int	errcode=0;
	int	fetched_row=0;
	int	fetched_ctr=0;
	char	current_lcn_pos1;
	
	#if DEBUG
		printf("\ncheck_av8b_set_custmr_model");
	#endif
	
	current_lcn_pos1=lsaconxb.arr[0]; 
			
/*	strncpy(CNTRL_RCD->mdl_acft_prf,"          ",10);
	strncpy(CNTRL_RCD->mdl_acft_prf,"AV8B      ",10); 
	CNTRL_RCD->built_01='N'; */
	CNTRL_RCD->built_04='Y';
	CNTRL_RCD->built_05='Y';
	
	if (strncmp((char*)hg_eiac.arr,"AV8B",4) == 0)
	{
		strncpy(SEGMNT02->custmr,"MC",2);
		strncpy(CNTRL_RCD->cn,"MC",2);
	}
	else
	{
		if ((strncmp((char*)hg_eiac.arr,"GR7",3) == 0)  ||
		    (strncmp((char*)hg_eiac.arr,"GR9",3) == 0) ||
		    (strncmp((char*)hg_eiac.arr,"T10",3) == 0) ||
		    (strncmp((char*)hg_eiac.arr,"T12",3) == 0))
		{
			strncpy(SEGMNT02->custmr,"UK",2);
			strncpy(CNTRL_RCD->cn,"UK",2);
		}
		else
		{
			strncpy(SEGMNT02->custmr,"\?\?",2);
		}
	}

	if (SEGMNT02->custmr[0] == '\?')
	{
	}
	else
	{
		errcode=gather_av8b_proof_data(CNTRL_RCD,SEGMNT01,SEGMNT02,SEGMNT03,SEGMNT04,SEGMNT05,SEGMNT08);
		if(errcode==0) 
		{
		}
	}

	return(errcode);
}

static int	gather_av8b_proof_data(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02,struct prtsc03 *SEGMNT03,struct prtsc04 *SEGMNT04,struct prtsc05 *SEGMNT05,struct prtsc08 *SEGMNT08)
{
	int	errcode=0;

	#if DEBUG
		printf("\ngather_av8b_proof_data");
	#endif

	if (CNTRL_RCD->built_01 == 'Y')
	{
	}
	else
	{
		errcode=create_av8b_0102(CNTRL_RCD,SEGMNT01,SEGMNT02);
	}

/*	if(errcode == 0)
	{
		errcode=create_av8b_03(CNTRL_RCD,SEGMNT03);
	}
	else
	{
	}  */

	if (CNTRL_RCD->built_04 == 'Y')
	{
	}
	else
	{
		if (errcode == 0)
		{
			errcode=create_av8b_04(CNTRL_RCD,SEGMNT04);
		}
		else
		{
		}
	}

	if (CNTRL_RCD->built_05 == 'Y')
	{
	}
	else
	{
		if (errcode == 0)
		{
			errcode=create_av8b_05(CNTRL_RCD,SEGMNT05);
		}
		else
		{
		}
	}

	if (errcode == 0)
	{
		errcode=build_av8b_prtsc08_rcd(SEGMNT08,CNTRL_RCD);
	}
	else
	{
	}
	
	#if DEBUG
		printf("\ngather_av8b_proof_data");
		printf("\nPrevious lcn pos1 (%c)",CNTRL_RCD->prev_lcn_pos1);
	#endif

	CNTRL_RCD->prev_lcn_pos1=lsaconxb.arr[0];

	#if DEBUG
		printf("\ngather_av8b_proof_data");
		printf("\nPrevious lcn pos1 (%c)",CNTRL_RCD->prev_lcn_pos1);
	#endif

	return(errcode);
}

/*

	This is the main processing function for building the
	PROOF interface Record.
	*/

static int     build_av8b_prtsc08_rcd(struct prtsc08 *SEGMNT08,struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;
	int	i=0;
	char    spaces[]={"                                        "};
	char	outData[500];

	#if DEBUG
		printf("\nbuild_av8b_prtsc08_rcd");
	#endif
	
	errcode=initlze_segmnt08(SEGMNT08);

	
	
	if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
	{
		strncpy(SEGMNT08->ref_no,(char *) hgx_ref_no.arr,hgx_ref_no.len);
		strncpy(SEGMNT08->cage_code,(char *) hgx_cage_code.arr,hgx_cage_code.len);
	}
	else
	{
		if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
		{
			strncpy(SEGMNT08->ref_no,CNTRL_RCD->hb_ref_no,32);
			strncpy(SEGMNT08->cage_code,CNTRL_RCD->hb_cage_code,5);
		}
		else
		{
			printf("\nUnable to determine HA/HB Record Type");
			printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
			errcode=1010;
			return(errcode);
		}
	}
/*	strncpy(SEGMNT08->hg_end_item_acrnym,CNTRL_RCD->mdl_acft_prf,10); */
	strncpy(SEGMNT08->hg_end_item_acrnym,(char *) mdl_acft_prf.arr,mdl_acft_prf.len);
	strncat(SEGMNT08->hg_end_item_acrnym,spaces,10-mdl_acft_prf.len);
	strncpy(SEGMNT08->prtsc08a,"08",2);
	strncpy(SEGMNT08->hg_alt_lsa,(char *) altlcnxb.arr,altlcnxb.len);
	strncpy(SEGMNT08->hg_lsaconxb,(char *) lsaconxb.arr,lsaconxb.len);
	if ((strncmp((char*)hg_eiac.arr,"GR7",3) == 0)  ||
	    (strncmp((char*)hg_eiac.arr,"GR9",3) == 0) ||
	    (strncmp((char*)hg_eiac.arr,"T10",3) == 0) ||
	    (strncmp((char*)hg_eiac.arr,"T12",3) == 0))
	{
		strncpy(SEGMNT08->hg_08_icc,"X ",2);
	}
	else
	{
		strncpy(SEGMNT08->hg_08_icc,(char *) itmcathg.arr,itmcathg.len);
	}
	if (hgx_suplyr_code_i == 0)
	{
		strncpy(SEGMNT08->hgx_suplyr_cage,(char *) hgx_suplyr_code.arr,hgx_suplyr_code.len);
	}
	else
	{
		strncpy(SEGMNT08->hgx_suplyr_cage,spaces,5);
	}
        if (qtypeihg_i == 0)
	{
		strncpy(SEGMNT08->hg_qpei,(char *) qtypeihg.arr,qtypeihg.len);
	}
	else
	{
		strncpy(SEGMNT08->hg_qpei,spaces,5);
	}
        if (hgx_nha_cage_code_i == 0)
	{
		strncpy(SEGMNT08->hgx_nha_cage,(char *) hgx_nha_cage_code.arr,hgx_nha_cage_code.len);
	}
	else
	{
		strncpy(SEGMNT08->hgx_nha_cage,spaces,5);
	}

       if (hgx_nha_i == 0)
       {
	       strncpy(SEGMNT08->hgx_nha_ref_number,(char *) hgx_nha.arr,hgx_nha.len);
       }
       else
       {
	       strncpy(SEGMNT08->hgx_nha_ref_number,spaces,32);
	}

	for (i=0; i<500; i++)
	{
		outData[i] = ' ';
	}

	SEGMNT08->prtsc08_eof='\0';
	SEGMNT08->prtsc08_newline='\n';
	#if DEBUG
		printf("\nSegmnt 08 (%s)",SEGMNT08);
	#endif
	assert(sizeof(outData)+1 >= sizeof(SEGMNT08));
	memset(outData,'\0',sizeof(outData));
	memcpy(outData,SEGMNT08,sizeof(SEGMNT08));
	errcode=write_av8b_rcd((char *) &outData,CNTRL_RCD);

	return(errcode);
}
/*
    
			  */
static int	write_av8b_rcd(char *outData,struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;

	#if DEBUG
		printf("\nwrite_av8b_rcd (%s) (%d)",outData,strlen(outData));
	#endif

	fwrite(outData,strlen(outData),1,outfp);
	rcds_created++;

	return(errcode);
}


static int	create_av8b_0102(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02) 

{

	int	errcode=0;

	#if DEBUG
		printf("\ncreate_av8b_0102");
	#endif
	
        strncpy((char *) refno.arr,CNTRL_RCD->ha_ref_no,32);
	refno.arr[32]='\0';
	refno.len= (unsigned short) strlen((char *) refno.arr);
	strncpy((char *) cage.arr,CNTRL_RCD->ha_cage_code,5);
	cage.arr[5]='\0';
	cage.len=5;
        strncpy((char *) hg_eiac.arr,CNTRL_RCD->ha_eiac,10);
	hg_eiac.arr[10]='\0';
	hg_eiac.len=10;
	strncpy((char *) lsaconxb.arr,CNTRL_RCD->hg_lcn,18);
	lsaconxb.arr[18]='\0';
	lsaconxb.len=18;
	strncpy((char *) altlcnxb.arr,CNTRL_RCD->hg_alc,2);
	altlcnxb.arr[2]='\0';
	altlcnxb.len=2;
	
	errcode=initlze_segmnt0102_host_var();

	if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
	{
		errcode=get_PRTSC01A_av8b_ha(CNTRL_RCD,SEGMNT01,SEGMNT02);		
	}
	else
	{
		if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
		{
			        strncpy((char *) hb_refno.arr,CNTRL_RCD->hb_ref_no,32);
				hb_refno.arr[32]='\0';
				hb_refno.len=32;
				strncpy((char *) hb_cage.arr,CNTRL_RCD->hb_cage_code,5);
				hb_cage.arr[5]='\0';
				hb_cage.len=5;
				errcode=get_PRTSC01A_av8b_hb(CNTRL_RCD,SEGMNT01,SEGMNT02);			
		}
		else
		{
			printf("\ncreate_0102");
			printf("\nUnable to determine HA/HB Record Type");
			printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1100;
			return(errcode);
		}
	}
	
	return(errcode);		
}


/*	This function the PRTSC01A information is the request is for av8b
				*/

static int     get_PRTSC01A_av8b_ha(struct cntrl_rcd *CNTRL_RCD, struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02)

{
	int	errcode=0;

	#if DEBUG
		printf("\nget_PRTSC01A_av8b_ha");
		printf("\nrefno (%s) (%d) (%d)",(char *) refno.arr,strlen((char *) refno.arr),refno.len);
		printf("\ncagecdxh (%s) (%d) (%d)",(char *) cage.arr,strlen((char *) cage.arr),cage.len);
	#endif

	EXEC SQL
            select  ha.itnameha,
		substr(to_char(ha.prdldtha,'0009'),2,4),
                ha.physecha,
                ha.shlifeha,
		ha.unitisha,
                ha.cognsnha,
		ha.smmnsnha,
		ha.matnsnha,
		ha.fscnsnha,
		ha.niinsnha,
		ha.aaplccha,
		intrfce_ext.proof_transfer_flag
		into :ha_itnameha:ha_itnameha_i,
		    :ha_prdldtha:ha_prdldtha_i,
		    :ha_physecha:ha_physecha_i,
		    :ha_shlifeha:ha_shlifeha_i,
		    :ha_unitisha:ha_unitisha_i,
		    :ha_cognsnha:ha_cognsnha_i,
		    :ha_smmnsnha:ha_smmnsnha_i,
		    :ha_matnsnha:ha_matnsnha_i,
		    :ha_fscnsnha:ha_fscnsnha_i,
		    :ha_niinsnha:ha_niinsnha_i,
		    :ha_aaplccha:ha_applccha_i,
        	    :intrfce_proof_transfer_flag:intrfce_proof_transfer_flag_i
            from prov.av8b_intrfce_ext intrfce_ext,
		 slic2b20.av8b_ha ha
            where
		  ha.can_int = 0
             and rtrim(ha.refnumha) = intrfce_ext.ref_no
              and ha.cagecdxh = intrfce_ext.cage_code
              and intrfce_ext.ha_hb_ind = 'HA'
              and ha.refnumha = :refno
              and ha.cagecdxh = :cage;


	if (sqlca.sqlcode == FND)
	{
		errcode=get_av8b_hax01_data(CNTRL_RCD);
		if (errcode == 0)
		{
			errcode=get_av8b_hax01a_data(CNTRL_RCD);
		}
		if (errcode == 0)
		{
			errcode=get_PRTSC01A_av8b_hf(CNTRL_RCD);
		}
		if(errcode == 0 && (intrfce_proof_transfer_flag == 'N' ||
		                    intrfce_proof_transfer_flag_i == -1))
		{
			SEGMNT01->proof_transfer_flag='N';
/*			errcode=updte_av8b_hax_xfer_flag(CNTRL_RCD); */
		}
		else
		{
			SEGMNT01->proof_transfer_flag=intrfce_proof_transfer_flag;
		}
		if (errcode == 0)
		{
			errcode=get_av8b_SE_info_ea(CNTRL_RCD);
		}
		if(errcode == 0)
		{
			errcode=get_av8b_arn_info(CNTRL_RCD);
		}
		if(errcode == 0)
		{
			errcode=determine_av8b_cat_resp(CNTRL_RCD);
		}
		if (errcode == 0)
		{
			errcode=build_av8b_prtsc0102_rcd(CNTRL_RCD,SEGMNT01,SEGMNT02);
			CNTRL_RCD->built_01='Y';
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			printf("\nget_PRTSC01A_av8b_ha");
			printf("\nUnable to locate HA Record for selected HG");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1101;
		}
		else
		{
			printf("\nget_PRTSC01A_av8b_ha");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1102;
			btchslpf_dberr();
		}
	}

	return(errcode);		
}
static int     get_av8b_hax01_data(struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;

	#if DEBUG
		printf("\nget_av8b_hax01_data");
		printf("\nrefnumha (%s) (%d) (%d)",(char *) refno.arr,strlen((char *) refno.arr),refno.len);
		printf("\ncagecdxh (%s) (%d) (%d)",(char *) cage.arr,strlen((char *) cage.arr),cage.len);
	#endif

	EXEC SQL
            select hax.nicncog,
		hax.nicnmcc,
		hax.nicnfsc,
		hax.nicnniin,
		hax.nicnsmic 
		into :hax_nicncog:hax_nicncog_i,
		     :hax_nicnmcc:hax_nicnmcc_i,
		     :hax_nicnfsc:hax_nicnfsc_i,
		     :hax_nicnniin:hax_nicnniin_i,
		     :hax_nicnsmic:hax_nicnsmic_i
            from slic2b20.av8b_hax01 hax
            where
                  hax.can_int = 0
	      and hax.refnumha = :refno
              and hax.cagecdxh = :cage;


	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			hax_nicncog_i=1;
			hax_nicnmcc_i=1;
			hax_nicnfsc_i=1;
			hax_nicnniin_i=1;
			hax_nicnsmic_i=1;
		}
		else
		{
			printf("\nget_av8b_hax_data");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1114;
			btchslpf_dberr();		
		}
	}
	
	return(errcode);
}
static int     get_av8b_hax01a_data(struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;

	#if DEBUG
		printf("\nget_av8b_hax01a_data");
		printf("\nrefnumha (%s) (%d) (%d)",(char *) refno.arr,strlen((char *) refno.arr),refno.len);
		printf("\ncagecdxh (%s) (%d) (%d)",(char *) cage.arr,strlen((char *) cage.arr),cage.len);
	#endif

	EXEC SQL
            select substr(to_char(hax01a.sctldtme,'09'),2,2),
	        hax01a.scttstfg,
		substr(hax01a.sctcmpdt,6,2)||
		'/'||
		substr(hax01a.sctcmpdt,9,2)||
		'/'||
		substr(hax01a.sctcmpdt,1,4),
                hax01a.sctauth,
		hax01a.psind,
		hax01a.psscdno
		into :hax_sctldtme:hax_sctldtme_i,
		    :hax_scttstfg:hax_scttstfg_i,
		    :hax_sctcmpdt:hax_sctcmpdt_i,
		    :hax_sctauth:hax_sctauth_i,
		    :hax_psind:hax_psind_i,
		    :hax_psscdno:hax_psscdno_i
            from slic2b20.av8b_hax01a hax01a
            where
                  hax01a.can_int = 0
	      and hax01a.refnumha = :refno
              and hax01a.cagecdxh = :cage;

	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			hax_sctldtme_i=1;
			hax_sctcmpdt_i=1;
			hax_scttstfg_i=1;
			hax_sctauth_i=1;
			hax_psind_i=1;
			hax_psscdno_i=1;
		}
		else
		{
			printf("\nget_av8b_hax_data");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1115;
			btchslpf_dberr();
		}
	}
	
	return(errcode);
}
/*
	This function updates the Proof_TRANSFER_FLAG on the HAX to "Y"
	*/
	
static int	updte_av8b_hax_xfer_flag(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;

	#if DEBUG
		printf("\nupdte_av8b_hax_xfer_flag");
	#endif
	
	EXEC SQL
		update prov.av8b_intrfce_ext
		 	set proof_transfer_flag = 'Y'
		 where
		 	ref_no = rtrim(:refno)
		 and	cage_code = :cage
		 and    ha_hb_ind = 'HA';
		
	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		printf("\nupdte_av8b_hax_xfer_flag");
		printf("\nUnable to update Intrfce Proof Transfer Flag");
		CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
		printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
		printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
		printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
		printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
		printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
		errcode=1103;
		btchslpf_dberr();
	}

	return(errcode);		
}

/*	This function the PRTSC01A information is the request is for av8b
				*/

static int     get_PRTSC01A_av8b_hb(struct cntrl_rcd *CNTRL_RCD, struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02)

{
	int	errcode=0;

	#if DEBUG
		printf("\nget_PRTSC01A_av8b_hb");
		printf("\nrefno (%s) (%d) (%d)",(char *) refno.arr,strlen((char *) refno.arr),refno.len);
		printf("\ncagecdxh (%s) (%d) (%d)",(char *) cage.arr,strlen((char *) cage.arr),cage.len);
	#endif


/*      Updated SQL to pull nomenclature and HA data 06/22/2005  
	      select intrfce_ext.proof_transfer_flag
		into :intrfce_proof_transfer_flag:intrfce_proof_transfer_flag_i
            from prov.av8b_intrfce_ext intrfce_ext,
		 slic2b20.av8b_hb hb
            where
		  hb.can_int = 0 
              and hb.refnumhb = :refno
              and hb.cagecdhb = :cage
              and rtrim(hb.addrefhb) = intrfce_ext.ref_no
              and hb.adcagehb = intrfce_ext.cage_code
              and intrfce_ext.ha_hb_ind = 'HB'; 
*/

	EXEC SQL
            select  ha.itnameha,
		substr(to_char(ha.prdldtha,'0009'),2,4),
                ha.physecha,
                ha.shlifeha,
		ha.unitisha,
                ha.cognsnha,
		ha.smmnsnha,
		ha.matnsnha,
		ha.fscnsnha,
		ha.niinsnha,
		ha.aaplccha,
		intrfce_ext.proof_transfer_flag
		into :ha_itnameha:ha_itnameha_i,
		    :ha_prdldtha:ha_prdldtha_i,
		    :ha_physecha:ha_physecha_i,
		    :ha_shlifeha:ha_shlifeha_i,
		    :ha_unitisha:ha_unitisha_i,
		    :ha_cognsnha:ha_cognsnha_i,
		    :ha_smmnsnha:ha_smmnsnha_i,
		    :ha_matnsnha:ha_matnsnha_i,
		    :ha_fscnsnha:ha_fscnsnha_i,
		    :ha_niinsnha:ha_niinsnha_i,
		    :ha_aaplccha:ha_applccha_i,
        	    :intrfce_proof_transfer_flag:intrfce_proof_transfer_flag_i
            from prov.av8b_intrfce_ext intrfce_ext,
		 slic2b20.av8b_ha ha,
		 slic2b20.av8b_hb hb
            where

		  hb.can_int = 0 
              and ha.refnumha = :refno
              and ha.cagecdxh = :cage
	      and ha.refnumha=hb.refnumhb
	      and ha.cagecdxh=hb.cagecdhb
              and hb.addrefhb = :hb_refno
              and hb.adcagehb = :hb_cage
              and rtrim(hb.addrefhb) = intrfce_ext.ref_no
              and hb.adcagehb = intrfce_ext.cage_code
              and intrfce_ext.ha_hb_ind = 'HB';

	if (sqlca.sqlcode == FND)
	{
		errcode=get_av8b_hax01_data(CNTRL_RCD);
		if (errcode == 0)
		{
			errcode=get_av8b_hax01a_data(CNTRL_RCD);
		}
		if(errcode == 0)
		{
			errcode=get_PRTSC01A_av8b_hf(CNTRL_RCD);
		}
		if(errcode == 0 && (intrfce_proof_transfer_flag == 'N' ||
		                    intrfce_proof_transfer_flag_i == -1))
		{
			SEGMNT01->proof_transfer_flag='N';
/*			errcode=updte_av8b_hbx_xfer_flag(CNTRL_RCD);  */
		}
		else
		{
			SEGMNT01->proof_transfer_flag=intrfce_proof_transfer_flag;
		}
		if (errcode == 0)
		{
			errcode=get_av8b_SE_info_ea(CNTRL_RCD);
		}
		if(errcode == 0)
		{
			errcode=get_av8b_arn_info(CNTRL_RCD);
		}
		if(errcode == 0)
		{
			errcode=determine_av8b_cat_resp(CNTRL_RCD);
		}
		if (errcode == 0)
		{
			errcode=build_av8b_prtsc0102_rcd(CNTRL_RCD,SEGMNT01,SEGMNT02);
			CNTRL_RCD->built_01='Y';
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			printf("\nget_PRTSC01A_av8b_hb");
			printf("\nUnable to locate HA Record for selected HB Record");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1104;
		}
		else
		{
			printf("\nget_PRTSC01A_av8b_hb");
			printf("\nBad SQLCODE");
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1105;
			btchslpf_dberr();
		}
	}

	return(errcode);		
}
/*
	This function updates the Proof_TRANSFER_FLAG on the HBX to "Y"
	*/
	
static int	updte_av8b_hbx_xfer_flag(struct cntrl_rcd *CNTRL_RCD)
{
	int	errcode=0;

	#if DEBUG
		printf("\nupdte_av8b_hbx_xfer_flag");
	#endif
	
	EXEC SQL
		update prov.av8b_intrfce_ext
		 	set proof_transfer_flag = 'Y'
		 where
		          ref_no = rtrim(:hb_refno)
	       	      and cage_code = :hb_cage
		      and ha_hb_ind = 'HB';
		
	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		printf("\nupdte_av8b_hbx_xfer_flag");
		printf("\nUnable to update HBX PROOF Transfer Flag");
		printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
		printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
		printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
		printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
		printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
		errcode=1106;
		CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
		btchslpf_dberr();
	}

	return(errcode);		
}

/*
	This function gets the Packaging Preservation information from
	the 1388 HF Table.
				*/

static int	get_PRTSC01A_av8b_hf(struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;

	#if DEBUG
		printf("\nget_PRTSC01A_av8b_HF");
	#endif

	EXEC SQL
	    select qtyupkhf
		into :hf_qtyupkhf:hf_qtyupkhf_i
            from slic2b20.av8b_hf hf
            where
                  hf.cagecdxh = :cage
              and hf.refnumha = rpad(:refno,32,' ')
	      and hf.can_int = 0
	      and degprohf in (select max(degprohf)
				from slic2b20.av8b_hf hf1
				where hf.cagecdxh = hf1.cagecdxh
				  and hf.refnumha = hf1.refnumha
				  and hf.can_int = hf1.can_int);

	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			strncpy((char *) hf_qtyupkhf.arr,"   ",3);
		}
		else
		{
			printf("\nget_PRTSC01A_av8b_HF");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;	
			errcode=1107;
			btchslpf_dberr();
		}
	}

	return(errcode);		
}

static int     get_av8b_SE_info_ea(struct cntrl_rcd *CNTRL_RCD)

{
	int     errcode=0;

	#if DEBUG
		printf("\nget_av8b_SE_info_ea");
	#endif

	EXEC SQL
	    select cfegfeea
		    into :se_cfegfeea:se_cfegfeea_i
		  from slic2b20.av8b_ea ea
	     where
		    ea.secageea = :cage
	      	and ea.serefnea = rpad(:refno,32,' ')
		and ea.can_int = 0;

	if (sqlca.sqlcode == FND)
	{
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			se_cfegfeea=' ';
		}
		else
		{
			printf("\nget_av8b_SE_info_ea");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1108;
			btchslpf_dberr();
		}
	}

	return(errcode);

}
/*  This function retrieves those HB Reference numbers that have a RNCC 
    of 7 (SCD Reference Numbers).  If none are found then it checks to see if it
    has an HB with an RNCC of D (Procurement Spec Reference Number)
				*/
				
	EXEC SQL DECLARE process_av8b_arn_info_csr CURSOR for
	 select '1',hb.addrefhb,
	           hb.adcagehb,
		   hb.adrncchb
	          from slic2b20.av8b_hb hb
            where
	      	    hb.cagecdhb = :cage
	      	and hb.refnumhb = rpad(:refno,32,' ')
		and hb.adrncchb = '7'
		and hb.can_int = 0
	union all
	select '2',hb.addrefhb,
	           hb.adcagehb,
		   hb.adrncchb
	          from slic2b20.av8b_hb hb
            where
	      	    hb.cagecdhb = :cage
	      	and hb.refnumhb = rpad(:refno,32,' ')
		and hb.adrncchb = 'D'
		and hb.can_int=0;
		
static int	get_av8b_arn_info(struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;
	char	spaces[]={"                                        "};

	#if DEBUG
		printf("\nget_av8b_arn_info");
	#endif

	EXEC SQL OPEN process_av8b_arn_info_csr;
	
	if (sqlca.sqlcode == FND)
	{
		EXEC SQL FETCH process_av8b_arn_info_csr
	    		into :arn_type_code:arn_type_code_i,
			:arn_refnumha:arn_refnumha_i,
			:arn_cage:arn_cage_i,
			:arn_rncc:arn_rncc_i;

		if (sqlca.sqlcode == FND)
		{
		}
		else
		{
			if (sqlca.sqlcode == NOT_FND)
			{
				strncpy((char *) arn_refnumha.arr,spaces,32);
				arn_refnumha.len=32;
				arn_rncc=' ';
			}
			else
			{
				printf("\nget_av8b_arn_info");
				printf("\nBad SQLCODE on FETCH");
				printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
				printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
				printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
				printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
				printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
				printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
				printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
				CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
				errcode=1109;
				btchslpf_dberr();
			}
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
				strncpy((char *) arn_refnumha.arr,spaces,32);
				strncpy((char *) arn_cage.arr,spaces,5);
				arn_refnumha.len=32;
				arn_cage.len=5;
				arn_rncc=' ';
		}
		else
		{
			printf("\nget_av8b_arn_info");
			printf("\nBad SQLCODE on OPEN CURSOR");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1110;
			btchslpf_dberr();
		}
	}
	
	EXEC SQL CLOSE process_av8b_arn_info_csr;

	return(errcode);		
}

/*
	This function determines the Category Responsibility Code   */
	
	EXEC SQL DECLARE determine_av8b_cat_resp_csr CURSOR for
		select distinct '1',suplyrcd
	            from slic2b20.av8b_hgx01
	             where refnumha = :refno
	              and cagecdxh = :cage
	              and suplyrcd = '76301'
		      and lcntypxb = 'P'
		      and can_int=0 
	        union all
	        select distinct '2',suplyrcd
	            from slic2b20.av8b_hgx01
	              where refnumha = :refno
	                and cagecdxh = :cage
	                and suplyrcd not in ('76301','     ')
		        and lcntypxb = 'P'
			and can_int = 0
	        union all
	        select distinct '3',suplyrcd
	            from slic2b20.av8b_hgx01
	              where refnumha = :refno
	                and cagecdxh = :cage
	                and (suplyrcd is null or
	                    suplyrcd = '     ')
		        and lcntypxb = 'P'
			and can_int = 0
	        order by 1;
	                    	
static int	determine_av8b_cat_resp(struct cntrl_rcd *CNTRL_RCD)

{
	int	errcode=0;
	char	fetched_row=0;
	char	spaces[]={"                                        "};
	
	EXEC SQL OPEN determine_av8b_cat_resp_csr;
	
	strncpy((char *) hgx_suplyrcd.arr,spaces,5);
	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			EXEC SQL FETCH determine_av8b_cat_resp_csr
			  into :cat_resp_ind,
			       :hgx_suplyrcd:hgx_suplyrcd_i;
	   		if (sqlca.sqlcode == FND)
			{
				if (hgx_suplyrcd_i == FND)
				{
					fetched_row=1;
				}
				else
				{
					strncpy((char *) hgx_suplyrcd.arr,spaces,5);
				}
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
				}
				else
				{
					printf("\ndetermine_av8b_cat_resp");
					printf("\nFETCH CURSOR");
					printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
					printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
					printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
					printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
					printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
					printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
					printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					errcode=1113;
					btchslpf_dberr();
				}
			}
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
		}
		else
		{
			printf("\ndetermine_av8b_cat_resp");
			printf("\nOpen CURSOR");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1114;
			btchslpf_dberr();
		}
	}
	
	EXEC SQL CLOSE determine_av8b_cat_resp_csr;
	
	return(errcode);
}
/*
	This function sets up the output area with information from the
	selects   */

static int	build_av8b_prtsc0102_rcd(struct cntrl_rcd *CNTRL_RCD,struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02)

{
	int	errcode=0;
	char	spaces[]={"                                        "};
	int	i=0;
	char	outData[500];
	
	#if DEBUG
		printf("\nbuild_av8b_prtsc0102_rcd");
		printf("\nHA Ref No (%s)",(char *) refno.arr);
		printf("\nHA Ref No Cage (%s)",(char *) cage.arr);
		printf("\nHB Ref No (%s)",(char *) hb_refno.arr);
		printf("\nHB Ref No Cage (%s)",(char *) hb_cage.arr);
	#endif

	errcode=initlze_AV8_segmnt0102(SEGMNT01,SEGMNT02);
	
	if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
	{
		strncpy(SEGMNT01->ref_no,(char *) refno.arr,refno.len);
		strncpy(SEGMNT01->cage_code,(char *) cage.arr,refno.len);
	}
	else
	{
		if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
		{
			strncpy(SEGMNT01->ref_no,(char *) hb_refno.arr,hb_refno.len);
			strncpy(SEGMNT01->cage_code,(char *) hb_cage.arr,hb_cage.len);
		}
		else
		{
			printf("\nbuild_av8b_prtsc0102_rcd");
			printf("\nUnable to determine HA/HB Record Type - Creation of SEGMNT01 Record");
			printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1115;
			return(errcode);
		}
	}
	
	strncpy(SEGMNT01->prtsc01a,"01",2);
	strncpy(SEGMNT01->filler,spaces,10);
	strncpy(SEGMNT01->ref_no_type,CNTRL_RCD->ha_hb_code,2);
	if(strncmp((char *) ha_itnameha.arr,"                   ",19)==0)
	{
		strncpy(SEGMNT01->ha_item_nme,"TBD                ",19);
	}
	else
	{
		strncpy(SEGMNT01->ha_item_nme,(char *) ha_itnameha.arr,ha_itnameha.len);
	}
	strncpy(SEGMNT01->ha_prod_lead_time,(char *) ha_prdldtha.arr,ha_prdldtha.len);
	SEGMNT01->se_item=se_item_ind;

	if (hax_sctldtme_i == 0)
	{
		strncpy(SEGMNT01->hax_sct_lead_time,(char *) hax_sctldtme.arr,hax_sctldtme.len);
	}
	else
	{
		strncpy(SEGMNT01->hax_sct_lead_time,spaces,2);
	}
	SEGMNT01->ha_physcl_secrty=ha_physecha;
	SEGMNT01->ha_shlf_life=ha_shlifeha;
	if(ha_unitisha_i == 0)
	{
		strncpy(SEGMNT01->ha_unit_issue,"EA",2);
	}
	else
	{
		strncpy(SEGMNT01->ha_unit_issue,(char *) ha_unitisha.arr,ha_unitisha.len);
	}
	if (hax_sctcmpdt_i == 0)
	{
		strncpy(SEGMNT01->hax_sct_compltn_date,(char *) hax_sctcmpdt.arr,hax_sctcmpdt.len);
	}
	else
	{
		strncpy(SEGMNT01->hax_sct_compltn_date,spaces,10);
	}
	if (hax_scttstfg_i == 0)
	{
		SEGMNT01->hax_sct_tst_reqd_flag=hax_scttstfg;
	}
	else
	{
		SEGMNT01->hax_sct_tst_reqd_flag='N';
	}
	if (hax_sctauth_i == 0)
	{
		strncpy(SEGMNT01->hax_sct_authrztn_no,(char *) hax_sctauth.arr,hax_sctauth.len);
	}
	else
	{
		strncpy(SEGMNT01->hax_sct_authrztn_no,spaces,15);
	}
	if (hf_qtyupkhf_i == 0)
	{
		strncpy(SEGMNT01->hf_qup,(char *) hf_qtyupkhf.arr,hf_qtyupkhf.len);
	}
	else
	{
		strncpy(SEGMNT01->hf_qup,spaces,3);
	}
	if (hax_psind_i == 0)
	{
		strncpy(SEGMNT01->hax_ps_ind,(char *) hax_psind.arr,hax_psind.len);
	}
	else
	{
		strncpy(SEGMNT01->hax_ps_ind,spaces,3);
	}
	if (hax_psscdno_i == 0)
	{
		strncpy(SEGMNT01->hax_ps_scd_no,(char *) hax_psscdno.arr,hax_psscdno.len);
	}
	else
	{
		strncpy(SEGMNT01->hax_ps_scd_no,spaces,22);
	}
	
/*	strncpy(SEGMNT02->hg_end_item_acrnym,CNTRL_RCD->mdl_acft_prf,10); */
	strncpy(SEGMNT02->hg_end_item_acrnym,(char *) mdl_acft_prf.arr,mdl_acft_prf.len);
	strncat(SEGMNT02->hg_end_item_acrnym,spaces,10-mdl_acft_prf.len);
	/* strncpy(SEGMNT02->ha_nsn_cog_code,(char *) ha_cognsnha.arr,ha_cognsnha.len); NO LONGER NEEDED PER PATRICIA WHITE (PROBLEMREPORT  GSSIT00031772) */
	/* SEGMNT02->ha_nsn_matl=ha_matnsnha; NO LONGER NEEDED PER PATRICIA WHITE (PROBLEMREPORT GSSIT00031772) */ 
	strncpy(SEGMNT02->ha_nsn_fsc,(char *) ha_fscnsnha.arr,ha_fscnsnha.len);
	strncpy(SEGMNT02->ha_nsn_niin,(char *) ha_niinsnha.arr,ha_niinsnha.len);
	strncpy(SEGMNT02->ha_nsn_spec_ident,(char *) ha_smmnsnha.arr,ha_smmnsnha.len);
	
	if(hax_nicncog_i == 0)
	{
		strncpy(SEGMNT02->hax_nsn_cog_code,(char *) hax_nicncog.arr,hax_nicncog.len);
	}
	else
	{
		strncpy(SEGMNT02->hax_nsn_cog_code,spaces,2);
	}
	
	if (hax_nicnmcc_i == 0)
	{
		SEGMNT02->hax_nsn_matl=hax_nicnmcc;
	}
	else
	{
		SEGMNT02->hax_nsn_matl=' ';
	}
	
	if(hax_nicnfsc_i == 0)
	{
		strncpy(SEGMNT02->hax_nsn_fsc,(char *) hax_nicnfsc.arr,hax_nicnfsc.len);
	}
	else
	{
		strncpy(SEGMNT02->hax_nsn_fsc,spaces,4);
	}
	
	if(hax_nicnniin_i == 0)
	{
		strncpy(SEGMNT02->hax_nsn_niin,(char *) hax_nicnniin.arr,hax_nicnniin.len);
	}
	else
	{
		strncpy(SEGMNT02->hax_nsn_niin,spaces,9);
	}
	
	if(hax_nicnsmic_i == 0)
	{
		strncpy(SEGMNT02->hax_nsn_spec_ident,(char *) hax_nicnsmic.arr,hax_nicnsmic.len);
	}
	else
	{
		strncpy(SEGMNT02->hax_nsn_spec_ident,spaces,2);
	}
	

	strncpy(SEGMNT02->prtsc02a,"02",2);
	SEGMNT02->ha_aaplccha=ha_aaplccha;
	strncpy(SEGMNT02->hgx_suplyr_cage_code,(char *) hgx_suplyrcd.arr,hgx_suplyrcd.len); 

	if (arn_refnumha_i == 0)
	{
		strncpy(SEGMNT01->hb_arn_ref_no,(char *) arn_refnumha.arr,arn_refnumha.len);
	}
	else
	{
		strncpy(SEGMNT01->hb_arn_ref_no,spaces,32);
	}
	
	if (arn_cage_i == 0)
	{
		strncpy(SEGMNT01->hb_arn_cage,(char *) arn_cage.arr,arn_cage.len);
	}
	else
	{
		strncpy(SEGMNT01->hb_arn_cage,spaces,5);
	}
	
	if (arn_rncc_i == 0)
	{
		SEGMNT01->hb_arn_rncc=arn_rncc;
	}
	else
	{
		SEGMNT01->hb_arn_rncc=' ';
	}
	
	if (se_cfegfeea_i == 0)
	{
		SEGMNT01->ea_cfe_gfe=se_cfegfeea;
	}
	else
	{
		SEGMNT01->ea_cfe_gfe=' ';
	}
	
	for (i=0;i<500;i++)
	{
		outData[i]=' ';
	}
	
	SEGMNT01->prtsc01_eof='\0';
	SEGMNT01->prtsc01_newline='\n';
	#if DEBUG
		printf("\nSegmnt 01 (%s)",SEGMNT01);
	#endif
	assert(sizeof(outData)+1 >= sizeof(SEGMNT01));
	memset(outData,'\0',sizeof(outData));
	memcpy(outData,SEGMNT01, sizeof(SEGMNT01));
	errcode=write_av8b_rcd((char *) &outData,CNTRL_RCD);
	
	for (i=0;i<500;i++)
	{
		outData[i]=' ';
	}

	if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
	{
		strncpy(SEGMNT02->ref_no,(char *) refno.arr,refno.len);
		strncpy(SEGMNT02->cage_code,(char *) cage.arr,cage.len);
	}
	else
	{
		if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
		{
			strncpy(SEGMNT02->ref_no,(char *) hb_refno.arr,hb_refno.len);
			strncpy(SEGMNT02->cage_code,(char *) hb_cage.arr,hb_cage.len);
		}
		else
		{
			printf("\nbuild_av8b_prtsc0102_rcd");
			printf("\nUnable to determine HA/HB Record Type - Creation of SEGMNT02 Record");
			printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cagecdxh (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			errcode=1116;
			return(errcode);
		}
	}
	
	errcode=write_av8b_segmnt02(CNTRL_RCD,SEGMNT02);
	
	return(errcode);		
}
static int	write_av8b_segmnt02(struct cntrl_rcd *CNTRL_RCD,struct prtsc02 *SEGMNT02)
{
	int	errcode=0;
	int	fetched_row=0;
	int	fetched_ctr=0;
	char	outData[500];

	SEGMNT02->prtsc02_eof='\0';
	SEGMNT02->prtsc02_newline='\n';
	#if DEBUG
		printf("\nwrite_av8b_segmnt02");
		printf("\nSegmnt 02 (%s)",SEGMNT02);
	#endif
	assert(sizeof(outData)+1 >= sizeof(SEGMNT02));
	memset(outData,'\0',sizeof(outData));
	memcpy(outData, SEGMNT02,sizeof(SEGMNT02));
	errcode=write_av8b_rcd((char *) &outData,CNTRL_RCD);		
	return(errcode);
}
/*

*/
static int	initlze_AV8_segmnt0102(struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02)
{
	int	errcode=0;
	char	spaces[]={"                                        "};

	#if DEBUG
		printf("\ninitlze_AV8_segmnt0102");
	#endif
	strncpy(SEGMNT01->ref_no,spaces,32);
	strncpy(SEGMNT01->cage_code,spaces,5);
	strncpy(SEGMNT01->filler,spaces,10);
	strncpy(SEGMNT01->ha_item_nme,spaces,19);
	strncpy(SEGMNT01->ha_prod_lead_time,spaces,4);
	strncpy(SEGMNT01->hax_sct_lead_time,spaces,2);
	strncpy(SEGMNT01->ha_unit_issue,spaces,2);
	SEGMNT01->ha_physcl_secrty=' ';
	SEGMNT01->ha_shlf_life=' ';
	strncpy(SEGMNT01->hf_qup,spaces,3);
	SEGMNT01->hax_sct_tst_reqd_flag=' ';
	strncpy(SEGMNT01->hax_sct_compltn_date,spaces,10);
	strncpy(SEGMNT01->hax_sct_authrztn_no,spaces,15);
	strncpy(SEGMNT01->hax_ps_ind,spaces,3);
	strncpy(SEGMNT01->hax_ps_scd_no,spaces,22);
	SEGMNT01->hb_arn_rncc=' ';
	strncpy(SEGMNT01->hb_arn_ref_no,spaces,32);
	strncpy(SEGMNT01->hb_arn_cage,spaces,32);
	SEGMNT01->ea_cfe_gfe=' ';
	SEGMNT01->se_item='N';
	SEGMNT01->proof_transfer_flag=' ';
	strncpy(SEGMNT02->ref_no,spaces,32);
	strncpy(SEGMNT02->cage_code,spaces,5);
	strncpy(SEGMNT02->hg_end_item_acrnym,spaces,10);
	strncpy(SEGMNT02->ha_nsn_cog_code,spaces,2);
	SEGMNT02->ha_nsn_matl=' ';
	strncpy(SEGMNT02->ha_nsn_fsc,spaces,4);
	strncpy(SEGMNT02->ha_nsn_niin,spaces,9);
	strncpy(SEGMNT02->ha_nsn_spec_ident,spaces,2);
	strncpy(SEGMNT02->hax_nsn_cog_code,spaces,2);
	SEGMNT02->hax_nsn_matl=' ';
	strncpy(SEGMNT02->hax_nsn_fsc,spaces,4);
	strncpy(SEGMNT02->hax_nsn_niin,spaces,9);
	strncpy(SEGMNT02->hax_nsn_spec_ident,spaces,2);
	SEGMNT02->ha_aaplccha=' ';
	strncpy(SEGMNT02->hgx_suplyr_cage_code,spaces,5);

	return(errcode);
}

static int	create_av8b_03(struct cntrl_rcd *CNTRL_RCD,struct prtsc03 *SEGMNT03)

{
	int	errcode=0;

	#if DEBUG
		printf("\ncreate_av8b_03");
		printf("\nRefno (%s)",CNTRL_RCD->ha_ref_no);
		printf("\nCage (%s)",CNTRL_RCD->ha_cage_code);
		printf("\nEIAC (%s)",CNTRL_RCD->ha_eiac);
		printf("\nLCN (%s)",CNTRL_RCD->hg_lcn);
		printf("\nALC (%s)",CNTRL_RCD->hg_alc);
	#endif
	
	strncpy((char *) refno.arr,CNTRL_RCD->ha_ref_no,32);
	refno.arr[32]='\0';
	refno.len=32;
	strncpy((char *) cage_code.arr,CNTRL_RCD->ha_cage_code,5);
	cage_code.arr[5]='\0';
	cage_code.len=5;
	strncpy((char *) eiac.arr,CNTRL_RCD->ha_eiac,10);
	eiac.len=10;
	strncpy((char *) hg_03lcn.arr,CNTRL_RCD->hg_lcn,18);
	hg_03lcn.arr[18]='\0';
	hg_03lcn.len=18;
	strncpy((char *) hg_03alc.arr,CNTRL_RCD->hg_alc,2);
	hg_03alc.arr[2]='\0';
	hg_03alc.len=2;

	if ((strncmp((char*)hg_eiac.arr,"GR7",3) == 0)  ||
	    (strncmp((char*)hg_eiac.arr,"GR9",3) == 0) ||
	    (strncmp((char*)hg_eiac.arr,"T10",3) == 0) ||
	    (strncmp((char*)hg_eiac.arr,"T12",3) == 0))
	{
		strncpy(SEGMNT03->hg_icc,"  ",2);
		strncpy(SEGMNT03->hg_icc,"X ",2);
	}

	errcode=fetch_av8b_eff(CNTRL_RCD,SEGMNT03);

	return(errcode);		
}

EXEC SQL DECLARE effecty_av8b_csr CURSOR for
	select distinct	hgx2.refnumha,
    	   	hgx2.cagecdxh,
    	   	hgx2.eiacodxa,
    	   	model,
		to_char(efffrom,'0009'),
		to_char(effto,'0009')
	from slic2b20.av8b_hgx01a hgx2	     
	    where hgx2.refnumha    = :refno
	     and hgx2.cagecdxh  = :cage_code
	     and hgx2.eiacodxa = :eiac
	     and hgx2.lsaconxb = :hg_03lcn
	     and hgx2.altlcnxb = :hg_03alc
	     and hgx2.lcntypxb   = 'P'
	     and hgx2.can_int = 0
	union
	select distinct	hpx2.refnumha,
    	   	hpx2.cagecdxh,
    	   	hpx2.eiacodxa,
    	   	mdlhp,    
		to_char(uoefffrm,'0009'),
		to_char(uoeffto,'0009')
	from slic2b20.av8b_hpx01a hpx2  
 	   where hpx2.refnumha = :refno
	     and hpx2.cagecdxh = :cage_code
	     and hpx2.eiacodxa = :eiac
	     and hpx2.lsaconxb = :hg_03lcn
	     and hpx2.altlcnxb = :hg_03alc
	     and hpx2.efftyphp = 'U'
	     and hpx2.lcntypxb  = 'P'
	     and hpx2.can_int = 0
	order by 1,2,3,4,5,6;
		
int     fetch_av8b_eff(struct cntrl_rcd *CNTRL_RCD,struct prtsc03 *SEGMNT03)

{
	char    spaces[]={"                                        "};
	int     errcode=0;
	int	fetched_row=0;
	int	fetched_ctr=0;

	#if DEBUG
		printf("\nfetch_av8b_eff");
		printf("\nrefno (%s) (%d) (%d)",(char *) refno.arr, refno.len, strlen((char *) refno.arr));
		printf("\ncage_code (%s) (%d) (%d)",(char *) cage_code.arr,cage_code.len,strlen((char *) cage_code.arr));
		printf("\neiac (%s) (%d) (%d)",(char *) eiac.arr,eiac.len,strlen((char *) eiac.arr));
		printf("\nlcn (%s) (%d) (%d)",(char *) hg_03lcn.arr,hg_03lcn.len, strlen((char *) hg_03lcn.arr));
		printf("\nalc (%s) (%d) (%d)",(char *) hg_03alc.arr,hg_03alc.len,strlen((char *) hg_03alc.arr));
	#endif

	EXEC SQL OPEN effecty_av8b_csr;

	if (sqlca.sqlcode == FND)
	{
		while(!fetched_row)
		{
			errcode=initlze_segmnt03_host_var();

			EXEC SQL FETCH effecty_av8b_csr
			  into :hgx_ref_no,
				:hgx_cage_code,
				:hg_eiac,
				:series_cd:series_cd_i,
			  	:ef_from:ef_from_i,
			  	:ef_to:ef_to_i;
			if (sqlca.sqlcode == FND)
			{
				errcode=initlze_segmnt03(SEGMNT03);
				fetched_ctr++;
				if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
				{
					strncpy(SEGMNT03->ref_no,(char *) refno.arr,refno.len);
					strncpy(SEGMNT03->cage_code,(char *) cage_code.arr,cage_code.len);
				}
				else
				{
					if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
					{
						strncpy(SEGMNT03->ref_no,CNTRL_RCD->hb_ref_no,32);
						strncpy(SEGMNT03->cage_code,CNTRL_RCD->hb_cage_code,5);
					}
					else
					{
						printf("\nfetch_av8b_eff");
						printf("\nUnable to determine HA/HB Record Type");
						printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
						printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
						printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
						printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
						printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
						printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
						printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
						printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
						errcode=1200;
						return(errcode);
					}
				}
				
				strncpy(SEGMNT03->prtsc03a,"03",2);
		/*		strncpy(SEGMNT03->hg_end_item_acrnym,CNTRL_RCD->mdl_acft_prf,10); */
				strncpy(SEGMNT03->hg_end_item_acrnym,(char *) mdl_acft_prf.arr,mdl_acft_prf.len);
				strncat(SEGMNT03->hg_end_item_acrnym,spaces,10-mdl_acft_prf.len);
				strncpy(SEGMNT03->hg_lsaconxb,CNTRL_RCD->hg_lcn,18);
				strncpy(SEGMNT03->hg_alt_lsa,CNTRL_RCD->hg_alc,2);
				SEGMNT03->mdl_instld_on_eff=series_cd;
				if (strncmp(CNTRL_RCD->cn,"MC",2)==0)
				{
					strncpy(SEGMNT03->from_eff,(char *) ef_from.arr,ef_from.len);
					strncpy(SEGMNT03->to_eff,(char *) ef_to.arr,ef_to.len);
				}
				else
				{
					strncpy(SEGMNT03->from_eff,"    ",4);
					strncpy(SEGMNT03->to_eff,"    ",4);
					SEGMNT03->mdl_instld_on_eff=' ';
				}

				errcode=build_av8b_prtsc03_rcd(CNTRL_RCD,SEGMNT03);
			}
			else
			{
				fetched_row=1;
				if (sqlca.sqlcode == NOT_FND)
				{
					if (fetched_ctr > 0)
					{
					}
					else
					{
						if((strncmp((char *) eiac.arr,"GR7",3)==0) ||
						   (strncmp((char *) eiac.arr,"GR9",3)==0) ||
						   (strncmp((char *) eiac.arr,"T10",3)==0) ||
						   (strncmp((char *) eiac.arr,"T12",3)==0))
						{
						errcode=initlze_segmnt03_host_var();
						if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
						{
							strncpy(SEGMNT03->ref_no,(char *) refno.arr,refno.len);
							strncpy(SEGMNT03->cage_code,(char *) cage_code.arr,cage_code.len);
						}
						else
						{
							if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
							{
								strncpy(SEGMNT03->ref_no,CNTRL_RCD->hb_ref_no,32);
								strncpy(SEGMNT03->cage_code,CNTRL_RCD->hb_cage_code,5);
							}
							else
							{
								printf("\nfetch_av8b_eff");
								printf("\nUnable to determine HA/HB Record Type");
								printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
								printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
								printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
								printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
								printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
								printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
								printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
								printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
								errcode=1200;
								return(errcode);
							}
						}
							CNTRL_RCD->valid_application = 'Y';
							strncpy(SEGMNT03->from_eff," 0001",5);
							strncpy(SEGMNT03->to_eff," 9999",5);
							SEGMNT03->mdl_instld_on_eff='A';
							strncpy(SEGMNT03->prtsc03a,"03",2);
							strncpy(SEGMNT03->hg_end_item_acrnym,(char *) mdl_acft_prf.arr,mdl_acft_prf.len);
							strncat(SEGMNT03->hg_end_item_acrnym,spaces,10-mdl_acft_prf.len);
							strncpy(SEGMNT03->hg_lsaconxb,CNTRL_RCD->hg_lcn,18);
							strncpy(SEGMNT03->hg_alt_lsa,CNTRL_RCD->hg_alc,2);
							errcode=build_av8b_prtsc03_rcd(CNTRL_RCD,SEGMNT03);
						}
						else
						{
							CNTRL_RCD->valid_application = 'N';
						}
					}
				}
				else
				{
					printf("\nFUNCTION: fetch_eff");
					printf("\n\tFETCH Data Failure");
					printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
					printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
					printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
					printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
					printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
					printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
					printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
					CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
					errcode=1201;
					btchslpf_dberr();
					
				}
			}
		}
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
			if((strncmp((char *) eiac.arr,"GR7",3)==0) ||
			   (strncmp((char *) eiac.arr,"GR9",3)==0) ||
			   (strncmp((char *) eiac.arr,"T10",3)==0) ||
			   (strncmp((char *) eiac.arr,"T12",3)==0))
			{
				errcode=initlze_segmnt03_host_var();
				if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
				{
					strncpy(SEGMNT03->ref_no,(char *) refno.arr,refno.len);
					strncpy(SEGMNT03->cage_code,(char *) cage_code.arr,cage_code.len);
				}
				else
				{
					if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
					{
						strncpy(SEGMNT03->ref_no,CNTRL_RCD->hb_ref_no,32);
						strncpy(SEGMNT03->cage_code,CNTRL_RCD->hb_cage_code,5);
					}
					else
					{
						printf("\nfetch_av8b_eff");
						printf("\nUnable to determine HA/HB Record Type");
						printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
						printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
						printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
						printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
						printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
						printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
						printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
						printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
						errcode=1200;
						return(errcode);
					}
				}
				strncpy(SEGMNT03->from_eff," 0001",5);
				strncpy(SEGMNT03->to_eff," 9999",5);
				SEGMNT03->mdl_instld_on_eff='A';
				CNTRL_RCD->valid_application = 'Y';
				strncpy(SEGMNT03->prtsc03a,"03",2);
				strncpy(SEGMNT03->hg_end_item_acrnym,(char *) mdl_acft_prf.arr,mdl_acft_prf.len);
				strncat(SEGMNT03->hg_end_item_acrnym,spaces,10-mdl_acft_prf.len);
				strncpy(SEGMNT03->hg_lsaconxb,CNTRL_RCD->hg_lcn,18);
				strncpy(SEGMNT03->hg_alt_lsa,CNTRL_RCD->hg_alc,2);
				errcode=build_av8b_prtsc03_rcd(CNTRL_RCD,SEGMNT03);
			}
			else
			{
				CNTRL_RCD->valid_application = 'N';
			}
		}
		else
		{
			printf("\nFUNCTION: fetch_eff");
			printf("\n\tOpen Cursor Failure");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1202;
			btchslpf_dberr();
			
		}
	}

	EXEC SQL CLOSE effecty_av8b_csr;
	
	return(errcode);
}
/*

	This is the main processing function for building the
	PROOF interface Record.
	*/

static int     build_av8b_prtsc03_rcd(struct cntrl_rcd *CNTRL_RCD,struct prtsc03 *SEGMNT03)

{
	int	errcode=0;
	char    spaces[]={"                                        "};
	int	i=0;
	char	outData[500];


	#if DEBUG
		printf("\nbuild_av8b_prtsc03_rcd");
	#endif

	for (i=0;i<500;i++)
	{
		outData[i]=' ';
	}
	
	SEGMNT03->prtsc03_eof='\0';
	SEGMNT03->prtsc03_newline='\n';
	#if DEBUG
		printf("\nSegmnt 03 (%s)",SEGMNT03);
	#endif
	assert(sizeof(outData)+1 >= sizeof(SEGMNT03));
	memset(outData,'\0',sizeof(outData));
	memcpy(outData,SEGMNT03,sizeof(SEGMNT03));
	errcode=write_av8b_rcd((char *) &outData,CNTRL_RCD);
	
	return(errcode);
}

static int	create_av8b_04(struct cntrl_rcd *CNTRL_RCD,struct prtsc04 *SEGMNT04)

{

	int	errcode=0;

	#if DEBUG
		printf("\ncreate_av8b_04");
	#endif
	
        strncpy((char *) refno.arr,CNTRL_RCD->ha_ref_no,32);
	refno.arr[32]='\0';
	refno.len = (unsigned short ) strlen((char *) refno.arr);
	strncpy((char *) cage_code.arr,CNTRL_RCD->ha_cage_code,5);
	cage_code.arr[5]='\0';
	cage_code.len=5;
	strncpy((char *) eiac.arr,CNTRL_RCD->ha_eiac,10);
	eiac.arr[10]='\0';
	eiac.len = (unsigned short) strlen((char *) eiac.arr);

	errcode=get_av8b_supsdure_info(CNTRL_RCD,SEGMNT04);

	return(errcode);		
}

/*
	The following Function select the supersedure information for the
	Part Number in question
				*/

EXEC SQL DECLARE supsdure_av8b_csr CURSOR for
	select distinct refnumha,
		cagecdxh,
		eiacodxa,
		rsrefno,
		rsind,
		canumbhp,
		repsupid
	   from slic2b20.av8b_hpx01
	     where
		    refnumha = :refno
		and cagecdxh = :cage_code
		and eiacodxa = :eiac
		and rsind in ('R','S')
		and lcntypxb = 'P'
		and can_int = 0;

int	get_av8b_supsdure_info(struct cntrl_rcd *CNTRL_RCD, struct prtsc04 *SEGMNT04)
{
	int	errcode=0;
		
	#if DEBUG
		printf("\nget_av8b_supsdure_info");
		printf("\nrefno (%s) (%d) (%d)",(char *) refno.arr,strlen((char *) refno.arr),refno.len);
		printf("\ncage_code (%s) (%d) (%d)",(char *) cage_code.arr,strlen((char *) cage_code.arr),cage_code.len);
		printf("\neiac (%s) (%d) (%d)",(char *) eiac.arr,strlen((char *) eiac.arr),eiac.len);
	#endif

	EXEC SQL OPEN supsdure_av8b_csr;

	if (sqlca.sqlcode == FND)
	{
		errcode=fetch_av8b_supsdure_info(CNTRL_RCD,SEGMNT04);
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
		}
		else
		{
			printf("\nget_av8b_supsdure_info");
			printf("\nUnable to Open Cursor");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1300;
			btchslpf_dberr();
		}
	}

	EXEC SQL CLOSE supsdure_av8b_csr;

	return(errcode);
}

int	fetch_av8b_supsdure_info(struct cntrl_rcd *CNTRL_RCD, struct prtsc04 *SEGMNT04)
{
	int	errcode=0;
	int	fetched_row=0;
	int	fetched_ctr=0;
	char	spaces[]={"                                        "};
	char	outData[500];
	int	i;
		
	#if DEBUG
		printf("\nfetch_av8b_supsdure_info");
	#endif

	while(!fetched_row)
	{
		errcode=initlze_segmnt04_host_var();

		EXEC SQL FETCH supsdure_av8b_csr into
			:hpx_ref_no,
			:hpx_cage_code:hpx_cage_code_i,
			:hpx_eiac:hpx_eiac_i, 
			:supsdure_refno:supsdure_ref_no_i,
			:supsdure_ind:supsdure_ind_i,
			:chng_athrty_no:chng_athrty_no_i,
			:intrchng_code:intrchng_code_i;

		if (sqlca.sqlcode == FND)
		{
			fetched_ctr++;
			errcode=initlze_segmnt04(SEGMNT04);
			if (hpx_cage_code_i == 0)
			{
			}
			else
			{
				strncpy((char *) hpx_cage_code.arr,spaces,5);
			}
			if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
			{
				strncpy(SEGMNT04->ref_no,(char *) refno.arr,refno.len);
				strncpy(SEGMNT04->cage_code,(char *) cage_code.arr,cage_code.len);
			}
			else
			{
				if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
				{
					strncpy(SEGMNT04->ref_no,CNTRL_RCD->hb_ref_no,32);
					strncpy(SEGMNT04->cage_code,CNTRL_RCD->hb_cage_code,5);
				}
				else
				{
					printf("\nfetch_av8b_supsdure_info");
					printf("\nUnable to determine HA/HB Record Type");
					printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
					printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
					printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
					printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
					printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
					printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
					printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
					printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
					errcode=1301;
					return(errcode);
				}
			}
/*			strncpy(SEGMNT04->hg_end_item_acrnym,CNTRL_RCD->mdl_acft_prf,10); */
			strncpy(SEGMNT04->hg_end_item_acrnym,(char *) mdl_acft_prf.arr,mdl_acft_prf.len);
			strncat(SEGMNT04->hg_end_item_acrnym,spaces,10-mdl_acft_prf.len);
			strncpy(SEGMNT04->prtsc04a,"04",2);
			if (supsdure_ref_no_i == 0)
			{
				strncpy(SEGMNT04->hpx_replcng_prt_no,(char *) supsdure_refno.arr,supsdure_refno.len);
			}
			else
			{
				strncpy(SEGMNT04->hpx_replcng_prt_no,spaces,32);
			}
			if (supsdure_ind_i == 0)
			{
				SEGMNT04->hpx_replcng_indctr=supsdure_ind;
			}
			else
			{
				SEGMNT04->hpx_replcng_indctr=' ';
			}
			if (chng_athrty_no_i == 0)
			{
				strncpy(SEGMNT04->hpx_replcng_chng_authrty_no,(char *) chng_athrty_no.arr,chng_athrty_no.len);
			}
			else
			{
				strncpy(SEGMNT04->hpx_replcng_chng_authrty_no,spaces,15);
			}
			if (intrchng_code_i == 0)
			{
				strncpy(SEGMNT04->hpx_replcng_intrchng_code,(char *) intrchng_code.arr,intrchng_code.len);
			}
			else
			{
				strncpy(SEGMNT04->hpx_replcng_intrchng_code,spaces,2);
			}
		
			SEGMNT04->prtsc04_eof='\0';
			SEGMNT04->prtsc04_newline='\n';

			for (i=0;i<500;i++)
			{
				outData[i]=' ';
			}
	
			#if DEBUG
				printf("\nSegmnt 04 (%s)",SEGMNT04);
			#endif
			assert(sizeof(outData)+1 >= sizeof(SEGMNT04));
			memset(outData,'\0',sizeof(outData));
			memcpy(outData,SEGMNT04,sizeof(SEGMNT04));
			errcode=write_av8b_rcd((char *) &outData,CNTRL_RCD);
		}
		else
		{
			fetched_row=1;
			CNTRL_RCD->built_04='Y';
			if (sqlca.sqlcode == NOT_FND)
			{
			}
			else
			{
				printf("\nfetch_av8b_supsdure_info");
				printf("\nUnable to Open Cursor");
				printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
				printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
				printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
				printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
				printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
				printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
				printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
				CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
				errcode=1302;
				btchslpf_dberr();
			}
		}
	}

	return(errcode);
}
static int	create_av8b_05(struct cntrl_rcd *CNTRL_RCD,struct prtsc05 *SEGMNT05) 

{

	int	errcode=0;

	#if DEBUG
		printf("\ncreate_av8b_05");
	#endif
	
        strncpy((char *) refno.arr,CNTRL_RCD->ha_ref_no,32);
	refno.arr[32]='\0';
	refno.len=32;
	strncpy((char *) cage_code.arr,CNTRL_RCD->ha_cage_code,5);
	cage_code.arr[5]='\0';
	cage_code.len=5;

	errcode=get_av8b_pricing_info(CNTRL_RCD,SEGMNT05);

	return(errcode);		
}


static int	get_av8b_pricing_info(struct cntrl_rcd *CNTRL_RCD, struct prtsc05 *SEGMNT05)
{
	int	errcode=0;
		
	#if DEBUG
		printf("\nget_av8b_pricing_info");
		printf("\nPart Number (%s)",(char *) refno.arr);
		printf("\nCage (%s)",(char *) cage_code.arr);
	#endif

	EXEC SQL OPEN pricing_av8b_csr;

	if (sqlca.sqlcode == FND)
	{
		errcode=fetch_av8b_pricing_info(CNTRL_RCD,SEGMNT05);
	}
	else
	{
		if (sqlca.sqlcode == NOT_FND)
		{
		}
		else
		{
			printf("\nget_av8b_pricing_info");
			printf("\nUnable to Open Cursor");
			printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
			printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
			printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
			printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
			printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
			printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
			printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
			CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
			errcode=1500;
			btchslpf_dberr();
		}
	}

	EXEC SQL CLOSE pricing_av8b_csr;

	return(errcode);
}

static int	fetch_av8b_pricing_info(struct cntrl_rcd *CNTRL_RCD, struct prtsc05 *SEGMNT05)
{
	int	errcode=0;
	char	spaces[]="                                ";
	int	fetched_row=0;
	int	i=0;
	char	outData[500];
		
	#if DEBUG
		printf("\nfetch_av8b_pricing_info");
	#endif

	while(!fetched_row)
	{
		errcode=initlze_segmnt05_host_var();
		EXEC SQL FETCH pricing_av8b_csr into
			:hd_refno,
			:hd_cage_code,
			:fiscyrhd,
			:uiprichd;

		#if DEBUG
			printf("\nfetch_av8b_pricing_info - Display Prices");
			printf("\nSQLCODE (%d)",sqlca.sqlcode);
			printf("\nPart Number (%s)",(char *) refno.arr);
			printf("\nCage (%s)",(char *) cage_code.arr);
		#endif
		if (sqlca.sqlcode == FND)
		{
			#if DEBUG
				printf("\nfetch_av8b_pricing_info - Display Prices");
				printf("\nUnit Prices (%s)",(char *) uiprichd.arr);
				printf("\nUnit Price I (%d)",uiprichd_i);
			#endif
			if(strncmp(CNTRL_RCD->ha_hb_code,"HA",2) == 0)
			{
				strncpy(SEGMNT05->ref_no,(char *) hd_refno.arr,hd_refno.len);
				strncpy(SEGMNT05->cage_code,(char *) hd_cage_code.arr,hd_cage_code.len);
			}
			else
			{
				if(strncmp(CNTRL_RCD->ha_hb_code,"HB",2) == 0)
				{
					strncpy(SEGMNT05->ref_no,CNTRL_RCD->hb_ref_no,32);
					strncpy(SEGMNT05->cage_code,CNTRL_RCD->hb_cage_code,5);
				}
				else
				{
					printf("\nfetch_av8b_pricing_info");
					printf("\nUnable to determine HA/HB Record Type");
					printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
					printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
					printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
					printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
					printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
					printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
					printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
					printf("\nCNTRL_RCD ha_hb_code is (%s)",CNTRL_RCD->ha_hb_code);
					errcode=1501;
					return(errcode);
				}
			}
			strncpy(SEGMNT05->prtsc05a,"05",2);
	/*		strncpy(SEGMNT05->hg_end_item_acrnym,CNTRL_RCD->mdl_acft_prf,10);   */
			strncpy(SEGMNT05->hg_end_item_acrnym,(char *) mdl_acft_prf.arr,mdl_acft_prf.len);
			strncat(SEGMNT05->hg_end_item_acrnym,spaces,10-mdl_acft_prf.len);
			strncpy(SEGMNT05->hd_fiscal_year,(char *) fiscyrhd.arr,fiscyrhd.len);
			strncpy(SEGMNT05->hd_unit_issue_price,(char *) uiprichd.arr,uiprichd.len);
			SEGMNT05->hd_unit_issue_price[10]=' ';			for (i=0;i<500;i++)
			{
				outData[i]=' ';
			}
			SEGMNT05->prtsc05_eof='\0';
			SEGMNT05->prtsc05_newline='\n';
			#if DEBUG
				printf("\nSegmnt 05 (%s)",SEGMNT05);
			#endif
			assert(sizeof(outData)+1 >= sizeof(SEGMNT05));
			memset(outData,'\0',sizeof(outData));
			memcpy(outData,SEGMNT05,sizeof(SEGMNT05));
			errcode=write_av8b_rcd((char *) &outData,CNTRL_RCD);
		}
		else
		{
			CNTRL_RCD->built_05='Y';
			fetched_row=1;
			if (sqlca.sqlcode == NOT_FND)
			{
			}
			else
			{
				printf("\nfetch_av8b_pricing_info");
				printf("\nUnable to Open Cursor");
				printf("\nCNTRL_RCD ha_eiac (%s)",CNTRL_RCD->ha_eiac);
				printf("\nCNTRL_RCD ha_ref_No (%s)",CNTRL_RCD->ha_ref_no);
				printf("\nCNTRL_RCD ha_cage_code (%s)",CNTRL_RCD->ha_cage_code);
				printf("\nCNTRL_RCD hb_ref_No (%s)",CNTRL_RCD->hb_ref_no);
				printf("\nCNTRL_RCD hb_cage_code (%s)",CNTRL_RCD->hb_cage_code);
				printf("\nCNTRL_RCD hg_lcn (%s)",CNTRL_RCD->hg_lcn);
				printf("\nCNTRL_RCD hg_alc (%s)",CNTRL_RCD->hg_alc);
				CNTRL_RCD->prf_sqlcode=sqlca.sqlcode;
				errcode=1502;
				btchslpf_dberr();
			}
		}
	}

	return(errcode);
}

static int	initlze_segmnt0102(struct prtsc01 *SEGMNT01,struct prtsc02 *SEGMNT02)
{
	int	errcode=0;
	char	spaces[]={"                                        "};

	#if DEBUG
		printf("\ninitlze_segmnt0102");
	#endif
	strncpy(SEGMNT01->ref_no,spaces,32);
	strncpy(SEGMNT01->cage_code,spaces,5);
	strncpy(SEGMNT01->filler,spaces,10);
	strncpy(SEGMNT01->ha_item_nme,spaces,19);
	strncpy(SEGMNT01->ha_prod_lead_time,spaces,4);
	strncpy(SEGMNT01->hax_sct_lead_time,spaces,2);
	strncpy(SEGMNT01->ha_unit_issue,spaces,2);
	SEGMNT01->ha_physcl_secrty=' ';
	SEGMNT01->ha_shlf_life=' ';
	strncpy(SEGMNT01->hf_qup,spaces,3);
	SEGMNT01->hax_sct_tst_reqd_flag=' ';
	strncpy(SEGMNT01->hax_sct_compltn_date,spaces,10);
	strncpy(SEGMNT01->hax_sct_authrztn_no,spaces,15);
	strncpy(SEGMNT01->hax_ps_ind,spaces,3);
	strncpy(SEGMNT01->hax_ps_scd_no,spaces,22);
	SEGMNT01->hb_arn_rncc=' ';
	strncpy(SEGMNT01->hb_arn_ref_no,spaces,32);
	strncpy(SEGMNT01->hb_arn_cage,spaces,32);
	SEGMNT01->ea_cfe_gfe=' ';
	SEGMNT01->se_item='N';
	SEGMNT01->proof_transfer_flag=' ';
	strncpy(SEGMNT02->ref_no,spaces,32);
	strncpy(SEGMNT02->cage_code,spaces,5);
	strncpy(SEGMNT02->hg_end_item_acrnym,spaces,10);
	strncpy(SEGMNT02->custmr,spaces,2);
	strncpy(SEGMNT02->ha_nsn_cog_code,spaces,2);
	SEGMNT02->ha_nsn_matl=' ';
	strncpy(SEGMNT02->ha_nsn_fsc,spaces,4);
	strncpy(SEGMNT02->ha_nsn_niin,spaces,9);
	strncpy(SEGMNT02->ha_nsn_spec_ident,spaces,2);
	strncpy(SEGMNT02->hax_nsn_cog_code,spaces,2);
	SEGMNT02->hax_nsn_matl=' ';
	strncpy(SEGMNT02->hax_nsn_fsc,spaces,4);
	strncpy(SEGMNT02->hax_nsn_niin,spaces,9);
	strncpy(SEGMNT02->hax_nsn_spec_ident,spaces,2);
	SEGMNT02->ha_aaplccha=' ';
	strncpy(SEGMNT02->hgx_suplyr_cage_code,spaces,5);

	return(errcode);
}
/*

		*/
static int	initlze_segmnt0102_host_var()
{
	int	errcode=0;
	char	spaces[]={"                                        "};

	#if DEBUG
		printf("\ninitlze_segmnt0102_host_var");
	#endif
	
	strncpy((char *) hb_refno.arr,spaces,32);
	strncpy((char *) hb_cage.arr,spaces,5);
	strncpy((char *) ha_itnameha.arr,spaces,19);
	ha_physecha=' ';
	ha_shlifeha=' ';
	strncpy((char *) ha_unitisha.arr,spaces,2);
	strncpy((char *) ha_prdldtha.arr,spaces,4);
	strncpy((char *) ha_cognsnha.arr,spaces,2);
	strncpy((char *) ha_smmnsnha.arr,spaces,2);
	ha_matnsnha=' ';
	strncpy((char *) ha_fscnsnha.arr,spaces,4);
	strncpy((char *) ha_niinsnha.arr,spaces,9);
	ha_aaplccha=' ';

	strncpy((char *) hax_sctldtme.arr,spaces,2);
	hax_scttstfg=' ';
	strncpy((char *) hax_sctcmpdt.arr,spaces,11);
	strncpy((char *) hax_sctauth.arr,spaces,16);
	strncpy((char *) hax_nicncog.arr,spaces,2);
	hax_nicnmcc=' ';
	strncpy((char *) hax_nicnfsc.arr,spaces,4);
	strncpy((char *) hax_nicnniin.arr,spaces,9);
	strncpy((char *) hax_nicnsmic.arr,spaces,2);
	strncpy((char *) hax_psind.arr,spaces,3);
	strncpy((char *) hax_psscdno.arr,spaces,22);
	intrfce_proof_transfer_flag=' ';
	
	strncpy((char *) arn_refnumha.arr,spaces,32);
	strncpy((char *) arn_cage.arr,spaces,5);
	arn_rncc=' ';
	arn_type_code=' ';
	
	strncpy((char *) hf_qtyupkhf.arr,spaces,3);
	
	se_cfegfeea=' ';
	se_item_ind='N';
	strncpy((char *) hgx_suplyrcd.arr,spaces,5);

	return(errcode);
}
/*

		*/
static int	initlze_segmnt03(struct prtsc03 *SEGMNT03)
{
	int	errcode=0;
	char    spaces[]={"                                        "};

	#if DEBUG
		printf("\ninitlze_segmnt03");
	#endif
	
	SEGMNT03->mdl_instld_on_eff=' ';
	strncpy(SEGMNT03->from_eff,spaces,5);
	strncpy(SEGMNT03->to_eff,spaces,5);
	
	return(errcode);
}

/*

		*/
static int	initlze_segmnt03_host_var()
{
	int	errcode=0;
	char    spaces[]={"                                        "};	
	
	#if DEBUG
		printf("\ninitlze_segmnt03_host_var");
	#endif
	
	series_cd=' ';
	strncpy((char *) ef_from.arr,spaces,5);
	strncpy((char *) ef_to.arr,spaces,5);
	
	return(errcode);
}	
/*

	*/
static int	initlze_segmnt04(struct prtsc04 *SEGMNT04)
{
	int	errcode=0;
	char	spaces[]="                                        ";

	#if DEBUG
		printf("\ninitlze-segmnt04");
	#endif	
	strncpy(SEGMNT04->ref_no,spaces,32);
	strncpy(SEGMNT04->cage_code,spaces,5);
	strncpy(SEGMNT04->hg_end_item_acrnym,spaces,10);
	SEGMNT04->hpx_replcng_indctr=' ';
	strncpy(SEGMNT04->hpx_replcng_prt_no,spaces,32);
	strncpy(SEGMNT04->hpx_replcng_chng_authrty_no,spaces,15);
	strncpy(SEGMNT04->hpx_replcng_intrchng_code,spaces,2);
	
	return(errcode);
}

/*
		*/
static int	initlze_segmnt04_host_var()
{
	int	errcode=0;
	char	spaces[]="                                        ";
	
	strncpy((char *) hpx_ref_no.arr,spaces,32);
	strncpy((char *) hpx_cage_code.arr,spaces,5);
	strncpy((char *) hpx_eiac.arr,spaces,10);
	strncpy((char *) supsdure_refno.arr,spaces,32);
	supsdure_ind=' ';
	strncpy((char *) chng_athrty_no.arr,spaces,15);
	strncpy((char *) intrchng_code.arr,spaces,2);
	
	return(errcode);
}
/*

		*/
static int	initlze_segmnt05(struct prtsc05 *SEGMNT05)
{
	int	errcode=0;
	char	spaces[]="                                ";
		
	#if DEBUG
		printf("\ninitlze_segmnt05");
	#endif
	
	strncpy(SEGMNT05->ref_no,spaces,32);
	strncpy(SEGMNT05->cage_code,spaces,5);
	strncpy(SEGMNT05->hg_end_item_acrnym,spaces,10);
	strncpy(SEGMNT05->hd_fiscal_year,spaces,2);
	strncpy(SEGMNT05->hd_unit_issue_price,spaces,10);
	
	return(errcode);
}
/*

		*/
static int	initlze_segmnt05_host_var()
{
	int	errcode=0;
	char	spaces[]="                                ";
		
	#if DEBUG
		printf("\ninitlze_segmnt05host_var");
	#endif
		
	strncpy((char *) hd_refno.arr,spaces,32);
	strncpy((char *) hd_cage_code.arr,spaces,5);
	strncpy((char *) fiscyrhd.arr,spaces,2);
	strncpy((char *) uiprichd.arr,spaces,10);
	
	return(errcode);
}	
/*

			*/
static int	initlze_segmnt08(struct prtsc08 *SEGMNT08)
{
	int	errcode=0;
	char    spaces[]={"                                        "};

	#if DEBUG
		printf("\ninitlze_segmnt08");
	#endif

	strncpy(SEGMNT08->ref_no,spaces,32);
	strncpy(SEGMNT08->cage_code,spaces,5);
	strncpy(SEGMNT08->hg_alt_lsa,spaces,2);
	strncpy(SEGMNT08->hg_lsaconxb,spaces,18);
	strncpy(SEGMNT08->hg_08_icc,spaces,2);
	strncpy(SEGMNT08->hgx_suplyr_cage,spaces,5);
	strncpy(SEGMNT08->hg_qpei,spaces,5);
	strncpy(SEGMNT08->hgx_nha_ref_number,spaces,32);
	strncpy(SEGMNT08->hgx_nha_cage,spaces,5);

	return(errcode);
}
/*

			*/
static int	initlze_segmnt08_host_var()
{
	int	errcode=0;
	char    spaces[]={"                                        "};

	#if DEBUG
		printf("\ninitlze_segmnt08_host_var");
	#endif
	
	proof_transfer_flag=' ';

	strncpy((char *) hbx_ref_no.arr,spaces,32);
	strncpy((char *) hbx_cage_code.arr,spaces,5);
	strncpy((char *) hbx_ha_ref_no.arr,spaces,32);
	strncpy((char *) hbx_ha_cage_code.arr,spaces,5);

	strncpy((char *) hg_eiac.arr,spaces,10);
	strncpy((char *) lsaconxb.arr,spaces,18);
	strncpy((char *) altlcnxb.arr,spaces,02);
	strncpy((char *) qtypeihg.arr,spaces,05);
	strncpy((char *) itmcathg.arr,spaces,2);
	smrcodhg_pos1=' ';
	
	strncpy((char *) hgx_ref_no.arr,spaces,32);
	strncpy((char *) hgx_cage_code.arr,spaces,5);
	strncpy((char *) hgx_suplyrcd.arr,spaces,5);
	strncpy((char *) hgx_nha.arr,spaces,32);
	strncpy((char *) hgx_nha_cage_code.arr,spaces,5);

	return(errcode);
}

#ifdef _WIN32
static void my_pause()
{
	printf("Hit any key to continue: ");
	fflush(stdout);
	getchar();
}
#endif
